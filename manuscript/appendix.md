# 5 Приложение

## 5.1 Машинное обучение

### 5.1.1 Классификация набора ирисы Фишера

Скрипт `linear-classifier.py` из листинга 5-1 демонстрирует линейную классификацию точек из набора данных ирисы Фишера. Для этой классификации используется модель логистической регрессии.

{caption: "Листинг 5-1. Скрипт для линейной классификации", line-numbers: true, format: Python}
![`linear-classifier.py`](code/ArtificialIntelligence/linear-classifier.py)

Вот общий алгоритм работы скрипта:

1. Загрузить набор данных ирисы Фишера и объединить классы ирисов 1 и 2.

2. Обучить модель линейного классификатора.

3. Вывести результат классификации в виде графике.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — содержит эталонный набор данных ирисы Фишера.

* `linear_model` из библиотеки `sklearn` — предоставляет набор моделей для линейной классификации. Кроме того в этом модуле реализован алгоритм обучения этих моделей методом [стохастического градиентного спуска](https://ru.wikipedia.org/wiki/Стохастический_градиентный_спуск).

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

* `copy` — модуль для копирования объектов.

Скрипт начинается с загрузки набора данных ирисы Фишера. Эту загрузку выполняет функция `load_iris` из модуля `datasets`. Её результат сохраняется в переменную `iris`.

Функция `load_iris` возвращает два массива: `data` и `target`. Элементы массива `data` состоят из четырёх чисел. Эти числа: длина и ширина чашелистика цветка, длина и ширина лепестка цветка. Второй массив `target` содержит коды видов ирисов: 0, 1, 2.

Элементы массивов `data` и `target` с одинаковым индексом дают полное описание конкретного растения. Например, первое растение в наборе данных имеет размеры цветка, описанные в нулевом элементе массива `data`. Вид этого растения соответствует коду в нулевом элементе массива `target`.

Далее скрипт берёт первое и второе число всех элементов массива `data`. Это выполняет следующая операция: `iris.data[:, :2]`. В результате получается массив, в котором есть только длина и ширина чашелистиков цветков. Этот массив результат записывается в переменную `x`.

В переменную `y` записывается массив `target` без изменений.

На следующем шаге скрипт объединяет виды ирисов с номерами 1 и 2 в один. Это нужно, потому что по размерам чашелистика цветка можно отличить только вид 0 от видов 1 и 2. Но растение вида 1 от растения 2 по этим признакам не отличить. Для этого нужны размеры лепестка цветка. Наш пример упрощённый. В нём модель обучается только по двум признакам. Поэтому мы обучим модель отличать ирисы вида 0 под названием Iris Setosa от остальных видов.

Чтобы объединить виды ирисов 1 и 2, выполняются два действия:

1. Все элементы массива `y` копируются в массив `y_setosa` с помощью функции `copy` из модуля `copy`.

2. Всем элементам массива `y_setosa` со значением больше 0 присваивается значение 1.

Далее скрипт создаёт объект `sgdc` класса `SGDClassifier` из модуля `linear_model`. Конструктор класса получается два параметра:

1. `loss='log_loss'` выбирает в качестве обучаемой модели логистическую регрессию.

2. `random_state=42` — параметр генератора случайных чисел. Если присвоить ему целое число, то алгоритм обучения будет выдавать одинаковый результат для одного и того же набора данных при перезапуске скрипта.

Когда объект `sgdc` создан, скрипт вызывает его метод `fit`. Этот метод реализует алгоритм обучения модели. Метод принимает в качестве входных параметров массивы `x` и `y_setosa`. Массив `x` содержит вектор входных значений, а массив `y_setosa` — вектор выходных значений для обучения модели.

После обучения модели скрипт выводит ошибку обучения. Эту ошибку возвращает метод `score` объекта `sgdc`. На вход метод принимает те же массивы `x` и `y_setosa`, что и алгоритм обучения `fit`.

Когда модель готова, скрипт строит график с результатом обучения. Для этого вызываются следующие функции из модуля `pyplot`:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости.  Функция принимает следующие параметры:
   * Первый параметр — это массив с координатами точек по оси X.
   * Второй параметр — массив с координатами точек по оси Y.
   * `c` — массив со списком цветов для каждой точки.
   * `edgecolor` — цвет границы каждой точки.

5. `plot` — рисует линию по заданному набору точек. Функция принимает следующие параметры:
   * Первый параметр — это массив с координатами точек по оси X.
   * Второй параметр — массив с координатами точек по оси Y.
   * `ls` — стиль линии (сплошная, пунктирная и т.д.).
   * `color` — цвет линии.

6. `show` — выводит на экран всё содержимое всех объектов класса `Figure`.

На графике изображена граница принятия решений линейного классификатора. Для двумерного пространства признаков эта граница — прямая линия. Скрипт строит эту линию по двум точкам: крайняя левая и крайняя правая по оси X.

Координаты крайних точек по оси X возвращает функция `plt.xlim()`. Для каждой из них скрипт рассчитывает координату Y. Этот расчёт реализован в функции `calculate_y`. Для расчёта используются следующие параметры обучаемой модели:

* `coef_` — это двумерный массив с весами каждого признака. Первый индекс каждого элемента соответствует классу, а второй — номеру признака. Значение самого элемента равно весу соответствующего признака, который определил алгоритм обучения.

* `intercept_` — это массив с константами пороговой функции.

Для расчёта координаты Y скрипт использует следующую формулу:
{line-numbers: false, format: Python}
```
(-intercept[0] - (x1 * coef[0, 0])) / coef[0, 1]
```

Возникает вопрос: почему эта формула выглядит именно так? Формула границы принятия решений выглядит так:
{width: "30%"}
![](images/Appendix/logreg-classes-border.png)

В ней используются следующие обозначения:

* z — выходное значение, которое определяет класс объекта. Если z > 0, то объект относится к классу над границей (Iris setosa). Если z < 0, объект относится к классу под границей (другой вид ириса). Если z = 0, то объект находится прямо на границе и модель не может определить его класс.

* θ~0~ — константное значение

* θ~1~ — вес признака ширина чашелистика

* x~1~ — длина чашелистика

* θ~2~ — вес признака длина чашелистика

* x~2~ — ширина чашелистика

Нам известна координата точки x~1~ по оси X. На оси X отложены длины чашелистиков. Чтобы построить линию на графике, необходимо найти координату x~2~ по оси Y. На оси Y отложены значения ширины чашелистика. Для вычисления x~2~ допустим, что значение z = 0. Другими словами мы ищем именно точку на границе раздела классов. Тогда формула расчёта значения x~2~ по x~1~ выглядит так:
{width: "30%"}
![](images/Appendix/logreg-x2-calculation.png)

Именно эту формулу вычисления x~2~ использует функция `calculate_x2`.

Иллюстрация 2-20 демонстрирует результат работы скрипта `linear-classifier.py`.

### 5.1.2 Линейная регрессия цены на поддержанные автомобили

Скрипт `linear-regression.py` из листинга 5-2 демонстрирует обучение модели линейного регрессора на случайно сгенерированном наборе данных. После обучения модель прогнозирует цену поддержанных автомобилей в зависимости от их пробега. Для обучения линейного регрессора используется метод наименьших квадратов.

{caption: "Листинг 5-2. Скрипт обучения модели линейного регрессора", line-numbers: true, format: Python}
![`linear-regression.py`](code/ArtificialIntelligence/linear-regression.py)

Вот общий алгоритм работы скрипта:

1. Сгенерировать случайный набор точек в двумерном пространстве.

2. Разделить набор точек на обучающий и тестовый.

3. Обучить модель линейного регрессора на обучающем наборе точек.

4. Получить предсказания модели для тестового набора точек.

5. Вывести результаты предсказаний модели в виде графика.

Рассмотрим каждый шаг алгоритма подробнее.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — предоставляет функции для генерации случайных наборов данных.

* `linear_model` — содержит набор моделей для линейной регрессии. Также в этом модуле реализованы алгоритмы обучения этих моделей.

* `model_selection` из библиотеки `sklearn` — предоставляет классы и функции для работы с набором данных.

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

Первый шаг скрипта — генерация случайного набора точек с помощью функции `make_regression` из модуля `datasets`. Функция возвращает два массива: 

* Векторы независимых переменных X.
* Значения зависимой переменной Y.

В нашем случае каждый вектор из массива X состоит из единственного значения — величина пробега автомобиля. Каждому вектору соответствует конкретная цена автомобиля из массива Y.

На вход `make_regression` принимает следующие параметры:

* `n_samples` — количество генерируемых точек.

* `n_features` — количество признаков объектов. Размерность выходного массива X соответствует этому параметру.

* `noise` — случайное отклонение генерируемых точек от прямой линии.

* `random_state` — параметр генератора случайных чисел. Если присвоить ему целое число, то алгоритм обучения будет выдавать одинаковый результат для одного и того же набора данных при перезапуске скрипта.

Функция `make_regression` генерирует точки с координатами от -1.5 до 1.5 по оси X и от -100 до 100 по оси Y. Эти значения не похожи на возможные величины пробега автомобилей и их цены. Чтобы приблизить сгенерированные данные к условиям нашей задачи, скрипт приводит их к следующим диапазонам значений:

* Цены на автомобили по оси Y: от 18500$ до 21500$.
* Величины пробега автомобилей по оси X: от 0 км до 4000 км.

Кроме диапазонов значений, есть ещё одна проблема со сгенерированным набором точек. Он расположен так, что с ростом значений по оси X растут значения по оси Y. В контексте нашей задачи это означает, что автомобили с большим пробегом стоят дороже. Но на самом деле зависимость между значениями X и Y обратная: чем больше пробег, тем дешевле автомобиль. Чтобы решить эту проблему, необходимо развернуть значения по оси Y.

Подготовка сгенерированного набора точек выполняется в следующих двух строчках скрипта:
{line-numbers: false, format: Python}
```
x_aligned = [(e + 3) * 800 for e in x]
y_aligned = [23000 - (e + 150) * 23 for e in y]
```

Следующее действие скрипта — разделение всех сгенерированных точек на обучающий и тестовый наборы. Это выполняет функция `train_test_split` из модуля `model_selection`. В качестве параметров она принимает массивы значений X и Y. Кроме того параметр `test_size` определяет соотношение между обучающим и тестовым набором. В нашем случае `test_size` равен 0.15. Это означает, что 15% точек войдут в тестовый набор, а 85% — в обучающий. Значения X и Y обучающего набора сохраняются в переменных `x_train` и `y_train`, а тестового — в `x_test` и `y_test`.

После подготовки обучающего и тестового набора данных, скрипт создаёт модель линейного регрессора. Она реализована в классе `LinearRegression` из модуля `linear_model`. Скрипт создаёт объект этого класси и сохраняет его в переменной с именем `regr`.

Для обучения модели вызывается метод `fit` объекта `regr`. Этот метод принимает на вход значения X и Y из обучающего набора данных. Эти значения хранятся в переменных `x_train` и `y_train`.

Обучаемая модель готова к использованию. Теперь скрипт получает предсказания модели для значений X из тестового набора данных. Эти значения хранятся в переменной `x_test`. Для получения предсказаний вызывается метод `predict` объекта `regr`. Результат его работы сохраняется в переменной `y_pred`.

Благодаря предсказаниям модели, строится наглядный график прогнозируемых и реальных цен на автомобили с пробегом. Для этого скрипт вызывает следующие функции из модуля `pyplot`:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости.

5. `plot` — рисует линию по заданному набору точек.

6. `show` — выводит на экран всё содержимое всех объектов класса `Figure`.

На графике предсказания модели изображаются синей линией. Чёрные точки соответствуют реальным ценам на автомобили с пробегом из тестового набора данных.

Иллюстрация 2-21 демонстрирует результат работы скрипта `linear-regression.py`.

### 5.1.3 Кластеризация пользователей онлайн магазина методом k-средних

Скрипт `k-mean-clustering.py` из листинга 5-3 демонстрирует кластеризацию набора точек методом k-средних.

{caption: "Листинг 5-3. Скрипт кластеризации методом k-средних", line-numbers: true, format: Python}
![`k-mean-clustering.py`](code/ArtificialIntelligence/k-mean-clustering.py)

Общий алгоритм работы скрипта выглядит так:

1. Сгенерировать случайный набор точек в двумерном пространстве.

2. Кластеризовать точки методом k-средних.

3. Вывести результат кластеризации в виде графике.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — содержит функции для генерации наборов данных. Кроме того в него входят методы загрузки эталонных наборов данных для тестирования новых алгоритмов обучения.

* `cluster` из библиотеки `sklearn` — в нём реализованы популярные алгоритмы обучения без учителя для задачи кластеризации.

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

Скрипт начинается с вызова функции [`make_blobs`](https://scikit-learn.org/stable/datasets/sample_generators.html#sample-generators) из модуля `datasets`. Эта функция генерирует кластеры точек на двумерном пространстве признаков. Координаты центров кластеров выбираются случайно. Точки каждого кластера находятся на случайном расстоянии от его центра. Эти расстояния соответствуют [нормальному распределению вероятностей](https://ru.wikipedia.org/wiki/Нормальное_распределение).

Результат генерации кластеров точек сохраняется в переменной `X`. Эта переменная представляет собой массив. Каждый его элемент соответствует одной точке. Точка представляет собой пару чисел: координаты по оси X и Y.

Далее скрипт создаёт объект класса [`KMeans`](https://scikit-learn.org/stable/modules/clustering.html#k-means) из модуля `cluster`. Этот объект сохраняется в переменной `kmeans`. В классе `KMeans` реализован алгоритм обучения методом k-средних.

В нашем случае конструктор класса `KMeans` принимает только два входных параметра:

* `n_clusters` — число кластеров, которые должна найти обучаемая модель.

* `random_state` — параметр генератора случайных чисел. Если присвоить ему целое число, то алгоритм обучения будет выдавать одинаковый результат для одного и того же набора данных при перезапуске скрипта.

После создания объекта класса `KMeans` скрипт вызывает его метод `fit` с параметром `X`. Этот метод выполняет алгоритм обучения на наборе данных, который хранится в переменной `X`.

Далее скрипт строит график с результатами обучения. Для этого из модуля `pyplot` вызываются следующие функции:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости.  Функция принимает следующие параметры:
   * Первый параметр — это массив с координатами точек по оси X.
   * Второй параметр — массив с координатами точек по оси Y.
   * `c` — массив со списком цветов для каждой точки.
   * `s` — размер точек.
   * `alpha` — уровень прозрачности от 0 (прозрачный) до 1 (непрозрачный).

5. `show` — выводит на экран всё содержимое всех объектов класса `Figure`.

Первый вызов функции `scatter` рисует все точки из сгенерированного набора. Функция принимает следующие параметры:

* `X[:,0]` — первые числа всех элементов массива `X`. Эти числа соответствуют координатам точек по оси X.

* `X[:,1]` — вторые числа всех элементов массива `X`. Эти числа соответствуют координатам точек по оси Y.

* `c=kmeans.labels_.astype(float)` — массив, каждый элемент которого соответствует точке из обучающего набора данных. Значение элемента — номер кластера к которому алгоритм обучения отнёс соответствующую точку.

Второй вызов функции `scatter` рисует центры кластеризации, которые нашёл алгоритм k-средних. Функция принимает следующие параметры:

* `centers[:, 0]` — координаты X центров всех кластеров, которые нашёл алгоритм обучения.

* `centers[:, 1]` — координаты Y центров всех кластеров, которые нашёл алгоритм обучения.

* `c='black'` — чёрный цвет, которым надо раскрасить центры кластеров.

* `s=200` — размер каждого центра кластера.

* `alpha=0.5` — полупрозрачность.

Иллюстрация 2-22 демонстрирует результат работы скрипта `k-mean-clustering.py`.

### 5.1.4 Обучение с подкреплением алгоритмом Q-learning

В отличие от предыдущих примеров скрипт для обучения агента игре в крестики-нолики большой. Будет удобнее разбираться в нём по частям. Сначала познакомимся с общим принципом работы скрипта. Затем рассмотрим каждую часть по отдельности.

Всего в скрипте есть четыре крупные части: два класса и две функции. Начнём с классов:

* `TicTacToe` — реализует среду для игры в крестики-нолики.

* `QLearningAgent` — реализует обучаемого агента для игры в крестики-нолики.

Функции в скрипте следующие:

* `train_q_learning_agent` — запускает алгоритм обучения двух агентов. Они играют против друг друга. По результатам каждой игры агенты обновляют свои таблицы Q-значений.

* `test_q_learning_agent` — тестирование двух обученных агентов. Агенты снова играют против друг друга. Но в этом случае происходит не обучение, а вывод ходов в каждой игре на экран.

Вот общий алгоритм работы скрипта:

1. Создать объект среды класса `TicTacToe` и проинициализировать его поля значениями по умолчанию.

2. Создать два объекта класса `QLearningAgent` и проинициализировать их. Эти объекты соответствуют агентам для игры в крестики-нолики.

3. Обучить агентов на серии игр друг с другом. Для этого вызвать функцию `train_q_learning_agent`.

4. Провести серию игр между обученными агентами. Для каждой игры вывести на экран её результат и ходы агентов. Для этого вызвать функцию `test_q_learning_agent`.

Рассмотрим, как реализованы классы `TicTacToe` и `QLearningAgent`. После этого познакомимся с функциями `train_q_learning_agent` и `test_q_learning_agent`. Назначение полей и методов обоих классов станет понятно из алгоритма работы функции `train_q_learning_agent`.

Класс `TicTacToe` имеет два поля:

* `board` — двумерный массив размером 3x3. Он содержит текущее состояние игрового поле. Изначально массив занулён. Если игрок X ходит в какое-то поле, соответствующий этому полю элемент массива становится равен 1. Аналогично при ходе игрока O — соответствующий полю элемент становится равен -1.

* `current_player` — номер игрока, который должен сделать ход. У игрока X номер 1, а у игрока O — это -1.

У класса `TicTacToe` есть следующие методы:

* `__init__` — инициализирует все поля класса значениями по умолчанию.

* `reset` — сбрасывает все поля класса в значения по умолчанию.

* `get_state` — возвращает текущее состояние игрового поля в виде одномерного массива.

* `is_valid_move` — проверяет, что указанный ход в указанное поле допустим.

* `make_move` — выполняет ход текущего игрока в указанное поле.

* `is_game_over` — возвращает пару значений. Первое — это состояние игры (закончилась или нет). Второе — какой из игроков одержал победу, если игра закончилась. Значения могут быть следующими: 1 — победа X, -1 — победа O, 0 — ничья.

* `print_board` — выводит на экран состояние игрового поля.

Класс агента `QLearningAgent` имеет следующие поля:

* `learning_rate` — параметр алгоритма обучения под названием скорость обучения. При инициализации получает значение 0.2.

* `discount_factor` — параметр алгоритма обучения под названием коэффициент дисконтирования. При инициализации получает значение 0.9.

* `exploration_prob` — соотношение исследования и эксплуатации при выборе действия агентом. Инициализируется значением 0.2. Это означает, что в 20% случаев агент выбирает исследование.

* `q_table` — таблица Q-значений для всех возможных пар "состояние-действие".

У класса `QLearningAgent` есть следующие методы:

* `__init__` — инициализирует все поля класса значениями по умолчанию.

* `choose_action` — выбирает действие для указанного состояния среды. При выборе учитывается соотношение исследования и эксплуатации. В случае исследования выбирается случайное действие. В случае эксплуатации — действие с максимальным Q-значением для данного состояния среды.

* `update_q_value` — обновляет таблицу Q-значений. Метод принимает на вход четыре параметра (кроме объекта класса `self`):

    * Текущее состояние среды `state`.

    * Выбранное в нём действие агента `action`.

    * Совокупное вознаграждение `reward` за действие `action`.

    * Новое состояние среды `next_state`, к которому привело действие `action`.

Метод `update_q_value` рассчитывает новое Q-значение по следующей формуле:
{height: "10%"}
![](images/ArtificialIntelligence/q-learning-formula.png)

Мы подробно рассмотрели её в разделе 2.6.2.3.1.

Первые два шага скрипта — создание и инициализация объектов. Третий шаг — обучение двух агентов игре в крестики-нолики. Для этого вызывается функция `train_q_learning_agent`. На вход она принимает три параметра:

* `env` — объект среды класса `TicTacToe`.

* `agent1` — объект класса `QLearningAgent` для первого агента. Он выбирает ходы игрока X.

* `agent2` — объект класса `QLearningAgent` для второго агента. Он выбирает ходы игрока O.

Функция не возвращает никакого значения. Вместо этого она модифицирует таблицы Q-значений обоих агентов. Другими словами, функция реализует алгоритм обучения агентов.

Вот основные шаги алгоритма функции `train_q_learning_agent`:

1. Подготовить параметры алгоритма обучения и объекты с временными данными:

* Установить число эпизодов обучения `num_episodes`. В нашем примере это 10000.

* Проинициализировать список `move_history`. В нём будут сохраняться ходы каждой игры. Затем этот список используется для обновления таблицы Q-значений обоих агентов.

2. Пройти в цикле `for` по всем эпизодам обучения. В каждом эпизоде агенты играют друг с другом один раз.

3. В начале каждого эпизода подготовить следующие объекты и переменные:

* Очистить список  `move_history` с историей ходов.

* Сбросить состояние среды `env` в начальное. Для этого вызвать метод `reset` класса `TicTacToe`.

* Получить текущее состояние среды `state` после сброса. Для этого вызвать метод `get_state` класса `TicTacToe`.

* Установить счётчик ходов `counter` в ноль.

4. Запустить бесконечный цикл `while` для одной игры.

5. В зависимости от номера хода `counter`, ход `action` выбирает один из агентов: `agent1` или `agent2`. В чётные ходы — `agent1`, в нечётные — `agent2`. Для этого вызвать метод `choose_action` класса `QLearningAgent`.

6. Проверить, что выбранный одним из агентов ход `action` разрешён правилами игры. Для этого вызвать метод `is_valid_move` класса `TicTacToe`.

7. Если ход `action` разрешён, среда его выполняет и обновляет своё текущее состояние. Для выполнения хода вызвать метод `make_move` класса `TicTacToe`.

8. Если ход `action` не разрешён, начать следующую итерацию цикла `while`. То есть перейти на шаг 4 алгоритма.

9. Прочитать новое состояние среды `next_state`, после выполнения хода `action`. Для этого вызвать метод `get_state` класса `TicTacToe`.

10. Сохранить в истории ходов `move_history` триплет: прошлое состояние среды `state`, выбранное одним агентов действие `action` и новое состояние среды `next_state`.

11. Прочитать текущее состояние игры `game_over` и её результат `result` после хода `action`. Для этого вызвать метод `is_game_over` класса `TicTacToe`

12. Если игра закончилась, завершить текущий цикл игры `while`. То есть перейти на шаг 4 алгоритма.

13. Если игра не закончилась, поменять текущее состояние среды `state` на новое `next_state` и увеличить счётчик ходов `counter` на 1.

14. Завершить очередной цикл игры `while`.

15. Пройти в цикле `for` по истории ходов `move_history`.

16. Если ход в истории чётный, обновить Q-значение для агента `agent1`. Для этого вызвать метод `update_q_value` класса `QLearningAgent`.

17. Если ход в истории нечётный, обновить Q-значение для агента `agent2`. Для этого вызвать метод `update_q_value` класса `QLearningAgent`.

18. Перейти к следующей итерации цикла `for`, который идёт по всем эпизодам обучения. То есть перейти на шаг 2 алгоритма.

После завершения функции `train_q_learning_agent` мы получим два обученных агента. Они хранятся в объектах `agent1` и `agent2`.

Может возникнуть вопрос по алгоритму функции `train_q_learning_agent`: зачем нужен список с историей ходов `move_history`? Почему нельзя обновлять таблицу Q-значений агента сразу после того, как он сделал ход? Проблема в том, что совокупное вознаграждение за сделанный ход остаётся неизвестным до тех пор, пока игра не закончится. Только после окончания игры, мы узнаем её результат: победа или поражение агента. Этот результат и есть совокупное вознаграждение за все выбранные действия. Без него невозможно правильно рассчитать новое Q-значение для ходов агента. Поэтому сначала агенты играют партию до конца. Только после этого алгоритм проходит по истории их ходов и обновляет таблицу Q-значений, исходя из результата игры.

Четвёртый шаг скрипта — тестирование обученных агентов. Для этого вызывается функция `test_q_learning_agent`. На вход она получает те же три параметра, что и функция `train_q_learning_agent`: `env`, `agent1` и `agent2`.

Функция `test_q_learning_agent` не возвращает никакого значения. Она выводит на экран результаты тестирования агентов.

Основные шаги алгоритма функции `test_q_learning_agent` следующие:

1. Подготовить параметры тестирования:

* Установить число эпизодов тестирования `num_test_episodes`. В нашем примере это 10.

2. Пройти в цикле `for` по всем эпизодам тестирования. В каждом эпизоде агенты играют друг с другом один раз.

3. В начале каждого эпизода подготовить следующие объекты и переменные:

* Сбросить состояние среды `env` в начальное. Для этого вызвать метод `reset` класса `TicTacToe`.

* Получить текущее состояние среды `state` после сброса. Для этого вызвать метод `get_state` класса `TicTacToe`.

* Установить счётчик ходов `counter` в ноль.

4. Запустить бесконечный цикл `while` для одной игры.

5. В зависимости от номера хода `counter`, ход `action` выбирает один из агентов: `agent1` или `agent2`. В чётные ходы — `agent1`, в нечётные — `agent2`. Для этого вызвать метод `choose_action` класса `QLearningAgent`.

6. Проверить, что выбранный одним из агентов ход `action` разрешён правилами игры. Для этого вызвать метод `is_valid_move` класса `TicTacToe`.

7. Если ход `action` разрешён, среда его выполняет и обновляет своё текущее состояние. Для выполнения хода вызвать метод `make_move` класса `TicTacToe`.

8. Если ход `action` не разрешён, начать следующую итерацию цикла `while`. То есть перейти на шаг 4 алгоритма.

9. Вывести на экран состояние игрового поля после выполнения хода `action`. Для этого вызвать метод `print_board` класса `TicTacToe`.

10. Прочитать текущее состояние игры `game_over` и её результат `result` после хода `action`. Для этого вызвать метод `is_game_over` класса `TicTacToe`

12. Если игра закончилась, вывести на экран её результат и завершить текущий цикл игры `while`. То есть перейти на шаг 4 алгоритма.

13. Прочитать новое состояние среды после выполнения хода `action` и сохранить его в переменной `state`. Для этого вызвать метод `get_state` класса `TicTacToe`.

14. Увеличить счётчик ходов `counter` на 1

15. Перейти к следующей итерации цикла `for`, который идёт по всем эпизодам тестирования. То есть перейти на шаг 2 алгоритма.

После завершения функции `test_q_learning_agent` на экран выводятся результаты десяти игр между агентам `agent1` и `agent2`. Пример вывода для одной игры демонстрирует листинг 5-4.

{caption: "Листинг 5-4. Вывод результата тестовой игры", line-numbers: false, format: text}
```
- - -
- X -
- - -

O - -
- X -
- - -

O - -
X X -
- - -

O - -
X X O
- - -

O - X
X X O
- - -

O - X
X X O
O - -

O X X
X X O
O - -

O X X
X X O
O O -

O X X
X X O
O O X

Ничья!
```

Полный скрипт обучения агентов методом Q-learning доступен на [Github странице проекта](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/q-learning.py).

## 5.2 Современные шахматные движки

### 5.2.1 Применение вертикального фильтра Собеля

Скрипт `sobel-vertical-filter.py` из листинга 5-5 демонстрирует применение вертикального фильтра Собеля к исходной фотографии. Чтобы запустить скрипт скачайте его и [фотографию Лены Сёдерберг](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/Chess/lena.png) в один каталог. Пожалуйста, не меняйте имена файлов.

{caption: "Листинг 5-5. Скрипт для линейной классификации", line-numbers: true, format: Python}
![`sobel-vertical-filter.py`](code/Chess/sobel-vertical-filter.py)

Вот общий алгоритм работы скрипта:

1. Подготовка входных данных.

2. Применение фильтра к цветовым каналом фотографии.

3. Визуализация карт признаков в виде RGB изображения.

Для работы скрипт импортирует следующие модули и библиотеки:

* Библиотека `numpy` для работы с массивами.

* Модуль `pyplot` из библиотеки `matplotlib` предоставляет интерфейс для вывода изображений.

* Функция `convolve` из библиотеки `scipy` выполняет операцию свёртки.

В начале скрипта объявляется двумерный массив `sobel_vertical` размера 3x3 с вертикальным фильтром Собеля. Он сохраняется в объект `array` из библиотеки `numpy`. Объект предоставляет удобный интерфейс для работы с массивами.

На следующем шаге скрипт загружает фотографию из файла `lena.png`. Для загрузки вызывается функция `imread` из модуля `pyplot`. Она возвращает объект `array` с массивом пикселей загруженной фотографии. Для RGB изображений массив имеет размер `(M, N, 3)`. Где M — это ширина исходного изображения в пикселях, а N — его высота. Другими словами мы получили стек из трёх изображений: по одному для каждого цветового канала.

Далее скрипт применяет вертикальный фильтр Собеля к каждому из трёх цветовых каналов изображения. Для этого в цикле `for` с тремя итерациями вызывается функция `convolve` из библиотеки `scipy`. Функция принимает на воход два параметра:

1. `img[:,:,channel]` — массив пикселей исходного изображения из цветового канала с индексом `channel`.

2. `sobel_vertical` — массив с вертикальным фильтром Собеля.

Функция возвращает карту признаков с результатом операции свёртки. Она представляет собой объект `array`. Объект записывается во временную переменную с именем `result`. Эта временная переменная добавляется в список (объект `list`) с именем `channels`.

После окончания выполнения фильтра `for` мы получим список `channels` с тремя элементами. Каждый элемент — это объект `array` с картой признаков для соответствующего цветового канала исходно изображения.

На следующем шаге скрипт комбинирует все три элемента из списка `channels` в один массив. Для этого вызывается функция `dstack` из библиотеки `numpy`. Эта функция не меняет элементы входных массивов, а только упорядочивает их по третьему измерению. Таким образом из трёх массивов мы получаем изображение с тремя цветовыми каналами. Его мы сохраняем в виде объекта `array` в переменную `img`. 

I> Подробнее работа функции `dstack` описана в [статье](https://www.educative.io/answers/what-is-the-numpydstack-function-in-numpy).

Функция `dstack` вернула нам массив пикселей RGB изображения. Для его визуализации скрипт вызывает функцию `imshow` из библиотеки `matplotlib`. Эта функция принимает на вход объект `array` из переменной `img`.

Последнее действие скрипта — открыть окно с финальным RGB изображением. Для этого вызывается функция `show ` библиотеки `matplotlib`. Эта функция не имеет входных параметров.

Иллюстрация 3-41 демонстрирует результат работы скрипта `sobel-vertical-filter.py`.

### 5.2.2 Применение фильтра для изображения

Скрипт `apply-filter-manually.py` из листинга 5-6 демонстрирует выполнение операции свёртки без функции `convolve` из библиотеки `scipy`. Чтобы увидеть результаты скрипта, запустите его из интерпретатора командной строки. Это `cmd.exe` для Windows или Bash для Linux.

{caption: "Листинг 5-6. Скрипт для линейной классификации", line-numbers: true, format: Python}
![`apply-filter-manually.py`](code/Chess/apply-filter-manually.py)

Вот общий алгоритм работы скрипта:

1. Подготовка входных данных.

2. Выполнение произведения Адамара во вложенном цикле.

3. Вывод результата на консоль.

Для работы скрипт импортирует только библиотеку `numpy` для операций с массивами.

В начале скрипта объявляется двумерный массив `sobel_vertical` размера 3x3 с вертикальным фильтром Собеля. Он помещается в объект `array` из библиотеки `numpy`.

Далее объявляется массив `image` размера 5x5 c пикселями исходного чёрно-белого изображения. Он также помещается в объект `array`.

На следующем шаге объявляются три пустых массива:

1. `tmp` — временно хранит пиксели исходного изображения, которые на текущем шаге перекрыл фильтр. Размер этого двумерного массива 3x3 соответствует размеру фильтра.

2. `row` — временно хранит элементы одной строки карты признаков. Максимальный размер этого одномерного массива 3.

3. `result` хранит финальную карту признаков, которая получилась в результате операции свёртки. Размер этого массива 3x3.

После подготовки входных данных и временных массивов скрипт выполняет [**вложенный цикл**](https://education.yandex.ru/handbook/python/article/vlozhennye-cikly). Внешний цикл выполняет следующий оператор `for`:
{line-numbers: false, format: Python}
```
for i in range(1, 4):
```

Он проходит по строкам исходного изображения. Нумерация строк начинается с 0. Тогда в нашем случае последняя строка изображения имеет индекс 4. Функция `range(1, 4)` возвращает массив `[1, 2, 3]`. Цикл проходит по элементам этого массива. На каждой итерации очередной элемент записывается в переменную с именем `i`.

Внутренний цикл выполняет следующий оператор `for`:
{line-numbers: false, format: Python}
```
   for j in range(1, 4):
```

Он проходит по столбцам исходного изображения. На каждой из трёх итераций оператор `for` записывает очередной элемент массива `[1, 2, 3]` в переменную с именем `j`.

На каждой итерации внутреннего цикла `for` выполняются три действия:

1. Сохранить во временный массив `tmp` пиксели исходного изображения, которые перекрыл фильтр. Это три строки пикселей, которые начинаются с индекса `i-1` и заканчивая `i+1`. Ряды пикселей в этих строках начинаются с индекса `j-1` и заканчиваются `j+1`.

2. Выполнить произведение Адамара. Его результат представляет собой одно число, которое записывается в конец массива `row`. Произведение Адамара выполняется за два шага:

* Вызов функции `multiply` из библиотеки `numpy`. Она получает на вход два массива и перемножает их элементы с одинаковыми индексами. Это означает, что первый элемент умножается на первый, второй на второй и т.д. Результат функции возвращается в виде массива в `array` объекте.

* Вызов функции `sum` из библиотеки `numpy`. Она получает на вход один массив и скалывает все его элементы между собой.

3. Очистить временный массив `tmp` для подготовки к следующей итерации внутреннего цикла `for`.

На каждой итерации внешнего цикла `for` выполняются три действия:

1. Запустить внутренний цикл `for` с самого начала.

2. Записать результат выполнения внутреннего цикла `for` в конец массива `result`. Этот результат хранится во временном массиве `row`.

3. Очистить временный массив `row` для подготовки к следующей итерации внешнего цикла `for`.

После завершения внешнего цикла `for` результат работы скрипта хранится в массиве `result`. Он выводится на консоль с помощью функции `print`. Этот вывод выглядит следующим образом:
{line-numbers: false, format: Python}
```
[[-38, -190, -365], [-252, -204, -239], [37, 251, 429]]
```

{pagebreak}
