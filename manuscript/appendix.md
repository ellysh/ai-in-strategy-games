# 5 Приложение

## 5.1 Машинное обучение

### 5.1.1 Классификация набора ирисы Фишера

Листинг 5-1 демонстрирует код скрипта [`linear-classifier.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/linear-classifier.py). Он классифицирует растения из набора данных ирисы Фишера. Для этого скрипт использует модель логистической регрессии.

{caption: "Листинг 5-1. Скрипт для классификации ирисов Фишера", line-numbers: true, format: Python}
![`linear-classifier.py`](code/ArtificialIntelligence/linear-classifier.py)

Вот общий алгоритм работы скрипта:

1. Загрузить набор данных ирисы Фишера и объединить классы ирисов 1 и 2.

2. Обучить модель линейного классификатора.

3. Вывести результат классификации в виде графика.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — содержит эталонный набор данных: ирисы Фишера.

* `linear_model` из библиотеки `sklearn` — предоставляет набор моделей линейных классификаторов. В модуле также реализован алгоритм обучения этих моделей методом [стохастического градиентного спуска](https://ru.wikipedia.org/wiki/Стохастический_градиентный_спуск).

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

* `copy` — модуль для копирования объектов.

Скрипт начинается с загрузки набора данных ирисы Фишера. Эту загрузку выполняет функция `load_iris` из модуля `datasets`. Её результат сохраняется в переменную `iris`.

Функция `load_iris` возвращает два массива: `data` и `target`. Каждый элемент массива `data` состоит из четырёх чисел: длина и ширина чашелистика цветка, длина и ширина лепестка цветка. Элементы второго массива `target` — это коды одного из трёх видов ириса: 0, 1 или 2.

Пара элементов массивов `data` и `target` с одинаковым индексом полностью описывает конкретное растение из набора данных. Например, элемент с индексом ноль в массиве `data` даёт размеры его цветка. Вид этого растения соответствует коду из нулевого элемента массива `target`. То же самое выполняется для пары первых элементов, вторых, третьих и т.д.

После загрузки набора данных скрипт сохраняет массивы `data` и `target` из переменной `iris` в отдельные переменные `x` и `y`. В массив `x` попадает только длина и ширина чашелистика каждого цветка. Такой результат даёт следующая операция:
{line-numbers: false, format: Python}
```
x = iris.data[:, :2]
```

Массив `target` записывается в переменную `y` без изменений.

Наш скрипт — это упрощённый пример. В нём модель обучается только по двум признакам: ширина и длина чашелистика цветка. Поэтому она сможет отличать только ирисы вида 0 под названием Iris Setosa от остальных видов. Но растения видов 1 и 2 по этим признакам не различить.

Чтобы подготовить обучающий наборы данных для нашей классификации, надо объединить виды ирисов 1 и 2 в один класс. Дадим ему номер 1. Для этого скрипт выполняет два действия:

1. Все элементы массива `y` копируются в массив `y_two_classes` с помощью функции `copy` из модуля `copy`.

2. Всем элементам массива `y_two_classes` со значением больше 0 присваивается значение 1.

Далее скрипт создаёт объект `sgdc` класса `SGDClassifier` из модуля `linear_model`. Конструктор класса получает два параметра:

1. `loss='log_loss'` выбирает в качестве обучаемой модели логистическую регрессию.

2. `random_state=42` — параметр генератора случайных чисел. Если присвоить ему целое число, то алгоритм обучения будет выдавать одинаковый результат для одного и того же набора данных при перезапуске скрипта.

Когда объект `sgdc` создан, скрипт вызывает его метод `fit`. Этот метод реализует алгоритм обучения модели. Метод принимает в качестве входных параметров массивы `x` и `y_two_classes`. Массив `x` содержит вектор входных значений, а массив `y_two_classes` — вектор выходных значений для алгоритма обучения модели.

Когда метод `fit` заканчивает работу, скрипт выводит ошибку обучения (training error). Её возвращает метод `score` объекта `sgdc`. На вход метод принимает те же массивы `x` и `y_two_classes`, что и алгоритм обучения `fit`.

Когда модель готова, скрипт выводит график с результатом обучения. Для этого он вызывает следующие функции из модуля `pyplot`:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости. Функция принимает следующие параметры:
   * Первый параметр — массив с координатами точек по оси X.
   * Второй параметр — массив с координатами точек по оси Y.
   * `c` — массив со списком цветов для каждой точки.
   * `edgecolor` — цвет границы каждой точки.

5. `plot` — рисует линию по заданному набору точек. Функция принимает следующие параметры:
   * Первый параметр — массив с координатами точек линии по оси X.
   * Второй параметр — массив с координатами точек линии по оси Y.
   * `ls` — стиль линии (сплошная, пунктирная и т.д.).
   * `color` — цвет линии.

6. `show` — выводит на экран всё содержимое глобального объекта класса `Figure`.

На графике изображена граница принятия решений линейного классификатора. Для двумерного пространства признаков эта граница — прямая линия. Она строится по двум точкам: крайняя левая и крайняя правая по оси X.

Координаты крайних точек по оси X возвращает функция `plt.xlim()`. Для каждой из них скрипт рассчитывает координату Y. Этот расчёт реализует функция `calculate_y`. Для расчёта используются два параметра класса `sgdc`:

* `coef_` — это двумерный массив с весами каждого признака. Первый индекс каждого элемента соответствует классу, а второй — номеру признака. Значение самого элемента равно весу соответствующего признака, который подобрал алгоритм обучения.

* `intercept_` — это массив с константами пороговой функции.

Для расчёта координаты Y скрипт использует следующую формулу:
{line-numbers: false, format: Python}
```
(-intercept[0] - (x * coef[0, 0])) / coef[0, 1]
```

Разберёмся, почему формула расчёта координаты Y выглядит именно так. Вот общий вид формулы границы принятия решений для модели логистической регрессии:
{width: "30%"}
![](images/Appendix/logreg-classes-border.png)

В ней используются следующие обозначения:

* z — выходное значение, которое определяет класс объекта. Если z > 0, то объект относится к классу над границей (Iris Setosa). Если z < 0, объект относится к классу под границей (другой вид ириса). Если z = 0, то объект находится прямо на границе и модель не может определить его класс.

* θ~0~ — константное значение

* θ~1~ — вес признака длина чашелистика

* x~1~ — длина чашелистика

* θ~2~ — вес признака ширина чашелистика

* x~2~ — ширина чашелистика.

Нам известна координата точки x~1~ по оси X. На оси X отложены длины чашелистиков. Чтобы построить линию на графике, необходимо найти координату x~2~ по оси Y. На оси Y отложены значения ширины чашелистика. Для вычисления x~2~ допустим, что значение z = 0. Другими словами, мы ищем именно точку на границе раздела классов. Тогда формула расчёта значения x~2~ по x~1~ выглядит так:
{width: "30%"}
![](images/Appendix/logreg-x2-calculation.png)

Именно эту формулу использует функция `calculate_y`.

Иллюстрация 2-18 демонстрирует результат работы скрипта `linear-classifier.py`.

### 5.1.2 Линейная регрессия цены на поддержанные автомобили

Листинг 5-2 демонстрирует код скрипта [`linear-regression.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/linear-regression.py). Он прогнозирует цену поддержанных автомобилей в зависимости от их пробега. Для этого скрипт использует модель линейной регрессии.

{caption: "Листинг 5-2. Скрипт для прогноза цены на автомобили", line-numbers: true, format: Python}
![`linear-regression.py`](code/ArtificialIntelligence/linear-regression.py)

Вот общий алгоритм работы скрипта:

1. Сгенерировать случайный набор точек в двумерном пространстве.

2. Разделить набор точек на обучающий и тестовый.

3. Обучить модель линейной регрессии на обучающем наборе точек.

4. Получить предсказание модели для тестового набора точек.

5. Вывести предсказание модели в виде графика.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — предоставляет функции для генерации случайных наборов данных.

* `linear_model` — содержит набор моделей линейной регрессии и алгоритмы для их обучения.

* `model_selection` из библиотеки `sklearn` — предоставляет классы и функции для работы с набором данных.

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

Первый шаг скрипта — генерация случайного набора точек. Для этого вызывается функция `make_regression` из модуля `datasets`. Функция возвращает два массива: 

* Векторы независимых переменных X.
* Значения зависимой переменной Y.

В нашем случае каждый вектор из массива X состоит из единственного значения — пробег автомобиля. Каждому вектору соответствует цена автомобиля из массива Y. Элементы массивов X и Y с одинаковым индексом относятся к одному обучающему примеру. Например, нулевой элемент массива X — это пробег конкретного автомобиля, а нулевой элемент массива Y — его цена.

На вход функция `make_regression` принимает следующие параметры:

* `n_samples` — количество генерируемых точек.

* `n_features` — количество признаков объектов. Размер векторов в выходном массиве X соответствует этому параметру.

* `noise` — случайное отклонение генерируемых точек от прямой линии.

* `random_state` — параметр генератора случайных чисел. Если присвоить ему целое число, каждый последующий вызов функции будет возвращать тот же результат.

Функция `make_regression` генерирует точки с координатами от -1.5 до 1.5 по оси X и от -100 до 100 по оси Y. Эти диапазоны не соответствуют нашей задаче. Пробег автомобиля не может быть от -1.5 км до 1.5 км, а его цена не может быть от -100$ до 100$. Чтобы решить эту проблему, скрипт приводит сгенерированные данные к следующим диапазонам:

* Цены на автомобили по оси Y: от 18500$ до 21500$.

* Величины пробега автомобилей по оси X: от 0 км до 4000 км.

Есть ещё одна проблема со сгенерированным набором точек. Они расположены так, что с ростом значений по оси X растут значения по оси Y. В контексте нашей задачи это означает, что автомобили с большим пробегом стоят дороже. Но на самом деле зависимость между значениями X и Y обратная: чем больше пробег, тем дешевле автомобиль. Чтобы решить эту проблему, необходимо развернуть направление точек с восходящего на нисходящее.

Следующие две строчки скрипта приводят сгенерированные данные к нужным диапазонам и меняют направление точек на нисходящее:
{line-numbers: false, format: Python}
```
x_aligned = [(e + 3) * 800 for e in x]
y_aligned = [23000 - (e + 150) * 23 for e in y]
```

Второй шаг скрипта — разделить сгенерированные точки на обучающий и тестовый наборы. Для этого скрипт вызывает функцию `train_test_split` из модуля `model_selection`. В качестве параметров она принимает массивы X и Y. Третий параметр функции `test_size` определяет соотношение между обучающим и тестовым набором. В нашем случае `test_size` равен 0.15. Это означает, что 15% точек войдут в тестовый набор, а 85% — в обучающий. Обучающий набора данных сохраняется в массивах `x_train` и `y_train`, а тестовый — в `x_test` и `y_test`.

После подготовки обучающего и тестового набора данных, скрипт создаёт модель линейной регрессии. Она реализована в классе `LinearRegression` из модуля `linear_model`. Скрипт создаёт объект этого класса и сохраняет его в переменной `regr`.

Для обучения модели вызывается метод `fit` объекта `regr`. Метод принимает на вход обучающий набор данных в виде двух массивов: `x_train` и `y_train`.

После завершения метода `fit` модель готова к применению. Скрипт использует её, чтобы предсказать цену на автомобили из тестового набора данных. Для этого вызывается метод `predict` объекта `regr`. На вход он принимает массив `x_test`. Результат сохраняется в массиве `y_pred`.

На последнем шаге скрипт строит график предсказанных и реальных цен на автомобили из тестового набора данных. Для этого он вызывает следующие функции из модуля `pyplot`:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости.

5. `plot` — рисует линию по заданному набору точек.

6. `show` — выводит на экран всё содержимое глобального объекта класса `Figure`.

Предсказанные моделью цены изображаются на графике синей линией. Чёрные точки соответствуют реальным ценам на автомобили из тестового набора данных.

Иллюстрация 2-19 демонстрирует результат работы скрипта `linear-regression.py`.

### 5.1.3 Кластеризация пользователей онлайн магазина методом k-средних

Листинг 5-3 демонстрирует код скрипта [`k-mean-clustering.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/k-mean-clustering.py). Он выполняет кластеризацию пользователей онлайн магазина методом k-средних.

{caption: "Листинг 5-3. Скрипт для кластеризации пользователей онлайн магазина", line-numbers: true, format: Python}
![`k-mean-clustering.py`](code/ArtificialIntelligence/k-mean-clustering.py)

Общий алгоритм работы скрипта выглядит так:

1. Сгенерировать случайный набор точек в двумерном пространстве.

2. Кластеризовать точки методом k-средних.

3. Вывести результат кластеризации в виде графика.

Для работы скрипт импортирует следующие модули:

* `datasets` из библиотеки `sklearn` — предоставляет функции для генерации случайных наборов данных.

* `cluster` из библиотеки `sklearn` — в нём реализованы алгоритмы обучения без учителя для моделей кластеризации.

* `pyplot` из библиотеки `matplotlib` — это интерфейс для построения графиков.

Скрипт начинается с вызова функции [`make_blobs`](https://scikit-learn.org/stable/datasets/sample_generators.html#sample-generators) из модуля `datasets`. Эта функция генерирует кластеры точек на двумерном пространстве признаков. Координаты центров кластеров выбираются случайно. Точки каждого кластера находятся на случайном расстоянии от его центра. Эти расстояния соответствуют [нормальному распределению вероятностей](https://ru.wikipedia.org/wiki/Нормальное_распределение).

Функция `make_blobs` принимает на вход следующие параметры:

1. `n_samples` — общее количество точек, которые будут сгенерированы. Каждый кластер получит примерно одинаковое количество точек.

2. `centers` — количество центров кластеров, около которых будут находиться точки.

3. `cluster_std` — стандартное отклонение точек от центров кластеров.

4. `random_state` — параметр генератора случайных чисел. Если присвоить ему целое число, каждый последующий вызов функции будет возвращать тот же результат.

5. `center_box` — ограничительная рамка для каждого центра кластера. За эту рамку не попадут точки, относящиеся к кластеру.

Результат функции `make_blobs` сохраняется в массиве `x`. Каждый его элемент соответствует одной точке. Точка представляет собой пару чисел: координаты по осям X и Y. В терминах нашей задачи точка — это конкретный посетитель онлайн магазина. Её координата по оси X определяет, сколько раз посетитель просматривал товары категории автозапчасти. Координата по оси Y — число просмотров товаров категории велозапчасти.

Второй шаг — скрипта кластеризация точек. Для этого создаётся объект класса [`KMeans`](https://scikit-learn.org/stable/modules/clustering.html#k-means) из модуля `cluster`. Этот объект сохраняется в переменной `kmeans`. В классе `KMeans` реализован алгоритм обучения методом k-средних.

В нашем случае конструктор класса `KMeans` принимает только два входных параметра:

1. `n_clusters` — число кластеров, которые должна найти обучаемая модель.

2. `random_state` — параметр генератора случайных чисел.

Чтобы запустить алгоритм обучения, скрипт вызывает метод `fit` объекта `kmeans`. В качестве параметра ему передаётся массив `x`. Этот метод выполняет алгоритм обучения на полученном наборе данных.

На третьем шаге скрипт строит график с результатами кластеризации. Для этого из модуля `pyplot` вызываются следующие функции:

1. `figure` — конструктор глобального объекта класса `Figure`. Он хранит все видимые графические элементы.

2. `xlabel` — указывает надпись для оси X.

3. `ylabel` — указывает надпись для оси Y.

4. `scatter` — рисует набор точек на плоскости.  Функция принимает следующие параметры:
   * Первый параметр — массив с координатами точек по оси X.
   * Второй параметр — массив с координатами точек по оси Y.
   * `c` — массив со списком цветов для каждой точки.
   * `s` — размер точек.
   * `alpha` — уровень прозрачности от 0 (прозрачный) до 1 (непрозрачный).

5. `show` — выводит на экран всё содержимое глобального объекта класса `Figure`.

Функция `scatter` вызывается дважды. Первый вызов рисует все точки из сгенерированного набора. Для этого функция принимает на вход следующие параметры:

1. `x[:,0]` — первые числа всех элементов массива `x`. Эти числа соответствуют координатам точек по оси X.

2. `x[:,1]` — вторые числа всех элементов массива `x`. Эти числа соответствуют координатам точек по оси Y.

3. `c=kmeans.labels_.astype(float)` — массив, каждый элемент которого соответствует точке из обучающего набора данных. Значение элемента — номер кластера к которому алгоритм обучения отнёс соответствующую точку.

Второй вызов функции `scatter` рисует центры кластеризации, которые нашёл алгоритм k-средних. Функция принимает следующие параметры:

1. `centers[:, 0]` — координаты X центров всех кластеров, которые нашёл алгоритм обучения.

2. `centers[:, 1]` — координаты Y центров всех кластеров, которые нашёл алгоритм обучения.

3. `c='black'` — чёрный цвет, которым надо раскрасить центры кластеров.

4. `s=200` — размер каждого центра кластера.

5. `alpha=0.5` — полупрозрачность.

Иллюстрация 2-20 демонстрирует результат работы скрипта `k-mean-clustering.py`.

### 5.1.4 Обучение с подкреплением алгоритмом Q-learning

Рассмотрим скрипт [`q-learning.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/q-learning.py) для обучения агента игре крестики-нолики. В отличие от предыдущих примеров он большой. Поэтому его полный код в книге не приводится. Он доступен на [Github странице проекта](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/ArtificialIntelligence/q-learning.py).

Сначала мы разобьём скрипт на логические части. Затем рассмотрим их взаимодействие и общий принцип работы скрипта. После этого подробно рассмотрим устройство каждой части.

Скрипт состоит из четырёх логических частей: два класса и две функции. Начнём с классов:

* `TicTacToe` — реализует среду для игры в крестики-нолики.

* `QLearningAgent` — реализует одного агента для игры в крестики-нолики.

Функции в скрипте следующие:

* `train_q_learning_agent` — запускает алгоритм обучения для двух агентов. Они многократно играют против друг друга. По результатам каждой игры агенты обновляют свои таблицы Q-значений.

* `test_q_learning_agent` — тестирует двух обученных агентов. Агенты снова играют против друг друга несколько партий. Функция выводит их ходы и результаты игр на экран. При этом алгоритм обучения не выполняется.

Вот общий алгоритм работы скрипта:

1. Создать объект среды класса `TicTacToe` и проинициализировать его поля значениями по умолчанию.

2. Создать два объекта класса `QLearningAgent` и проинициализировать их. Эти объекты соответствуют двум агентам для игры в крестики-нолики.

3. Обучить агентов на серии игр друг с другом. Для этого вызвать функцию `train_q_learning_agent` и передать в неё все три объекта.

4. Провести серию игр между обученными агентами. Для каждой игры вывести на экран её результат и ходы агентов. Для этого вызвать функцию `test_q_learning_agent` и передать в неё все три объекта.

Рассмотрим, как реализованы классы `TicTacToe` и `QLearningAgent`. После этого познакомимся с функциями `train_q_learning_agent` и `test_q_learning_agent`. Назначение полей и методов обоих классов станет понятно из алгоритма работы функции `train_q_learning_agent`.

Класс `TicTacToe` имеет два поля:

1. `board` — двумерный массив размером 3x3. Он хранит текущее состояние игрового поле. Изначально массив занулен. Если игрок X ходит в какое-то поле, соответствующий этому полю элемент массива выставляется в 1. Аналогично при ходе игрока O — соответствующий полю элемент выставляется в -1.

2. `current_player` — номер игрока, который сейчас делает ход. У игрока X номер 1, а у игрока O — номер -1.

У класса `TicTacToe` есть следующие методы:

1. `__init__` — инициализирует все поля класса значениями по умолчанию.

2. `reset` — сбрасывает все поля класса в значения по умолчанию.

3. `get_state` — возвращает текущее состояние игрового поля в виде одномерного массива.

4. `is_valid_move` — проверяет, что ход в указанное поле допустим.

5. `make_move` — выполняет ход текущего игрока (`current_player`) в указанное поле.

6. `is_game_over` — возвращает пару значений. Первое — это состояние игры: закончилась или ещё нет. Второе — какой из игроков выиграл, если игра закончилась. Второе значение может быть следующим: 1 — победа X, -1 — победа O, 0 — ничья.

7. `print_board` — выводит на экран состояние игрового поля.

Класс агента `QLearningAgent` имеет следующие поля:

1. `learning_rate` — параметр алгоритма обучения под названием скорость обучения. При инициализации он получает значение 0.2.

2. `discount_factor` — параметр алгоритма обучения под названием коэффициент дисконтирования. При инициализации он получает значение 0.9.

3. `exploration_prob` — соотношение стратегий исследования и эксплуатации при выборе действия агентом. Инициализируется значением 0.2. Это означает, что в 20% случаев агент выбирает исследование, а в 80% случаев — эксплуатацию.

4. `q_table` — таблица Q-значений для всех возможных пар "состояние-действие".

У класса `QLearningAgent` есть следующие методы:

1. `__init__` — инициализирует все поля класса значениями по умолчанию.

2. `choose_action` — выбирает ход для указанного состояния среды. При выборе учитывается соотношение стратегий исследования и эксплуатации. В случае исследования выбирается случайный ход. В случае эксплуатации — ход с максимальным Q-значением для данного состояния среды.

3. `update_q_value` — обновляет таблицу Q-значений. Метод принимает на вход четыре параметра (кроме объекта класса `self`):
   * Текущее состояние среды `state`.
   * Действие агента `action` для текущего состояния среды.
   * Совокупное вознаграждение `reward` за действие `action`.
   * Новое состояние среды `next_state`, к которому привело действие агента `action`.

Метод `update_q_value` рассчитывает новое Q-значение по следующей формуле:
{width: "100%"}
![](images/ArtificialIntelligence/q-learning-formula.png)

Мы подробно рассмотрели её в разделе 2.6.2.3.1. Вы можете ещё раз вернуться к её описанию.

Первые два шага скрипта — создание и инициализация объектов. Для этого вызываются конструкторы соответствующих классов:
{line-numbers: false, format: Python}
```
# Создать объект среды класса TicTacToe
env = TicTacToe()

# Создать объект первого агента
agent1 = QLearningAgent()

# Создать объект второго агента
agent2 = QLearningAgent()
```

Конструктор каждого класса вызывает метод `__init__`. Таким образом поля всех объектов инициализируются значениями по умолчанию.

Третий шаг скрипта — обучение двух агентов игре в крестики-нолики. Для этого вызывается функция `train_q_learning_agent`. На вход она принимает три параметра:

1. `env` — объект среды класса `TicTacToe`.

2. `agent1` — объект первого агента (класс `QLearningAgent`). Он делает ходы игрока X.

3. `agent2` — объект второго агента (класс `QLearningAgent`). Он делает ходы игрока O.

Функция меняет таблицы Q-значений обоих агентов. В результате агенты учатся делать ходы, которые с большей вероятностью ведут к победе. Таким образом функция реализует алгоритм их обучения.

Функция `train_q_learning_agent` работает по следующему алгоритму:

1. Подготовить параметры алгоритма обучения и переменные с временными данными:
   * Установить число эпизодов обучения `num_episodes`. В нашем примере это 10000.
   * Проинициализировать список `move_history`. В нём сохраняются ходы каждой игры. Затем этот список используется для обновления таблицы Q-значений обоих агентов.

2. Пройти в цикле `for` по всем эпизодам обучения. В каждом эпизоде агенты играют друг с другом один раз.

3. В начале каждого эпизода подготовить следующие объекты и переменные:
   * Очистить список  `move_history` с историей ходов.
   * Сбросить состояние среды `env` в начальное. Для этого вызвать метод `reset` класса `TicTacToe`.
   * Получить текущее состояние среды `state` после сброса. Для этого вызвать метод `get_state` класса `TicTacToe`.
   * Установить счётчик ходов `counter` в ноль.

4. Запустить бесконечный цикл `while` для одной игры.

5. В зависимости от счётчика `counter`, ход `action` делает `agent1` или `agent2`. В чётные ходы — `agent1`, в нечётные — `agent2`. Для этого вызвать метод `choose_action` соответствующего объекта класса `QLearningAgent`.

6. Проверить, что выбранный одним из агентов ход `action` разрешён правилами игры. Для этого вызвать метод `is_valid_move` объекта `env` класса `TicTacToe`.

7. Если ход `action` разрешён, среда его выполняет и обновляет своё текущее состояние. Для выполнения хода вызвать метод `make_move` объекта `env` класса `TicTacToe`.

8. Если ход `action` не разрешён, начать следующую итерацию цикла `while`. То есть перейти на шаг 4 алгоритма.

9. Прочитать новое состояние среды `next_state`, после выполнения хода `action`. Для этого вызвать метод `get_state` объекта `env` класса `TicTacToe`.

10. Сохранить в истории ходов `move_history` триплет: прошлое состояние среды `state`, выбранное одним из агентов действие `action` и новое состояние среды `next_state`.

11. Прочитать текущее состояние игры `game_over` и её результат `result` после хода `action`. Для этого вызвать метод `is_game_over` объекта `env` класса `TicTacToe`.

12. Если игра закончилась, выйти из цикла игры `while`. Это означает переход на шаг 15 алгоритма.

13. Если игра не закончилась, поменять текущее состояние среды `state` на новое `next_state` и увеличить счётчик ходов `counter` на 1.

14. Перейти к следующей итерации цикла игры `while`.

15. Пройти в цикле `for` по истории ходов `move_history`.

16. Если ход в истории чётный, обновить Q-значение для агента `agent1`. Для этого вызвать его метод `update_q_value`.

17. Если ход в истории нечётный, обновить Q-значение для агента `agent2`. Для этого вызвать его метод `update_q_value`.

18. Перейти к следующей итерации цикла `for`, который идёт по всем эпизодам обучения. Это означает переход на шаг 2 алгоритма.

Сразу после создания объектов `agent1` и `agent2` оба агента делают случайные ходы. После завершения функции `train_q_learning_agent` их ходы зависят от текущего состояния игрового поля. Агенты выбирают те ходы, которые чаще приводили к победе во время обучения.

Может возникнуть вопрос: зачем функции `train_q_learning_agent` нужен список с историей ходов `move_history`? Почему нельзя обновлять таблицу Q-значений агента сразу после того, как он сделает ход? Проблема в том, что совокупное вознаграждение за сделанный ход остаётся неизвестным до тех пор, пока игра не закончится. Результат игры — это совокупное вознаграждение за все сделанные агентом ходы. Для этих ходов невозможно рассчитать новое Q-значение, не зная чем закончилась игра. Поэтому сначала агенты играют партию до конца. Только после этого алгоритм проходит по истории ходов и обновляет таблицу Q-значений каждого агента, исходя из результата игры.

Четвёртый шаг скрипта — тестирование обученных агентов. Для этого вызывается функция `test_q_learning_agent`. На вход она получает те же три параметра, что и функция `train_q_learning_agent`: `env`, `agent1` и `agent2`.

Функция `test_q_learning_agent` выводит на экран результаты тестовых игр между агентами. Она работает по следующему алгоритму:

1. Подготовить параметры тестирования:
   * Установить число эпизодов тестирования `num_test_episodes`. В нашем примере это 10.

2. Пройти в цикле `for` по всем эпизодам тестирования. В каждом эпизоде агенты играют друг с другом один раз.

3. В начале каждого эпизода подготовить следующие объекты и переменные:
   * Сбросить состояние среды `env` в начальное. Для этого вызвать его метод `reset`.
   * Получить текущее состояние среды `state` после сброса. Для этого вызвать метод `get_state` объекта `env`.
   * Установить счётчик ходов `counter` в ноль.

4. Запустить бесконечный цикл `while` для одной игры.

5. В зависимости от счётчика `counter`, ход `action` делает `agent1` или `agent2`. В чётные ходы — `agent1`, в нечётные — `agent2`. Для этого вызвать метод `choose_action` соответствующего объекта класса `QLearningAgent`.

6. Проверить, что выбранный одним из агентов ход `action` разрешён правилами игры. Для этого вызвать метод `is_valid_move` объекта `env` класса `TicTacToe`.

7. Если ход `action` разрешён, среда его выполняет и обновляет своё текущее состояние. Для выполнения хода вызвать метод `make_move` объекта `env` класса `TicTacToe`.

8. Если ход `action` не разрешён, начать следующую итерацию цикла `while`. То есть перейти на шаг 4 алгоритма.

9. Вывести на экран состояние игрового поля после выполнения хода `action`. Для этого вызвать метод `print_board` объекта `env` класса `TicTacToe`.

10. Прочитать текущее состояние игры `game_over` и её результат `result` после хода `action`. Для этого вызвать метод `is_game_over` объекта `env` класса `TicTacToe`

12. Если игра закончилась, вывести на экран её результат и завершить текущий цикл игры `while`. То есть перейти на шаг 2 алгоритма.

13. Если игра не закончилась, прочитать новое состояние среды после выполнения хода `action` и сохранить его в переменной `state`. Для этого вызвать метод `get_state` объекта `env` класса `TicTacToe`.

14. Увеличить счётчик ходов `counter` на 1

15. Перейти к следующей итерации цикла игры `while`.

После завершения функции `test_q_learning_agent` скрипт завершает свою работу. Он выведет на экран результаты десяти игр между агентам `agent1` и `agent2`. Пример вывода для одной игры демонстрирует листинг 5-4.

{caption: "Листинг 5-4. Вывод результата тестовой игры", line-numbers: false, format: text}
```
- - -
- X -
- - -

O - -
- X -
- - -

O - -
X X -
- - -

O - -
X X O
- - -

O - X
X X O
- - -

O - X
X X O
O - -

O X X
X X O
O - -

O X X
X X O
O O -

O X X
X X O
O O X

Ничья!
```

## 5.2 Современные шахматные движки

### 5.2.1 Применение вертикального фильтра Собеля

Листинг 5-5 демонстрирует код скрипта [`sobel-vertical-filter.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/Chess/sobel-vertical-filter.py). Он применяет вертикальный фильтр Собеля к заданной фотографии. Чтобы запустить скрипт, скачайте его и [фотографию Лены Сёдерберг](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/Chess/lena.png) в один каталог. Обратите внимание, что имена файлов менять нельзя.

{caption: "Листинг 5-5. Скрипт для применения вертикального фильтра Собеля", line-numbers: true, format: Python}
![`sobel-vertical-filter.py`](code/Chess/sobel-vertical-filter.py)

Скрипт работает по следующему алгоритму:

1. Подготовить входные данные.

2. Применить фильтр Собеля ко всем к цветовым каналам фотографии.

3. Визуализировать все карты признаков в виде одного RGB изображения.

Для работы скрипт импортирует следующие модули и библиотеки:

* Библиотека `numpy` для работы с массивами.

* Модуль `pyplot` из библиотеки `matplotlib` предоставляет интерфейс для вывода изображений.

* Функция `convolve` из библиотеки `scipy` выполняет операцию свёртки.

Скрипт начинается с создания двумерного массива размера 3x3. В нём хранится вертикальный фильтр Собеля. Массив передаётся в функцию [`array`](https://numpy.org/doc/stable/reference/generated/numpy.array.html) из библиотеки `numpy`. Она возвращает объект класса [`ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), который сохраняется в переменной `sobel_vertical`. Класс `ndarray` можно рассматривать как обёртку. Она предоставляет удобный интерфейс для работы с массивами.

I> [**Класс обёртка**](https://stackoverflow.com/questions/889160/what-is-a-wrapper-class) скрывает функциональность другого класса или компонента. При этом обёртка предоставляет свой собственный интерфейс для работы со скрытым классом.

Далее скрипт загружает фотографию из файла с именем `lena.png`. Для этого он вызывает функцию `imread` из модуля `pyplot`. Функция возвращает объект класса `ndarray` с массивом пикселей загруженной фотографии. Для RGB изображений массив имеет размер `(M, N, 3)`, где M — это ширина исходного изображения в пикселях, а N — его высота. Другими словами, скрипт получает стек из трёх изображений: по одному для каждого цветового канала.

На втором шаге скрипт применяет вертикальный фильтр Собеля к каждому из трёх цветовых каналов изображения. Для этого он вызывает функцию [`convolve`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html) из библиотеки `scipy` в цикле `for` с тремя итерациями. Функция принимает на вход два объекта класса `ndarray`:

1. `img[:,:,channel]` — обёртка над массивом пикселей исходного изображения из цветового канала с индексом `channel`.

2. `sobel_vertical` — обертка над массивом с вертикальным фильтром Собеля.

Функция возвращает карту признаков с результатом операции свёртки. Она представляет собой объект класса `ndarray`, который сохраняется во временную переменную `result`. Затем переменная добавляется в список с именем `channels`.

После окончания цикла `for` скрипт получает список `channels` с тремя элементами. Каждый из них — это объект класса `ndarray` с картой признаков для соответствующего цветового канала исходного изображения.

На последнем шаге скрипт визуализирует полученные карты признаков. Для этого он комбинирует все элементы списка `channels` в один массив. Эту операцию выполняет функция `dstack` из библиотеки `numpy`. Она не меняет элементы входных массивов, а только упорядочивает их по третьему измерению. Таким образом из трёх массивов скрипт получает одно изображение с тремя цветовыми каналами RGB. Изображение сохраняется как объект класса `ndarray` в переменную `img`.

I> Подробнее работа функции `dstack` описана в [статье](https://www.educative.io/answers/what-is-the-numpydstack-function-in-numpy).

Переменная `img` хранит объект класса `ndarray`. В нём находится двумерный массив с пикселями RGB изображения, созданного из трёх карт признаков. Для визуализации изображения скрипт вызывает функцию `imshow` из библиотеки `matplotlib`. Эта функция принимает на вход только переменную `img`.

Последнее действие скрипта — открыть окно с финальным RGB изображением. Для этого он вызывает функцию `show` из библиотеки `matplotlib`. Она не получает входных параметров.

Иллюстрация 3-41 демонстрирует результат работы скрипта `sobel-vertical-filter.py`.

### 5.2.2 Применение фильтра для изображения

Листинг 5-6 демонстрирует код скрипта [`apply-filter-manually.py`](https://github.com/ellysh/ai-in-strategy-games/blob/master/manuscript/resources/code/Chess/apply-filter-manually.py). Он выполняет операцию свёртки по шагам без вызова функции `convolve` из библиотеки `scipy`. Чтобы увидеть результаты скрипта, запустите его из интерпретатора командной строки. Это `cmd.exe` для Windows или Bash для Linux.

{caption: "Листинг 5-6. Скрипт для выполнения операции свёртки", line-numbers: true, format: Python}
![`apply-filter-manually.py`](code/Chess/apply-filter-manually.py)

Скрипт работает по следующему алгоритму:

1. Подготовить входные данные.

2. Выполнить произведение Адамара для пикселей фильтра и исходного изображения.

3. Вывести результат операции свёртки на консоль.

Для работы скрипт импортирует только библиотеку `numpy` для работы с массивами.

На первом шаге скрипт создаёт объект класса `ndarray` с вертикальным фильтром Собеля. Он сохраняется в переменной `sobel_vertical`.

Далее скрипт создаёт второй объект класса `ndarray`. Он хранит массив размера 5x5 с пикселями исходного чёрно-белого изображения. Этот объект сохраняется в переменной `image`.

На втором шаге скрипт выполняет операцию свёртки. Для этого надо выполнить поэлементное умножение пикселей фильтра и исходного изображения (произведение Адамара). Чтобы упростить код, создаются два вспомогательных массива:

1. `tmp` — временно хранит пиксели исходного изображения, которые на текущем шаге перекрыл фильтр. Размер этого двумерного массива 3x3 соответствует размеру фильтра.

2. `row` — временно хранит элементы одной строки карты признаков. Максимальный размер этого одномерного массива равен 3.

Для хранения финальной карты признаков скрипт создаёт двумерный массив `result` размера 3x3.

После подготовки к операции свёртки скрипт выполняет [**вложенный цикл**](https://education.yandex.ru/handbook/python/article/vlozhennye-cikly). Внешний цикл выполняет следующий оператор `for`:
{line-numbers: false, format: Python}
```
for i in range(1, 4):
```

Он проходит по строкам исходного изображения. Нумерация строк начинается с 0. Тогда последняя строка изображения имеет индекс 4. Функция `range(1, 4)` возвращает массив: `[1, 2, 3]`. Цикл `for` проходит по его элементам. На каждой итерации очередной элемент записывается в переменную с именем `i`.

Внутренний цикл выполняет следующий оператор `for`:
{line-numbers: false, format: Python}
```
   for j in range(1, 4):
```

Он проходит по столбцам исходного изображения. На каждой из трёх итераций оператор `for` записывает очередной элемент массива `[1, 2, 3]` в переменную с именем `j`.

На каждой итерации внутреннего цикла `for` скрипт выполняет три действия:

1. Сохранить во временный массив `tmp` пиксели исходного изображения, которые перекрыл фильтр. Это три строки пикселей, которые начинаются с индекса `i-1` и заканчиваются `i+1`. Ряды пикселей в этих строках начинаются с индекса `j-1` и заканчиваются `j+1`.

2. Выполнить произведение Адамара. Его результат представляет собой одно число. Оно записывается в конец массива `row`. Произведение Адамара выполняется за два шага:

   * Вызвать функцию `multiply` из библиотеки `numpy`. Она получает на вход два массива и перемножает их элементы с одинаковыми индексами. Это означает, что первый элемент умножается на первый, второй на второй и т.д. Результат функции возвращается в виде массива в объекте класса`ndarray`.

   * Вызвать функцию `sum` из библиотеки `numpy`. Она получает на вход один объект класса `ndarray` с массивом и складывает все его элементы между собой.

3. Очистить временный массив `tmp` для подготовки к следующей итерации внутреннего цикла `for`.

На каждой итерации внешнего цикла `for` выполняются три действия:

1. Запустить внутренний цикл `for` с самого начала.

2. Записать результат выполнения внутреннего цикла `for` в конец массива `result`. Этот результат хранится во временном массиве `row`.

3. Очистить временный массив `row` для подготовки к следующей итерации внешнего цикла `for`.

После завершения внешнего цикла `for` результат операции свёртки хранится в массиве `result`. Скрипт выводит его на консоль с помощью функции `print`. Этот вывод выглядит следующим образом:
{line-numbers: false, format: Python}
```
[[-38, -190, -365], [-252, -204, -239], [37, 251, 429]]
```

{pagebreak}
