## Современные подходы

Мы кратко рассмотрели теорию интеллектуальных агентов. С её помощью мы научились определять тип среды, к которой относится решаемая нами задачи. Далее на основе типа среды, можно подобрать подходящий тип интеллектуального агента. Тип агента определяет методы ИИ на которых строится программа агента.

В этом разделе мы подробнее рассмотрим современные методы для реализации систем ИИ.

### Поиск в пространстве состояний

Алгоритмы поиска, которые мы рассмотрим, относятся к классу [**поиска в пространстве состояний**](https://ru.wikipedia.org/wiki/Поиск_в_пространстве_состояний). Эти алгоритмы отличаются от [традиционных алгоритмов поиска](https://en.wikipedia.org/wiki/Search_algorithm), которые изучает информатика.

Традиционные алгоритмы поиска находят заданное значение в некоторой структуре данных. Обычно эта структура данных целиком помещается в память компьютера. Сам алгоритм заключается в переборе значений, которые хранит структура. Когда искомое и проверяемое значение совпадают, поиск завершается.

Поиск в пространстве состояний отличается от традиционных алгоритмов. В таком поиске структура данных не задаётся явно. Вместо этого есть состояния среды, которые проверяет интеллектуальный агент. Набор всех возможных состояний среды называется [**пространством состояний**](https://en.wikipedia.org/wiki/State_space).

#### Пространство состояний

Пространство состояний обычно представляют в форме графа. Граф состоит из вершин, которые соединяются рёбрами. Вершины соответствуют состояниям среды. Рёбра обозначают действия агента, которые меняют состояние среды. Смена состояния означает переход между двумя вершинами, которые соединяет одно ребро.

Некоторые пространства состояний удобнее представлять в виде **ориентированного графа**. В таком графе рёбра имеют направления. Другими словами у каждого ребра есть начало и конец. Направленные рёбра называются **дугами**. Переход между вершинами графа возможен только по направлению рёбер.

Иллюстрация 2-2 демонстрирует ориентированный граф с двумя состояниями среды для программы очистки диска из прошлого раздела.

{caption: "Иллюстрация 2-2. Пространство состояний для программы очистки диска", height: "50%", width: "100%"}
![Пространство состояний](images/ArtificialIntelligence/disc-cleanup-graph.png)

Пространство состояний определяет:

1. Начальное состояние среды.
2. Набор допустимых действий агента в каждом состоянии среды.
3. Функция действия (action function) — возвращает новое состояние среды, если агент совершит указанное действие в указанном состоянии среды.

В этом списке нет набора всех возможных состояний среды. Если этот набор известен, то форма представления пространства состояний называется **явным графом**. Граф такого типа помещается в память компьютера целиком. Он подходит для простых проблемных сред, как на иллюстрации 2-2.

Если проблемная среда сложная, то пространство состояний представляется в форме **неявного графа**. В этом случае набор всех возможных состояний среды заранее неизвестен. Эти состояния выводятся в процессе поиска и помещаются в память компьютера. Затем они удаляются, если не соответствуют решению задачи.

Неявный граф применятся в тех случаях, когда памяти компьютера недостаточно для хранения всех возможных состояний среды.

#### Решение задачи поиска

После определения пространства поиска решение задачи сводится к нахождению **пути** в графе. Путём называется такая последовательность рёбер или дуг, что конец каждой дуги является началом следующей.

Решение задачи — это путь в графе, который ведёт из начального состояния среды к искомому состоянию.

Выполняя алгоритм поиска, интеллектуальный агент проверяет каждую посещённую вершину графа. Это действие называется **проверкой цели**. Если состояние среды, соответствующее вершине, совпадает с искомым состоянием, то проверка цели проходит успешно.

В условии задачи цель может определяться как конкретное состояние среды. Тогда проверка цели сводится к сравнению текущего состояния и искомого.

В некоторых задачах цель формулируется как набор свойств, которым должно обладать искомое состояние. Тогда проверка цели заключается в проверке свойств текущего состояния.

Чтобы оценить показатели производительности выполняющего поиск агента, применяют понятие **стоимость пути**. Стоимость пути представляет собой функцию, которая даёт числовую оценку для указанного пути. Стоимость пути складывается из стоимостей составляющих его шагов. **Стоимость шага** — это числовая оценка действия агента, которое изменяет состояние среды.

**Решением** задачи называется путь из начальной вершины графа к искомой. **Оптимальным решением** называется решение с минимальной стоимостью.

#### Алгоритмы поиска и их сложность

Есть три класса алгоритмов поиска в пространстве состояний:

1. [**Неинформированный поиск**](https://ru.wikipedia.org/wiki/Неинформированный_метод_поиска) (uninformed search)
2. [**Информированный поиск**](https://ru.wikipedia.org/wiki/Информированный_метод_поиска) (informed search)
3. Поиск в условиях противодействия (adversarial Search)

Рассмотрим алгоритмы каждого из этих классов. Также сравним эффективность алгоритмов каждого класса.

Алгоритмы поиска оцениваются по двум показателям:

* Временная сложность
* Пространственная сложность

Мы уже сталкивались с этими понятиями ранее. Теперь дадим им более формальные определения.

**Временная сложность** означает время выполнения алгоритма в зависимости от размера его входных данных.

**Пространственная сложность** — это объём памяти, который нужен для выполнения алгоритма. Этот объём зависит только от размера входных данных алгоритма.

Обычно временная и пространственная сложности выражается в нотации ["О" большое](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое). "O" большое определяет характер изменения функции, когда её аргумент стремится к бесконечности. Другими словами "O" большое определяет, как быстро растёт функция в зависимости от её входных данных.

Рассмотрим пример. Предположим, что число шагов алгоритма N вычисляется в зависимости от размера входных данных n по следующей формуле: 2 * n^2^ + 5 * n + 10. В этом случае говорят, что временная сложность алгоритма равна O(n^2^).

При оценке сложности в нотации "O" большое учитывают только слагаемое самого высокого порядка. В нашем примере это слагаемое равно: 2 * n^2^. Константные множители тоже не учитываются. Это значит, что нам надо отбросить множитель 2. Тогда остаётся только n^2^. Таким образом мы получили сложность алгоритма O(n^2^).

Если сложность алгоритма не зависит от размера его входных данных, говорят что она равна O(1). При этом реальное число шагов алгоритма в оценке сложности не учитывается.

Иллюстрация 2-3 демонстрирует графики часто встречающихся функций оценки сложности алгоритма. Графики отражают зависимость числа шагов алгоритма N от размера входных данных n

{caption: "Иллюстрация 2-3. Функции оценки сложности алгоритма", height: "50%", width: "100%"}
![Функции оценки сложности](images/ArtificialIntelligence/computational-complexity.png)

Чем выше график функции от оси n, тем больше шагов выполняет алгоритм для обработки входных данных. Большее число шагов означает большую временную сложность. Другими словами, сложный алгоритм выполняется дольше, чем простой.

#### Неинформированный поиск

// TODO: uninformed search

#### Информированный поиск

// TODO: informed search

#### Состязательный поиск

// TODO: Adversarial Search

### Машинное обучение

#### Shallow learning

#### Deep learning