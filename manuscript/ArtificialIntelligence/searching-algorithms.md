## Алгоритмы поиска

Мы кратко рассмотрели теорию интеллектуальных агентов. С её помощью мы научились по условию задачи определять тип проблемной среды. Далее по типу среды, можно подобрать подходящий тип интеллектуального агента. Тип агента определяет методы ИИ на которых строится программа агента.

Рассмотрим современные методы ИИ, которые основаны на алгоритмах поиска. Эти методы используют интеллектуальные агенты двух типов:

* Основанные на цели
* Основанные на производительности

### Пространство состояний

В ИИ применяют алгоритмы поиска, которые относятся к классу [**поиска в пространстве состояний**](https://ru.wikipedia.org/wiki/Поиск_в_пространстве_состояний). Эти алгоритмы отличаются от [традиционных алгоритмов поиска](https://en.wikipedia.org/wiki/Search_algorithm), которые изучает информатика.

Традиционные алгоритмы поиска находят заданное значение в некоторой структуре данных. Обычно эта структура данных целиком помещается в память компьютера. Сам алгоритм заключается в переборе значений, которые хранит структура. Когда искомое и проверяемое значение совпадают, поиск завершается.

При поиске в пространстве состояний структура данных не задаётся явно. Вместо этого есть состояния среды, которые проверяет интеллектуальный агент. Набор всех возможных состояний среды называется [**пространством состояний**](https://en.wikipedia.org/wiki/State_space).

Пространство состояний обычно представляют в форме графа. Граф состоит из вершин, которые соединяются рёбрами. Вершины соответствуют состояниям среды. Рёбра обозначают действия агента, которые меняют состояние среды. Смена состояния означает переход между двумя вершинами, которые соединяет одно ребро.

Некоторые пространства состояний удобнее представлять в виде **ориентированного графа**. В таком графе рёбра имеют направления. Другими словами у каждого ребра есть начало и конец. Направленные рёбра называются **дугами**. Переход между вершинами графа возможен только по направлению рёбер.

Иллюстрация 2-2 демонстрирует ориентированный граф с двумя состояниями среды для программы очистки диска из прошлого раздела.

{caption: "Иллюстрация 2-2. Пространство состояний для программы очистки диска", height: "50%", width: "100%"}
![Пространство состояний](images/ArtificialIntelligence/disc-cleanup-graph.png)

Пространство состояний определяет:

1. Начальное состояние среды.
2. Набор допустимых действий агента в каждом состоянии среды.
3. Функция действия (action function) — возвращает новое состояние среды, если агент совершит указанное действие в указанном состоянии среды.

В этом списке нет набора всех возможных состояний среды. Если этот набор известен, то форма представления пространства состояний называется **явным графом**. Граф такого типа помещается в память компьютера целиком. Он подходит для простых проблемных сред, как на иллюстрации 2-2.

Если проблемная среда сложная, то пространство состояний представляется в форме **неявного графа**. В этом случае набор всех возможных состояний среды заранее неизвестен. Эти состояния выводятся в процессе поиска и помещаются в память компьютера. Затем они удаляются, если не соответствуют решению задачи.

Неявный граф применятся в тех случаях, когда памяти компьютера недостаточно для хранения всех возможных состояний среды.

### Решение задачи поиска

После определения пространства поиска решение задачи сводится к нахождению **пути** в графе. Путём называется такая последовательность рёбер или дуг, что конец каждой дуги является началом следующей.

Решение задачи — это путь в графе, который ведёт из начального состояния среды к искомому состоянию.

Выполняя алгоритм поиска, интеллектуальный агент проверяет каждую посещённую вершину графа. Это действие называется **проверкой цели**. Если состояние среды, соответствующее вершине, совпадает с искомым состоянием, то проверка цели проходит успешно.

В условии задачи цель может определяться как конкретное состояние среды. Тогда проверка цели сводится к сравнению текущего состояния и искомого.

В некоторых задачах цель формулируется как набор свойств, которым должно обладать искомое состояние. Тогда проверка цели заключается в проверке свойств текущего состояния.

Чтобы оценить показатели производительности выполняющего поиск агента, применяют понятие **стоимость пути**. Стоимость пути представляет собой функцию, которая даёт числовую оценку для указанного пути. Стоимость пути складывается из стоимостей составляющих его шагов. **Стоимость шага** — это числовая оценка действия агента, которое изменяет состояние среды.

**Решением** задачи называется путь из начальной вершины графа к искомой. **Оптимальным решением** называется решение с минимальной стоимостью.

### Оценка алгоритмов поиска

Алгоритмы поиска оцениваются по следующим показателям:

* Временная сложность (time complexity)
* Пространственная сложность (space complexity)
* Полнота (completeness)
* Оптимальность (optimality)

**Временная сложность** означает время выполнения алгоритма в зависимости от размера его входных данных.

**Пространственная сложность** — это объём памяти, который нужен для выполнения алгоритма. Этот объём зависит только от размера входных данных алгоритма.

Временная и пространственная сложности выражается в нотации ["О" большое](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое). "O" большое определяет характер изменения функции, когда её аргумент стремится к бесконечности. Другими словами "O" большое определяет, как быстро растёт функция в зависимости от её входных данных.

Рассмотрим пример. Предположим, что число шагов алгоритма N вычисляется в зависимости от размера входных данных n по следующей формуле: 2 * n^2^ + 5 * n + 10. В этом случае говорят, что временная сложность алгоритма равна O(n^2^).

При оценке сложности в нотации "O" большое учитывают только слагаемое самого высокого порядка. В нашем примере это слагаемое равно: 2 * n^2^. Константные множители тоже не учитываются. Это значит, что нам надо отбросить множитель 2. Тогда остаётся только n^2^. Таким образом мы получили сложность алгоритма O(n^2^).

Если сложность алгоритма не зависит от размера его входных данных, говорят что она равна O(1). При этом реальное число шагов алгоритма в оценке сложности не учитывается.

Иллюстрация 2-3 демонстрирует графики часто встречающихся функций оценки сложности алгоритма. Графики отражают зависимость числа шагов алгоритма N от размера входных данных n

{caption: "Иллюстрация 2-3. Функции оценки сложности алгоритма", height: "50%", width: "100%"}
![Функции оценки сложности](images/ArtificialIntelligence/computational-complexity.png)

Чем выше поднимается график функции от оси n, тем больше шагов выполняет алгоритм для обработки входных данных. Большее число шагов означает большую временную сложность. Другими словами, сложный алгоритм выполняется дольше, чем простой.

Пространственная сложность оценивается теми же самыми функциями, что и временная. В случае пространственной сложности ось N на иллюстрации 2-3 показывает объём памяти (например, в мегабайтах), который использует алгоритм в процессе своей работы.

Алгоритм поиска называется **полным**, если он гарантированно находит существующее решение в пространстве состояний за конечное число шагов. Если решение существует, но алгоритм его не находит в некоторых случаях, он называется **неполным**.

**Оптимальность** означает, что алгоритм находит оптимальное решение (с минимальной стоимостью) среди всех возможных.

Есть три класса алгоритмов поиска в пространстве состояний:

1. [**Неинформированный поиск**](https://ru.wikipedia.org/wiki/Неинформированный_метод_поиска) (uninformed search)
2. [**Информированный поиск**](https://ru.wikipedia.org/wiki/Информированный_метод_поиска) (informed search)
3. Поиск в условиях противодействия (adversarial search)

Рассмотрим алгоритмы каждого класса и сравним их эффективность.

### Неинформированный поиск

К классу **неинформированного поиска** относятся алгоритмы, которые не используют дополнительную информацию о пространстве поиска. В этих алгоритмах выполняются только два типа действий:

* Переход между вершинами графа пространства состояний.
* Проверка текущей вершины графа на соответствие искомого состояния среды.

Алгоритмы неинформированного поиска различаются только порядком перехода между вершинами графа пространства состояний. Их демонстрирует таблица 2-10.

{caption: "Таблица 2-10. Алгоритмы неинформированного поиска", width: "100%"}
| Алгоритм | Временная сложность | Пространственная сложность | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Поиск в ширину (BFS) | O(b^d^) | O(b^d^) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Поиск по критерию стоимости (UCS) | O(b^1+C/ε^) | O(b^1+C/ε^) | Да, если стоимости всех шагов строго положительны | Да, если стоимости всех шагов строго положительны |
|  | | | | |
| Поиск в глубину (DFS) | O(b^m^) | O(b*m) | Нет | Нет |
|  | | | | |
| Поиск с ограничением глубины (DLS) | O(b^l^) | O(b*l) | Нет | Нет |
|  | | | | |
| Поиск в глубину с итеративным углублением (IDDFS) | O(b^d^) | O(b*d) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Двунаправленный поиск | O(b^d/2^) | O(b^d/2^) | Да | Да, если стоимость всех шагов одинакова |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — **коэффициент ветвления**. Означает количество вершин, напрямую соединённых с каждой вершиной графа. Если это количество отличается для разных вершин, вычисляется среднее значение.
* d — глубина (длина пути) самого поверхностного решения.
* C — стоимость пути оптимального решения.
* ε — стоимость каждого шага, который приближает алгоритм к целевой вершине.
* m — максимальная глубина графа поиска.
* l — ограничение глубины поиска.

В общем случае алгоритмы неинформированного поиска работают для графов. Мы рассмотрим эти алгоритмы для деревьев. Так будет проще проиллюстрировать их принцип работы.

**Дерево** — это частный случай графа, в котором нет циклов. Кроме того между любой парой вершин такого графа есть минимум один путь.

[**Цикл**](https://ru.wikipedia.org/wiki/Цикл_(теория_графов)) в теории графов — это путь, который начинается и заканчивается в одной и той же вершине.

#### Поиск в ширину

Алгоритм **поиска в ширину** (breadth-first search, BFS) проходит по дереву поиска уровень за уровнем, начиная с корневого узла.

Иллюстрация 2-4 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-4. Порядок обхода узлов при поиске в ширину", height: "50%", width: "100%"}
![Поиск в ширину](images/ArtificialIntelligence/bfs-tree.png)

Номера в узлах дерева указывают порядок их обхода. Поиск начинается с корневого узла 1. Затем проверяются узлы первого уровня с номерами 2 и 3. После этого алгоритм проходит по узлам последнего уровня с номерами 4, 5, 6, 7. Порядок обхода узлов на одном уровне слева направо.

Достоинства поиска в ширину:

* Гарантированно находит решение, если оно существует (полнота).
* Находит оптимальное решение, если стоимость всех шагов одинакова (оптимальность).

Недостатки поиска в ширину:

* Требует много памяти (пространственная сложность). В худшем случае надо сохранить все посещённые узлы дерева поиска.
* Если решение представляет собой длинный путь, алгоритм ищет его очень долго (временная сложность).

#### Поиск по критерию стоимости

**Поиск по критерию стоимости** (uniform-cost search, UCS) используется для обхода дерева или графа, в котором стоимость шагов различается. Алгоритм проходит узлы в порядке возрастания стоимости пути от корневого узла. Первым проверяется узел стоимость пути до которого минимальна.

Если стоимость всех шагов в дереве или графе одинакова, поиск по критерию стоимости работает так же как поиск в ширину.

Иллюстрация 2-5 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-5. Порядок обхода узлов при поиске по критерию стоимости", height: "50%", width: "100%"}
![Поиск по критерию стоимости](images/ArtificialIntelligence/ucs-tree.png)

Номера в узлах дерева обозначают порядок их обхода. На иллюстрации около каждого ребра указана стоимость соответствующего шага. Алгоритм начинает проход с корневого узла 1. Стоимость шага до узла 2 равна 1. Это меньше стоимости шага 2 до узла 3. Поэтому алгоритм переходит в узел с номером 2.

Далее алгоритм вычисляет стоимость пути до узлов 5 и 4. Для узла 5 стоимость складывается из стоимости путей между узлами 1-2 и 2-5. В результате получается стоимость `1 + 3 = 4`. Для узла 4 стоимость равна `1 + 2 = 3`. В этом случае алгоритм выбирает проверку узла 3, потому что стоимость пути до него равна 2. Это меньше стоимости пути до узлов 5 и 4.

Далее алгоритм проверяет узел с минимальной стоимостью пути. Это узел под номером 4. Затем идут узлы:

* 5 — стоимость пути 4
* 6 — стоимость пути 5
* 7 — стоимость пути 6

Достоинства поиска по критерию стоимости:

* Находит оптимальное решение, потому что в первую очередь проходит пути с минимальной стоимостью (оптимальность).

Недостатки поиска по критерию стоимости:

* В наихудшем случае временная и пространственная сложность намного больше чем у поиска в ширину. Это происходит, потому что алгоритм сначала проверяет большие деревья из мелки шагов и только потом пути с большими шагами.

#### Поиск в глубину

**Поиск в глубину** (depth-first search, DFS) начинает с корневого узла и проходит каждый путь до самого дальнего узла. После этого алгоритм возвращается к ближайшему узлу, у которого есть непроверенные рёбра, и снова проходит до самого дальнего узла. Этот процесс повторяется, пока не пройдено всё дерево или граф.

Иллюстрация 2-6 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-6. Порядок обхода узлов при поиске в глубину", height: "50%", width: "100%"}
![Поиск в глубину](images/ArtificialIntelligence/dfs-tree.png)

Номера в узлах дерева указывают порядок их обхода. Поиск начинается с корневого узла 1. Затем алгоритм проходит до конца по левой ветви дерева через узлы 2 и 3. После этого он переходит на один шаг назад к узлу 2. У этого узла осталась непроверенная ветвь до узла 4. Алгоритм проверяет эту ветвь и возвращается в корневой узел 1. После этого он проходит по правой части дерева в аналогичном порядке.

Достоинства поиска в глубину:

* Требует очень мало памяти (пространственная сложность). Хранит только набор вершин по пути от корневой до текущей.

* Находит решение быстрее чем поиск в ширину, если начинается в правильном направлении (временная сложность).

Недостатки поиска в глубину:

* Если в графе или дереве есть циклы, алгоритм может зациклиться и не найти решения (полнота).

* Найденное решение может быть не оптимальным (оптимальность).

#### Поиск с ограничением глубины

**Поиск с ограничением глубины** (depth-limited search, DLS) — это вариант поиска в глубину с ограничением максимальной глубины прохода. Этот алгоритм решает проблему циклов, которые не может обработать поиск в глубину.

Иллюстрация 2-7 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-7. Порядок обхода узлов при поиске с ограничением глубины", height: "50%", width: "100%"}
![Поиск с ограничением глубины](images/ArtificialIntelligence/dls-tree.png)

Номера в узлах дерева указывают порядок их обхода. Иллюстрация демонстрирует обход дерева в случае ограничения глубины прохода, равном 3.

Алгоритм начинает с корневого узла 1 на глубине 0. Затем он идёт по левой ветви дерева через узлы 2 и 3. На узле 3 алгоритм останавливается, потому что этот узел находится на глубине 2. Это предел поиска для ограничения глубины, равном 3.

После этого алгоритм проходит узлы 4, 5, 6 и 7 в том же порядке что и поиск в глубину. На узле 7 алгоритм снова останавливается из-за ограничения глубины.

Достоинства поиска с ограничением глубины:

* Требует очень мало памяти также как поиск в глубину (пространственная сложность).

Недостатки поиска с ограничением глубины:

* Может не найти решения, если путь до него длиннее, чем ограничение глубины (полнота).

* Найденное решение может быть не оптимальным (оптимальность).

#### Поиск в глубину с итеративным углублением

**Поиск в глубину с итеративным углублением** (iterative-deepening depth-first search, IDDFS) — это вариант поиска с ограничением глубины. В нём пошагово увеличивается ограничение глубины до тех пор, пока не будет найдено решение.

Поиск в глубину с итеративным углублением представляет собой компромисс между поиском в ширину и поиском в глубину. Алгоритм имеет низкую пространственную ложность, но при этом полный и оптимальный.

Иллюстрация 2-8 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-8. Порядок обхода узлов при поиске в глубину с итеративным углублением", height: "50%", width: "100%"}
![Поиск в глубину с итеративным углублением](images/ArtificialIntelligence/iddfs-tree.png)

Поиск выполняется как последовательность итераций. Таблица 2-11 демонстрирует итерации для дерева поиска на иллюстрации 2-8.

{caption: "Таблица 2-11. Итерации поиска", width: "100%"}
| Номер итерации | Порядок посещения узлов |
| --- | --- |
| 1 | A |
|  | |
| 2 | A, B, C |
|  | |
| 3 | A, B, D, E, C, F, G |
|  | |
| 4 | A, B, D, H, I, E, C, F, G, J, K |

Достоинства поиска в глубину с итеративным углублением:

* Низкая пространственная сложность.

* Низкая временная сложность.

* Гарантированно находит решение, если оно есть (полнота).

* Найденное решение будет оптимальным (оптимальность).

Недостатки поиска в глубину с итеративным углублением:

* На каждой итерации алгоритм повторяет свои шаги из прошлой итерации.

Поиск в глубину с итеративным углублением считается лучшим алгоритмом неинформированного поиска, когда пространство поиска велико, а глубина решения неизвестна.

#### Двунаправленный поиск

**Двунаправленный поиск** (bidirectional search) заключается в одновременном поиске из корневого и целевого узлов. Поиск из корневого узла выполняется в прямом направлении, а из целевого узла — в обратном. Алгоритм прекращается, когда два процесса поиска встречаются. Таким образом решение составляется из двух частей. Это части пути, найденные поиском в прямом и в обратном направлениях.

Каждая часть двунаправленного поиска может выполняться любым алгоритмом неинформированного поиска (в ширину, в глубину, в глубину с ограничением и т.д.). Чаще всего используют поиск в ширину. Он обеспечивает полноту и оптимальность. Другие алгоритмы могут неполными или неоптимальными.

Для двунаправленного поиска должен быть известен целевой узел дерева или графа.

Иллюстрация 2-9 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-9. Порядок обхода узлов при двунаправленном поиске", height: "50%", width: "100%"}
![Двунаправленный поиск](images/ArtificialIntelligence/bidirectional-search-tree.png)

Поиск начинается в узле D. Он отмечен зелёным цветом. Целевой узел J отмечен оранжевым. Предположим, что в обоих направлениях выполняется поиск в ширину.

Во время двунаправленного поиска чередуются итерации прямого и обратного поиска. Таблица 2-12 демонстрирует эти итерации.

{caption: "Таблица 2-12. Итерации двунаправленного поиска", width: "100%"}
| Номер итерации | Направление поиска | Порядок посещения узлов |
| --- | --- | --- |
| 1 | Прямое | D |
|  | |
| 2 | Обратное | J |
|  | |
| 3 | Прямое | H, I, B |
|  | |
| 4 | Обратное | F, G |
|  | |
| 5 | Прямое | E, A |
|  | |
| 6 | Обратное | E, C, K |

Алгоритм останавливается на 6-ой итерации, когда прямой и обратный поиск встречаются в узле E. Далее алгоритм объединяет оба результата в один: D -> B -> E -> F -> J.

Достоинства двунаправленного поиска:

* Низкая пространственная сложность.

* Низкая временная сложность.

Недостатки поиска в глубину с итеративным углублением:

* Сложно реализовать в виде программы.

* Целевой узел должен быть известен заранее.

### Информированный поиск

Мы рассмотрели алгоритмы неинформированного поиска. Общая проблема таких алгоритмов в их неэффективности для большинства реальных задач. Как только пространство поиска становится большим, неинформированный поиск занимает слишком много времени и памяти из-за комбинаторного взрыва.

Алгоритмы **информированного поиска** решают проблему обработки большого пространства поиска. Эти алгоритмы применяют дополнительную информацию о поставленной задаче. Вот несколько примеров такой информации:

* Как далеко находится целевой узел от текущего?
* В каком направлении находится целевой узел?
* Какова стоимость пути до целевого узла?

Благодаря таким подсказкам, агент исключает некоторые ветви дерева без прохода по ним.

#### Поиск по первому наилучшему совпадению

#### Поиск A*

### Состязательный поиск

// TODO: Adversarial Search

#### Минимакс

#### Альфа-бета-отсечение