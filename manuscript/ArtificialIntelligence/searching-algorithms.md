## Алгоритмы поиска

Мы кратко рассмотрели теорию интеллектуальных агентов. С её помощью мы научились по условию задачи определять тип проблемной среды. Далее по типу среды, можно подобрать подходящий тип интеллектуального агента. Тип агента определяет методы ИИ на которых строится программа агента.

Рассмотрим современные методы ИИ, которые основаны на алгоритмах поиска. Эти методы используют интеллектуальные агенты двух типов:

* Основанные на цели
* Основанные на производительности

### Пространство состояний

В ИИ применяют алгоритмы поиска, которые относятся к классу [**поиска в пространстве состояний**](https://ru.wikipedia.org/wiki/Поиск_в_пространстве_состояний). Эти алгоритмы отличаются от [традиционных алгоритмов поиска](https://en.wikipedia.org/wiki/Search_algorithm), которые изучает информатика.

Традиционные алгоритмы поиска находят заданное значение в некоторой структуре данных. Обычно эта структура данных целиком помещается в память компьютера. Сам алгоритм заключается в переборе значений, которые хранит структура. Когда искомое и проверяемое значение совпадают, поиск завершается.

При поиске в пространстве состояний структура данных не задаётся явно. Вместо этого есть состояния среды, которые проверяет интеллектуальный агент. Набор всех возможных состояний среды называется [**пространством состояний**](https://en.wikipedia.org/wiki/State_space).

Пространство состояний обычно представляют в форме графа. Граф состоит из вершин, которые соединяются рёбрами. Вершины соответствуют состояниям среды. Рёбра обозначают действия агента, которые меняют состояние среды. Смена состояния означает переход между двумя вершинами, которые соединяет одно ребро.

Некоторые пространства состояний удобнее представлять в виде **ориентированного графа**. В таком графе рёбра имеют направления. Другими словами у каждого ребра есть начало и конец. Направленные рёбра называются **дугами**. Переход между вершинами графа возможен только по направлению рёбер.

Иллюстрация 2-2 демонстрирует ориентированный граф с двумя состояниями среды для программы очистки диска из прошлого раздела.

{caption: "Иллюстрация 2-2. Пространство состояний для программы очистки диска", height: "50%", width: "100%"}
![Пространство состояний](images/ArtificialIntelligence/disc-cleanup-graph.png)

Пространство состояний определяет:

1. Начальное состояние среды.
2. Набор допустимых действий агента в каждом состоянии среды.
3. Функция действия (action function) — возвращает новое состояние среды, если агент совершит указанное действие в указанном состоянии среды.

В этом списке нет набора всех возможных состояний среды. Если этот набор известен, то форма представления пространства состояний называется **явным графом**. Граф такого типа помещается в память компьютера целиком. Он подходит для простых проблемных сред, как на иллюстрации 2-2.

Если проблемная среда сложная, то пространство состояний представляется в форме **неявного графа**. В этом случае набор всех возможных состояний среды заранее неизвестен. Эти состояния выводятся в процессе поиска и помещаются в память компьютера. Затем они удаляются, если не соответствуют решению задачи.

Неявный граф применятся в тех случаях, когда памяти компьютера недостаточно для хранения всех возможных состояний среды.

### Решение задачи поиска

После определения пространства поиска решение задачи сводится к нахождению **пути** в графе. Путём называется такая последовательность рёбер или дуг, что конец каждой дуги является началом следующей.

Решение задачи — это путь в графе, который ведёт из начального состояния среды к искомому состоянию.

Выполняя алгоритм поиска, интеллектуальный агент проверяет каждую посещённую вершину графа. Это действие называется **проверкой цели**. Если состояние среды, соответствующее вершине, совпадает с искомым состоянием, то проверка цели проходит успешно.

В условии задачи цель может определяться как конкретное состояние среды. Тогда проверка цели сводится к сравнению текущего состояния и искомого.

В некоторых задачах цель формулируется как набор свойств, которым должно обладать искомое состояние. Тогда проверка цели заключается в проверке свойств текущего состояния.

Чтобы оценить показатели производительности выполняющего поиск агента, применяют понятие **стоимость пути**. Стоимость пути представляет собой функцию, которая даёт числовую оценку для указанного пути. Стоимость пути складывается из стоимостей составляющих его шагов. **Стоимость шага** — это числовая оценка действия агента, которое изменяет состояние среды.

**Решением** задачи называется путь из начальной вершины графа к искомой. **Оптимальным решением** называется решение с минимальной стоимостью.

### Оценка алгоритмов поиска

Алгоритмы поиска оцениваются по следующим показателям:

* Временная сложность (time complexity)
* Пространственная сложность (space complexity)
* Полнота (completeness)
* Оптимальность (optimality)

**Временная сложность** означает время выполнения алгоритма в зависимости от размера его входных данных.

**Пространственная сложность** — это объём памяти, который нужен для выполнения алгоритма. Этот объём зависит только от размера входных данных алгоритма.

Временная и пространственная сложности выражается в нотации ["О" большое](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое). "O" большое определяет характер изменения функции, когда её аргумент стремится к бесконечности. Другими словами "O" большое определяет, как быстро растёт функция в зависимости от её входных данных.

Рассмотрим пример. Предположим, что число шагов алгоритма N вычисляется в зависимости от размера входных данных n по следующей формуле: 2 * n^2^ + 5 * n + 10. В этом случае говорят, что временная сложность алгоритма равна O(n^2^).

При оценке сложности в нотации "O" большое учитывают только слагаемое самого высокого порядка. В нашем примере это слагаемое равно: 2 * n^2^. Константные множители тоже не учитываются. Это значит, что нам надо отбросить множитель 2. Тогда остаётся только n^2^. Таким образом мы получили сложность алгоритма O(n^2^).

Если сложность алгоритма не зависит от размера его входных данных, говорят что она равна O(1). При этом реальное число шагов алгоритма в оценке сложности не учитывается.

Иллюстрация 2-3 демонстрирует графики часто встречающихся функций оценки сложности алгоритма. Графики отражают зависимость числа шагов алгоритма N от размера входных данных n

{caption: "Иллюстрация 2-3. Функции оценки сложности алгоритма", height: "50%", width: "100%"}
![Функции оценки сложности](images/ArtificialIntelligence/computational-complexity.png)

Чем выше поднимается график функции от оси n, тем больше шагов выполняет алгоритм для обработки входных данных. Большее число шагов означает большую временную сложность. Другими словами, сложный алгоритм выполняется дольше, чем простой.

Пространственная сложность оценивается теми же самыми функциями, что и временная. В случае пространственной сложности ось N на иллюстрации 2-3 показывает объём памяти (например, в мегабайтах), который использует алгоритм в процессе своей работы.

Алгоритм поиска называется **полным**, если он гарантированно находит существующее решение в пространстве состояний за конечное число шагов. Если решение существует, но алгоритм его не находит в некоторых случаях, он называется **неполным**.

**Оптимальность** означает, что алгоритм находит оптимальное решение (с минимальной стоимостью) среди всех возможных.

Есть три класса алгоритмов поиска в пространстве состояний:

1. [**Неинформированный поиск**](https://ru.wikipedia.org/wiki/Неинформированный_метод_поиска) (uninformed search)
2. [**Информированный поиск**](https://ru.wikipedia.org/wiki/Информированный_метод_поиска) (informed search)
3. Поиск в условиях противодействия (adversarial Search)

Рассмотрим алгоритмы каждого класса и сравним их эффективность.

### Неинформированный поиск

К классу **неинформированного поиска** относятся алгоритмы, которые не используют дополнительную информацию о пространстве поиска. В этих алгоритмах выполняются только два типа действий:

* Переход между вершинами графа пространства состояний.
* Проверка текущей вершины графа на соответствие искомого состояния среды.

Алгоритмы неинформированного поиска различаются только порядком перехода между вершинами графа пространства состояний. Их демонстрирует таблица 2-10.

{caption: "Таблица 2-10. Алгоритмы неинформированного поиска", width: "100%"}
| Алгоритм | Временная сложность | Пространственная сложность | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Поиск в ширину (BFS) | O(b^d^) | O(b^d^) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Поиск по критерию стоимости (UCS) | O(b^1+C/ε^) | O(b^1+C/ε^) | Да, если стоимости всех шагов строго положительны | Да, если стоимости всех шагов строго положительны |
|  | | | | |
| Поиск в глубину (DFS) | O(b^m^) | O(b*m) | Нет | Нет |
|  | | | | |
| Поиск с ограничением глубины (DLS) | O(b^l^) | O(b*l) | Нет | Нет |
|  | | | | |
| Поиск в глубину с итеративным углублением (IDDFS) | O(b^d^) | O(b*d) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Двунаправленный поиск | O(b^d/2^) | O(b^d/2^) | Да | Да, если стоимость всех шагов одинакова |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — **коэффициент ветвления**. Означает количество вершин, напрямую соединённых с каждой вершиной графа. Если это количество отличается для разных вершин, вычисляется среднее значение.
* d — глубина (длина пути) самого поверхностного решения.
* C — стоимость пути оптимального решения.
* ε — стоимость каждого шага, который приближает алгоритм к целевой вершине.
* m — максимальная глубина графа поиска.
* l — ограничение глубины поиска.

В общем случае алгоритмы неинформированного поиска работают для графов. Мы рассмотрим эти алгоритмы для деревьев. Так будет проще проиллюстрировать их принцип работы.

**Дерево** — это частный случай графа, в котором нет циклов. Кроме того между любой парой вершин такого графа есть минимум один путь.

#### Поиск в ширину

### Информированный поиск

// TODO: informed search

### Состязательный поиск

// TODO: Adversarial Search