## Состязательный поиск

Мы познакомились с алгоритмами классического поиска. Они позволяют интеллектуальному агенту найти требуемое состояние одноагентной среды. В результате такого поиска агент решает поставленную задачу.

Классический поиск не работает в условиях, когда два и более агентов ищут решение в одной и той же среде. В этом случае действия каждого агента меняют состояние среды. При этом если агенты конкурируют друг с другом, их действия могут мешать оппоненту достигнуть цели. Поиск в таких условиях называется **состязательным** или **поиском в условиях противодействия** (adversarial Search). Рассмотрим его подробнее.

### Проблемная среда

Дадим полную характеристику проблемной среды, в которой применяется состязательный поиск. Такая среда имеет следующие признаки согласно таблице 2-5:

* Полностью наблюдаемая
* Детерминированная
* Последовательная
* Статическая или полудинамическая
* Дискретная
* Мультиагентная

Теория ИИ называет задачу поиска в условиях противодействия **игрой**. С точки зрения теории игр это определение недостаточно точное.Состязательный поиск работает только в играх конкретного типа. Они должны иметь следующие признаки согласно таблице 1-1:

* Последовательный порядок ходов
* Нулевая сумма выигрышей
* Полная информация
* Совершенная информация
* Детерминированность
* Фиксированные правила
* Дискретность

Для игр с другими признаками состязательной поиск неэффективен.

Пространством состояний для состязательного поиска является дерево игры. Это дерево соответствует развёрнутой форме представления игр, которую использует теория игр для поиска решения.

Мы рассмотрим два алгоритма состязательного поиска. Их демонстрирует таблица 2-16.

{caption: "Таблица 2-16. Алгоритмы состязательного поиска", width: "100%"}
| Алгоритм | Временная сложность | Пространственная сложность | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Минимакс (minimax) | O(b^m^) | O(b*m) | Да | Да, если все оппоненты действуют оптимально |
|  | | | | |
| Альфа-бета-отсечение (alpha-beta pruning) | O(b^m/2^) | O(b*m) | Да | Да, если все оппоненты действуют оптимально |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — коэффициент ветвления.
* m — максимальная глубина графа поиска.

### Минимакс

Самый известный алгоритм состязательного поиска называется [**минимакс**](https://ru.wikipedia.org/wiki/Минимакс). Он проходит узлы дерева в том же порядке, что и поиск в глубину. Во время прохода алгоритм оценивает потенциальные выигрыши каждого игрока в посещённых узлах. Эти выигрыши называются **минимаксными значениями**.

Рассмотрим работу алгоритма минимакс в самом простом случае. Два агента соревнуются в игре с нулевой суммой. Назовём агента, выполняющего первый ход, MAX (от максимум). Тогда MIN (от минимум) — это агент, делающий второй ход.

Задача игрок MAX — получить максимальный выигрыш в результате каждого своего хода. После него ходит игрок MIN. Его задача минимизировать выигрыш игрока MAX. В этом состоит оптимальная стратегия агента MIN. Так как игра с нулевой суммой, то минимизируя выигрыш оппонента, игрок MIN максимизирует свой собственный выигрыш.

Алгоритм минимакс использует поиск в глубину, чтобы пройти пространство состояний от начального узла до **терминального**. Терминальным называется состояние среды в котором игра окончена.

Каждому терминальному состоянию соответствует пара выигрышей для игроков MAX и MIN. Поскольку игра с нулевой суммой, то часто терминальному узлу присваивают выигрыш только игрока MAX. Его достаточно для правильной работы алгоритма минимакс.

Рассмотрим пример работы алгоритма минимакс. Иллюстрация 2-12 демонстрирует дерево поиска и порядок обхода его узлов.

{caption: "Иллюстрация 2-12. Поиск по минимакс алгоритму", height: "50%", width: "100%"}
![Минимакс алгоритм](images/ArtificialIntelligence/minimax-tree.png)

На иллюстрации приведена игра, в которой участники делают три хода. Первым ходит игрок MAX в узле A. Затем ходит игрок MIN в узлах B и C. Завершает игру ход MAX в узлах D, E, F, G.

Цвет узла соответствует игроку, который должен выполнить ход. В зелёных узлах ходит игрок MAX, а в красных — MIN. Терминальные узлы, в которых игра заканчивается, отмечены синим цветом.

Таблица 2-17 демонстрирует шаги алгоритма минимакс для дерева поиска с иллюстрации 2-12. Для каждого шага указан посещаемый узел и его новое минимаксное значение.

{caption: "Таблица 2-17. Шаги алгоритма минимакс", width: "70%"}
| Шаг | Посещённый узел | Новое минимаксное значение |
| --- | --- | --- |
| 1 | A | -∞ |
| 2 | B | +∞ |
| 3 | D | -∞ |
| 4 | H | 1 |
| 5 | D | 1 |
| 6 | I | 6 |
| 7 | D | 6 |
| 8 | B | 6 |
| 9 | E | -∞ |
| 10 | J | 7 |
| 11 | E | 7 |
| 12 | K | 4 |
| 13 | E | 7 |
| 14 | B | 6 |
| 15 | A | 6 |
| 16 | C | +∞ |
| 17 | F | -∞ |
| 18 | L | 5 |
| 19 | F | 5 |
| 20 | M | 2 |
| 21 | F | 5 |
| 22 | C | 5 |
| 23 | G | -∞ |
| 24 | N | 10 |
| 25 | G | 10 |
| 26 | O | 3 |
| 27 | G | 10 |
| 28 | C | 5 |
| 29 | A | 6 |

До того как алгоритм посетит терминальный узел, потенциальные выигрыши в его родительских узлах неизвестны. Поэтому в качестве минимаксного значения для родительских узлов алгоритм выбирает плюс или минус бесконечность (∞). Минус бесконечность выбирается для узлов, в которых ходит MAX. Плюс бесконечность — для узлов с ходом MIN.

Когда алгоритм посещает терминальный узел, он использует **функцию полезности**. Эта функция вычисляет выигрыш игрока MAX в проверяемом терминальном узле.

Проверив терминальный узел, алгоритм возвращается к его родительскому узлу и присваивает ему новое минимаксное значение. Это значение зависит от того, какой игрок делает ход в родительском узле. Правило выбора минимаксного значения выглядит так:

* Если узел терминальный, получить значение от функции полезности.

* Если в узле ходит игрок MAX, присвоить ему наибольшее из минимаксных значений дочерних узлов.

* Если в узле ходит игрок MIN, присвоить ему наименьшее из минимаксных значений дочерних узлов.

Согласно этому правилу, узлу D на иллюстрации 2-12 присваивается наибольшее минимаксное значение 6 дочернего узла I. Это происходит потому, что в узле D ходит игрок MAX.

В узле B ходит игрок MIN, поэтому ему присваивается наименьшее минимаксное значение 6 дочернего узла D, а не значение 7 узла E.

Аналогично алгоритм минимакс присваивает минимаксные значения всем узлам дерева. После этого алгоритм составляет решение, которое представляет собой путь от корневого узла до терминального узла с наилучшим гарантированным выигрышем для игрока MAX. В примере на иллюстрации 2-12 этот путь отмечен чёрной стрелкой:

A -> B -> D -> I

Достоинства алгоритма минимакс:

* Полнота.

* Оптимальность, если все игроки действуют оптимально.

* Низкая пространственная сложность.

Недостатки алгоритма минимакс:

* Высокая временная сложность.

Алгоритм минимакс успешно находит решения игр с небольшим коэффициентом ветвления, например крестики-нолики. Для более сложных игр вроде шахмат и го алгоритм работает слишком медленно. Его скорости не хватает даже для просчёта 4-5 ходов наперёд за разумное время.

Проблему медленной работы алгоритма минимакс решает метод **альфа-бета отсечения**.

### Альфа-бета отсечение

Метод альфа-бета отсечения также известен, как [**альфа-бета алгоритм**](https://ru.wikipedia.org/wiki/Альфа-бета-отсечение). Этот метод применяется к алгоритму минимакс для оптимизации. Благодаря отсечению, в лучшем случае можно сократить число проверяемых узлов наполовину. При этом алгоритмы альфа-бета и минимакс гарантированно дают одинаковый результат.

Алгоритм получил своё названием благодаря двум параметрам, которые обновляются в процессе его работы:

* α (альфа) — наибольшее минимаксное значение узла, которое было найдено вдоль пути для игрока MAX. Это значение считается наилучшим для MAX.

* β (бета) — наименьшее минимаксное значение узла, которое было найдено вдоль пути для игрока MIN. Оно будет наилучшим для MIN.

Вот правила обновления значений α и β:

* Значение α обновляет только игрок MAX в узлах, в которых он делает ход. Новым значением α становится минимаксное значение этого узла, только если оно больше текущего α. В противном случае α не меняется.

* Значение β обновляет только игрок MIN в узлах со своим ходом. Новым β становится минимаксное значение этого узла, только если оно меньше текущего β. В противном случае β не меняется.

* Дочерние узлы всегда наследуют значения α и β от родительских узлов.

Отсечение происходит по следующему правилу:

* Если в каком-то узле значение α оказывается строго больше β, все его непроверенные дочерние узлы отсекаются.

Сравнивая значения α и β с минимаксными значениями узлов, алгоритм способен отсекать не только отдельные узлы, но и целые поддеревья.

Рассмотрим альфа-бета алгоритм на примере игры с иллюстрации 2-12. Работу алгоритма демонстрирует иллюстрация 2-13.

{caption: "Иллюстрация 2-13. Поиск по алгоритму альфа-бета", height: "50%", width: "100%"}
![Алгоритм альфа-бета](images/ArtificialIntelligence/alpha-beta-pruning-tree.png)

Таблица 2-18 демонстрирует шаги алгоритма альфа-бета для дерева поиска с иллюстрации 2-13. Для каждого шага указан посещаемый узел, его новое минимаксное значение, а также текущие значения α и β.

{caption: "Таблица 2-18. Шаги алгоритма минимакс", width: "100%"}
| Шаг | Посещённый узел | Новое минимаксное значение | α | β |
| --- | --- | --- | --- | --- |
| 1 | A | -∞ | -∞ | +∞ |
| 2 | B | +∞ | -∞ | +∞ |
| 3 | D | -∞ | -∞ | +∞ |
| 4 | H | 1 | -∞ | +∞ |
| 5 | D | 1 | 1 | +∞ |
| 6 | I | 6 | 1 | +∞ |
| 7 | D | 6 | 6 | +∞ |
| 8 | B | 6 | 6 | 6 |
| 9 | E | -∞ | 6 | 6 |
| 10 | J | 7 | 6 | 6 |
| 11 | E | 7 | 7 | 6 |
| 12 | B | 6 | 6 | 6 |
| 13 | A | 6 | 6 | +∞ |
| 14 | C | +∞ | 6 | +∞ |
| 15 | F | -∞ | 6 | +∞ |
| 16 | L | 5 | 6 | +∞ |
| 17 | F | 5 | 6 | +∞ |
| 18 | M | 2 | 6 | +∞ |
| 19 | F | 5 | 6 | +∞ |
| 20 | C | 5 | 6 | 5 |
| 21 | A | 6 | 6 | 6 |

Иллюстрация 2-13 показывает, что алгоритм альфа-бета отсекает узлы K, G, N, O. Алгоритм не посещает эти узлы, поскольку они никак не влияют на конечное решение.

Рассмотрим шаги алгоритма в таблице 2-18. Первые 11 шагов альфа-бета отсечения и минимакса полностью совпадают. Алгоритмы присваивают одни и те же минимаксные значения узлам B, D, E, H, I, J.

Первое различие в таблицах 2-17 и 2-18 происходит на шаге 12. На этом шаге алгоритм минимакс посещает узел K. Альфа-бета отсечение пропускает узел K без проверки. Это происходит потому, что на 11 шаге для узла E выполнилось условие α > β (7 > 6). При выполнении этого условия все непосещённые дочерние узлы E отсекаются.

Далее на 13 шаге алгоритм альфа-бета возвращается в корневой узел A. После этого он проходит по узлам C, F, L и M. В результате этого прохода узлы получают те же минимаксные значения, которые им назначил бы минимаксный алгоритм.

На 20 шаге алгоритм альфа-бета поднимается в узел C из F. В этот момент алгоритм сравнивает значения α и β для узла C. Оказывается, что для него выполняется условие α > β (6 > 5). Поэтому алгоритм отсекает все оставшиеся непосещённые дочерние узлы C: G, N и O.

В результате алгоритм альфа-бета находит такое же решение, как и алгоритм минимакс. Оно отмечено чёрной стрелкой на иллюстрации 2-13:

A -> B -> D -> I

Достоинства алгоритма альфа-бета:

* Полнота.

* Оптимальность, если все игроки действуют оптимально.

* Низкая пространственная сложность.

Недостатки алгоритма альфа-бета:

* Временная сложность зависит от порядка проверки узлов. В худшем случае алгоритмы альфа-бета и минимакс проверяют одинаковое количество узлов.

* Повторяющиеся состояния в дерево поиска (**транспозиции**) увеличивают временную сложность экспоненциально.

I> Транспозицией называются последовательности ходов, которые приводят к одному и тому же результату.

### Неидеальные ходы при ограниченном времени