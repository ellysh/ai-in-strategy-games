## 2.5 Состязательный поиск

Мы познакомились с алгоритмами классического поиска. Их используют агенты, которые работают в одноагентной среде. Эта среда может быть достаточно сложной. Но агент сможет в ней действовать, если выбрать подходящий алгоритм.

Ни один из алгоритмов классического поиска не работает в мультиагентной среде. В такой среде одновременно действуют два или более агентов. Проблема в том, что действия каждого из них меняют состояние среды. Все алгоритмы классического поиска учитывает действия только одного агента.

Если среда конкурентная, то агенты могут целенаправленно мешать друг другу. Это намного усложняет решение задачи. Поиск в таких условиях называется **состязательным** или **поиском в условиях противодействия** (adversarial search). Его применяют агенты, основанные на полезности.

### 2.5.1 Проблемная среда

Состязательный поиск работает не во всех проблемных средах. Чтобы он был эффективным, среда должна иметь следующие характеристики, согласно таблице 2-5:

* Полностью наблюдаемая
* Детерминированная
* Последовательная
* Статическая или полудинамическая
* Дискретная
* Мультиагентная

Теория ИИ называет задачу поиска в условиях противодействия **игрой**. С точки зрения теории игр это определение неточное. Состязательный поиск работает только в играх конкретного типа. Они должны иметь следующие характеристики, согласно таблице 1-1:

* Последовательный порядок ходов
* Нулевая сумма выигрышей
* Полная информация
* Совершенная информация
* Детерминированность
* Фиксированные правила
* Дискретность

Для игр с другими признаками состязательный поиск неэффективен.

Пространство состояний для состязательного поиска — это развёрнутая форма представления игры в виде дерева. Именно эту форму использует теория игр для поиска решения игры. Мы познакомились с ней в разделе 1.3.1.

Мы рассмотрим два алгоритма состязательного поиска. Их свойства указаны в таблице 2-18.

{caption: "Таблица 2-18. Алгоритмы состязательного поиска", width: "100%"}
| Алгоритм | Время | Память | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Минимакс (minimax) | O(b^m^) | O(b*m) | Да | Да, если все оппоненты действуют оптимально |
|  | | | | |
| Альфа-бета отсечение (alpha-beta pruning) | ![](images/ArtificialIntelligence/alpha-beta-pruning-complexity-formula.png) | O(b*m) | Да | Да, если все оппоненты действуют оптимально |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — коэффициент ветвления.
* m — максимальная глубина дерева поиска.

Теперь мы готовы рассмотреть алгоритмы состязательного поиска.

### 2.5.2 Минимакс

Основополагающий алгоритм состязательного поиска называется [**минимакс**](https://ru.wikipedia.org/wiki/Минимакс) (minimax). Он был разработан первым. Большинство других алгоритмов состязательного поиска являются его улучшениями и вариациями.

Алгоритм минимакс основан на [теореме о минимаксе](https://fr-m-wikipedia-org.translate.goog/wiki/Théorème_du_minimax_de_von_Neumann?_x_tr_sl=auto&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp). Её сформулировал и доказал Джон фон Нейман для игр с нулевой суммой и двумя участниками. Учёный привёл своё доказательство в статье "По теории настольных игр" (Zur Theorie der Gesellschaftsspiele) 1928 года. Позже её неоднократно обобщали и переформулировали.

Поиск минимакс проходит узлы дерева в том же порядке, что и поиск в глубину (DFS). Во время прохода алгоритм оценивает потенциальные выигрыши каждого игрока в посещённых узлах. Эти выигрыши называются **минимаксными значениями** (minimax value).

Рассмотрим работу алгоритма минимакс в самом простом случае. Два агента соревнуются в игре с нулевой суммой. Назовём выполняющего первый ход агента MAX (максимум). Тогда MIN (минимум) — это агент, делающий второй ход.

Задача игрока MAX — получить максимальный выигрыш от каждого своего хода. Задача игрока MIN противоположная — минимизировать выигрыш игрока MAX. В этом заключается его оптимальная стратегия. Игра с нулевой суммой. Это означает, что минимизируя выигрыш оппонента, игрок MIN максимизирует свой собственный выигрыш.

Алгоритм минимакс использует поиск в глубину, чтобы пройти пространство состояний от начального узла до **терминального**. Терминальный узел дерева не имеет дочерних узлов. Он соответствует состоянию среды, в котором игра окончена.

Каждому терминальному состоянию соответствует пара выигрышей для игроков MAX и MIN. Поскольку игра с нулевой суммой, то часто терминальному узлу присваивают выигрыш только игрока MAX. Этого достаточно для правильной работы алгоритма минимакс.

Рассмотрим пример работы алгоритма минимакс. Иллюстрация 2-16 демонстрирует дерево игры и порядок обхода его узлов.

{caption: "Иллюстрация 2-16. Поиск по минимакс алгоритму"}
![Минимакс алгоритм](images/ArtificialIntelligence/minimax-tree.png)

На иллюстрации приведена игра, в которой участники делают три хода. Первым ходит игрок MAX в узле A. Затем ходит игрок MIN в узлах B и C. Завершает игру ход MAX в узлах D, E, F, G.

Цвет узла соответствует игроку, который должен выполнить ход. В зелёных узлах ходит игрок MAX, а в красных — MIN. Терминальные узлы, в которых игра заканчивается, отмечены синим цветом. Около каждого терминального узла указан выигрыш игрока MAX.

Таблица 2-19 демонстрирует шаги алгоритма минимакс для дерева игры на иллюстрации 2-16. При посещении каждого узла алгоритм вычисляет для него новое минимаксное значение. Оно так же приводится в таблице.

{caption: "Таблица 2-19. Шаги алгоритма минимакс", width: "70%"}
| Шаг | Посещённый узел | Новое минимаксное значение |
| --- | --- | --- |
| 1 | A | -∞ |
| 2 | B | +∞ |
| 3 | D | -∞ |
| 4 | H | 1 |
| 5 | D | 1 |
| 6 | I | 6 |
| 7 | D | 6 |
| 8 | B | 6 |
| 9 | E | -∞ |
| 10 | J | 7 |
| 11 | E | 7 |
| 12 | K | 4 |
| 13 | E | 7 |
| 14 | B | 6 |
| 15 | A | 6 |
| 16 | C | +∞ |
| 17 | F | -∞ |
| 18 | L | 5 |
| 19 | F | 5 |
| 20 | M | 2 |
| 21 | F | 5 |
| 22 | C | 5 |
| 23 | G | -∞ |
| 24 | N | 10 |
| 25 | G | 10 |
| 26 | O | 3 |
| 27 | G | 10 |
| 28 | C | 5 |
| 29 | A | 6 |

До того как алгоритм посетит терминальный узел, потенциальные выигрыши в его родительских узлах неизвестны. В этом случае алгоритм выбирает минимаксное значение плюс или минус бесконечность (∞). Минус бесконечность — для узлов, в которых ходит MAX. Плюс бесконечность — для узлов с ходом MIN.

Когда алгоритм достигает терминального узла, он вычисляет выигрыш игрока MAX в нём. Для этого применяется **функция полезности**. Функция даёт минимаксное значение для терминального узла. После этого алгоритм возвращается к его родительскому узлу. Ему присваивается новое минимаксное значение. Значение зависит от того, какой игрок делает ход в этом узле.

Общее правило выбора минимаксного значения для узла выглядит так:

* Если узел терминальный, получить значение от функции полезности.

* Если в узле ходит игрок MAX, присвоить ему наибольшее из минимаксных значений дочерних узлов.

* Если в узле ходит игрок MIN, присвоить ему наименьшее из минимаксных значений дочерних узлов.

Согласно этому правилу, узлу D на иллюстрации 2-16 присваивается наибольшее минимаксное значение 6 дочернего узла I. Это происходит потому, что в узле D ходит игрок MAX. В узле B ходит игрок MIN, поэтому ему присваивается наименьшее минимаксное значение 6 дочернего узла D, а не значение 7 узла E. Аналогично алгоритм минимакс присваивает минимаксные значения всем узлам дерева.

После этого алгоритм составляет решение. Решение — это путь от корневого узла до терминального узла с наилучшим гарантированным выигрышем для игрока MAX. На иллюстрации 2-16 этот путь отмечен чёрной стрелкой:

A -> B -> D -> I

Достоинства алгоритма минимакс:

* Полнота.

* Оптимальность, если все игроки действуют оптимально.

* Низкая пространственная сложность.

Недостатки алгоритма минимакс:

* Высокая временная сложность.

Алгоритм минимакс успешно находит решения игр с небольшим коэффициентом ветвления, например крестики-нолики. Для более сложных игр вроде шахмат алгоритм работает слишком медленно. Его скорости не хватает даже для просчёта 4-х ходов вперёд за разумное время.

Проблему медленной работы алгоритма минимакс решает его модификация с названием **альфа-бета отсечение**.

### 2.5.3 Альфа-бета отсечение

[**Алгоритм альфа-бета отсечения**](https://ru.wikipedia.org/wiki/Альфа-бета-отсечение) — это модификация алгоритма минимакс, которая улучшает его временную сложность. Благодаря отсечению, в лучшем случае можно сократить число проверяемых узлов наполовину. При этом алгоритмы альфа-бета и минимакс гарантированно дают одинаковый результат.

Алгоритм получил своё названием благодаря двум параметрам, которые обновляются в процессе его работы:

* α (альфа) — наибольшее минимаксное значение узла, которое было найдено вдоль пути для игрока MAX. Это значение считается наилучшим для MAX.

* β (бета) — наименьшее минимаксное значение узла, которое было найдено вдоль пути для игрока MIN. Оно будет наилучшим для MIN.

Вот правила обновления значений α и β:

* Значение α обновляет только игрок MAX в узлах, в которых он делает ход. Новым значением α становится минимаксное значение этого узла, только если оно больше текущего α. В противном случае α не меняется.

* Значение β обновляет только игрок MIN в узлах со своим ходом. Новым β становится минимаксное значение этого узла, только если оно меньше текущего β. В противном случае β не меняется.

* Дочерние узлы всегда наследуют значения α и β от родительских узлов.

Отсечение происходит по следующему правилу:

* Если в каком-то узле значение α оказывается строго больше β, все его непроверенные дочерние узлы отсекаются.

Сравнивая значения α и β с минимаксными значениями узлов, алгоритм способен отсекать не только отдельные узлы, но и целые поддеревья.

Рассмотрим альфа-бета алгоритм на примере игры с иллюстрации 2-16. Работу алгоритма демонстрирует иллюстрация 2-17.

{caption: "Иллюстрация 2-17. Поиск по алгоритму альфа-бета"}
![Алгоритм альфа-бета](images/ArtificialIntelligence/alpha-beta-pruning-tree.png)

Таблица 2-20 демонстрирует шаги алгоритма альфа-бета для дерева поиска с иллюстрации 2-17. Для каждого шага указан посещаемый узел, его новое минимаксное значение, а также текущие значения α и β.

{caption: "Таблица 2-20. Шаги алгоритма минимакс", width: "90%"}
| Шаг | Посещённый узел | Новое минимаксное значение | α | β |
| --- | --- | --- | --- | --- |
| 1 | A | -∞ | -∞ | +∞ |
| 2 | B | +∞ | -∞ | +∞ |
| 3 | D | -∞ | -∞ | +∞ |
| 4 | H | 1 | -∞ | +∞ |
| 5 | D | 1 | 1 | +∞ |
| 6 | I | 6 | 1 | +∞ |
| 7 | D | 6 | 6 | +∞ |
| 8 | B | 6 | 6 | 6 |
| 9 | E | -∞ | 6 | 6 |
| 10 | J | 7 | 6 | 6 |
| 11 | E | 7 | 7 | 6 |
| 12 | B | 6 | 6 | 6 |
| 13 | A | 6 | 6 | +∞ |
| 14 | C | +∞ | 6 | +∞ |
| 15 | F | -∞ | 6 | +∞ |
| 16 | L | 5 | 6 | +∞ |
| 17 | F | 5 | 6 | +∞ |
| 18 | M | 2 | 6 | +∞ |
| 19 | F | 5 | 6 | +∞ |
| 20 | C | 5 | 6 | 5 |
| 21 | A | 6 | 6 | 6 |

Иллюстрация 2-17 показывает, что алгоритм альфа-бета отсекает узлы K, G, N, O. Алгоритм не посещает эти узлы, поскольку они никак не влияют на конечное решение.

Рассмотрим шаги алгоритма в таблице 2-20. Первые 11 шагов альфа-бета отсечения и минимакса полностью совпадают. Алгоритмы присваивают одни и те же минимаксные значения узлам B, D, E, H, I, J.

Первое различие в таблицах 2-19 и 2-20 происходит на шаге 12. На этом шаге алгоритм минимакс посещает узел K. Альфа-бета отсечение пропускает узел K без проверки. Это происходит потому, что на 11 шаге для узла E выполнилось условие α > β (7 > 6). При выполнении этого условия все непосещённые дочерние узлы E отсекаются.

Далее на 13 шаге алгоритм альфа-бета возвращается в корневой узел A. После этого он проходит по узлам C, F, L и M. В результате этого прохода узлы получают те же минимаксные значения, которые им назначил бы минимаксный алгоритм.

На 20 шаге алгоритм альфа-бета поднимается в узел C из F. В этот момент алгоритм сравнивает значения α и β для узла C. Оказывается, что для него выполняется условие α > β (6 > 5). Поэтому алгоритм отсекает все оставшиеся непосещённые дочерние узлы C: G, N и O.

В результате алгоритм альфа-бета находит такое же решение, как и алгоритм минимакс. Оно отмечено чёрной стрелкой на иллюстрации 2-17:

A -> B -> D -> I

Достоинства алгоритма альфа-бета:

* Полнота.

* Оптимальность, если все игроки действуют оптимально.

* Низкая пространственная сложность.

Недостатки алгоритма альфа-бета:

* Временная сложность зависит от порядка проверки узлов. В худшем случае алгоритмы альфа-бета и минимакс проверяют одинаковое количество узлов.

* Повторяющиеся состояния в дереве поиска (**транспозиции**) увеличивают временную сложность экспоненциально.

I> Транспозицией называются последовательности ходов, которые приводят к одному и тому же результату.

{pagebreak}
