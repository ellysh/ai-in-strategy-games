## Классический поиск

Мы кратко рассмотрели теорию интеллектуальных агентов. С её помощью мы научились по условию задачи определять тип проблемной среды. Далее по типу среды, можно подобрать подходящий тип интеллектуального агента. Тип агента определяет методы ИИ на которых строится программа агента.

Рассмотрим современные методы ИИ, которые основаны на алгоритмах поиска. Эти методы используют интеллектуальные агенты двух типов:

* Основанные на цели
* Основанные на производительности

Сначала познакомимся с алгоритмами, известными как **классический поиск**. Они используются в одноагентных средах.

### Пространство состояний

В ИИ применяют алгоритмы поиска, которые относятся к классу [**поиска в пространстве состояний**](https://ru.wikipedia.org/wiki/Поиск_в_пространстве_состояний). Эти алгоритмы отличаются от [традиционных алгоритмов поиска](https://en.wikipedia.org/wiki/Search_algorithm), которые изучает информатика.

Традиционные алгоритмы поиска находят заданное значение в некоторой структуре данных. Обычно эта структура данных целиком помещается в память компьютера. Сам алгоритм заключается в переборе значений, которые хранит структура. Когда искомое и проверяемое значение совпадают, поиск завершается.

При поиске в пространстве состояний структура данных не задаётся явно. Вместо этого есть состояния среды, которые проверяет интеллектуальный агент. Набор всех возможных состояний среды называется [**пространством состояний**](https://en.wikipedia.org/wiki/State_space).

Пространство состояний обычно представляют в форме графа. Граф состоит из вершин, которые соединяются рёбрами. Вершины соответствуют состояниям среды. Рёбра обозначают действия агента, которые меняют состояние среды. Смена состояния означает переход между двумя вершинами, которые соединяет одно ребро.

Некоторые пространства состояний удобнее представлять в виде **ориентированного графа**. В таком графе рёбра имеют направления. Другими словами у каждого ребра есть начало и конец. Направленные рёбра называются **дугами**. Переход между вершинами графа возможен только по направлению рёбер.

Иллюстрация 2-2 демонстрирует ориентированный граф с двумя состояниями среды для программы очистки диска из прошлого раздела.

{caption: "Иллюстрация 2-2. Пространство состояний для программы очистки диска", height: "50%", width: "100%"}
![Пространство состояний](images/ArtificialIntelligence/disc-cleanup-graph.png)

Пространство состояний определяет:

1. Начальное состояние среды.
2. Набор допустимых действий агента в каждом состоянии среды.
3. Функция действия (action function) — возвращает новое состояние среды, если агент совершит указанное действие в указанном состоянии среды.

В этом списке нет набора всех возможных состояний среды. Если этот набор известен, то форма представления пространства состояний называется **явным графом**. Граф такого типа помещается в память компьютера целиком. Он подходит для простых проблемных сред, как на иллюстрации 2-2.

Если проблемная среда сложная, то пространство состояний представляется в форме **неявного графа**. В этом случае набор всех возможных состояний среды заранее неизвестен. Эти состояния выводятся в процессе поиска и помещаются в память компьютера. Затем они удаляются, если не соответствуют решению задачи.

Неявный граф применятся в тех случаях, когда памяти компьютера недостаточно для хранения всех возможных состояний среды.

### Решение задачи поиска

После определения пространства поиска решение задачи сводится к нахождению **пути** в графе. Путём называется такая последовательность рёбер или дуг, что конец каждой дуги является началом следующей.

Решение задачи — это путь в графе, который ведёт из начального состояния среды к искомому состоянию.

Выполняя алгоритм поиска, интеллектуальный агент проверяет каждую посещённую вершину графа. Это действие называется **проверкой цели**. Если состояние среды, соответствующее вершине, совпадает с искомым состоянием, то проверка цели проходит успешно.

В условии задачи цель может определяться как конкретное состояние среды. Тогда проверка цели сводится к сравнению текущего состояния и искомого.

В некоторых задачах цель формулируется как набор свойств, которым должно обладать искомое состояние. Тогда проверка цели заключается в проверке свойств текущего состояния.

Чтобы оценить показатели производительности выполняющего поиск агента, применяют понятие **стоимость пути**. Стоимость пути представляет собой функцию, которая даёт числовую оценку для указанного пути. Стоимость пути складывается из стоимостей составляющих его шагов. **Стоимость шага** — это числовая оценка действия агента, которое изменяет состояние среды.

**Решением** задачи называется путь из начальной вершины графа к искомой. **Оптимальным решением** называется решение с минимальной стоимостью.

### Оценка алгоритмов поиска

Алгоритмы поиска оцениваются по следующим показателям:

* Временная сложность (time complexity)
* Пространственная сложность (space complexity)
* Полнота (completeness)
* Оптимальность (optimality)

**Временная сложность** означает время выполнения алгоритма в зависимости от размера его входных данных.

**Пространственная сложность** — это объём памяти, который нужен для выполнения алгоритма. Этот объём зависит только от размера входных данных алгоритма.

Временная и пространственная сложности выражается в нотации ["О" большое](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое). "O" большое определяет характер изменения функции, когда её аргумент стремится к бесконечности. Другими словами "O" большое определяет, как быстро растёт функция в зависимости от её входных данных.

Рассмотрим пример. Предположим, что число шагов алгоритма N вычисляется в зависимости от размера входных данных n по следующей формуле: 2 * n^2^ + 5 * n + 10. В этом случае говорят, что временная сложность алгоритма равна O(n^2^).

При оценке сложности в нотации "O" большое учитывают только слагаемое самого высокого порядка. В нашем примере это слагаемое равно: 2 * n^2^. Константные множители тоже не учитываются. Это значит, что нам надо отбросить множитель 2. Тогда остаётся только n^2^. Таким образом мы получили сложность алгоритма O(n^2^).

Если сложность алгоритма не зависит от размера его входных данных, говорят что она равна O(1). При этом реальное число шагов алгоритма в оценке сложности не учитывается.

Иллюстрация 2-3 демонстрирует графики часто встречающихся функций оценки сложности алгоритма. Графики отражают зависимость числа шагов алгоритма N от размера входных данных n

{caption: "Иллюстрация 2-3. Функции оценки сложности алгоритма", height: "50%", width: "100%"}
![Функции оценки сложности](images/ArtificialIntelligence/computational-complexity.png)

Чем выше поднимается график функции от оси n, тем больше шагов выполняет алгоритм для обработки входных данных. Большее число шагов означает большую временную сложность. Другими словами, сложный алгоритм выполняется дольше, чем простой.

Пространственная сложность оценивается теми же самыми функциями, что и временная. В случае пространственной сложности ось N на иллюстрации 2-3 показывает объём памяти (например, в мегабайтах), который использует алгоритм в процессе своей работы.

Алгоритм поиска называется **полным**, если он гарантированно находит существующее решение в пространстве состояний за конечное число шагов. Если решение существует, но алгоритм его не находит в некоторых случаях, он называется **неполным**.

**Оптимальность** означает, что алгоритм находит оптимальное решение (с минимальной стоимостью) среди всех возможных.

Есть три класса алгоритмов поиска в пространстве состояний:

1. [**Неинформированный поиск**](https://ru.wikipedia.org/wiki/Неинформированный_метод_поиска) (uninformed search)
2. [**Информированный поиск**](https://ru.wikipedia.org/wiki/Информированный_метод_поиска) (informed search)
3. Поиск в условиях противодействия (adversarial search)

Рассмотрим алгоритмы каждого класса и сравним их эффективность.

### Неинформированный поиск

К классу **неинформированного поиска** относятся алгоритмы, которые не используют дополнительную информацию о пространстве поиска. В этих алгоритмах выполняются только два типа действий:

* Переход между вершинами графа пространства состояний.
* Проверка текущей вершины графа на соответствие искомого состояния среды.

Алгоритмы неинформированного поиска различаются только порядком перехода между вершинами графа пространства состояний. Таблица 2-10 демонстрирует эти алгоритмы.

{caption: "Таблица 2-10. Алгоритмы неинформированного поиска", width: "100%"}
| Алгоритм | Временная сложность | Пространственная сложность | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Поиск в ширину (BFS) | O(b^d^) | O(b^d^) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Поиск по критерию стоимости (UCS) | O(b^1+C/ε^) | O(b^1+C/ε^) | Да, если стоимости всех шагов строго положительны | Да, если стоимости всех шагов строго положительны |
|  | | | | |
| Поиск в глубину (DFS) | O(b^m^) | O(b*m) | Нет | Нет |
|  | | | | |
| Поиск с ограничением глубины (DLS) | O(b^l^) | O(b*l) | Нет | Нет |
|  | | | | |
| Поиск в глубину с итеративным углублением (IDDFS) | O(b^d^) | O(b*d) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Двунаправленный поиск | O(b^d/2^) | O(b^d/2^) | Да | Да, если стоимость всех шагов одинакова |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — **коэффициент ветвления**. Означает количество вершин, напрямую соединённых с каждой вершиной графа. Если это количество отличается для разных вершин, вычисляется среднее значение.
* d — глубина (длина пути) самого поверхностного решения.
* C — стоимость пути оптимального решения.
* ε — стоимость каждого шага, который приближает алгоритм к целевой вершине.
* m — максимальная глубина графа поиска.
* l — ограничение глубины поиска.

В общем случае алгоритмы неинформированного поиска работают для явных и неявных графов. Мы рассмотрим эти алгоритмы для явных деревьев. Так будет проще проиллюстрировать их принцип работы.

**Дерево** — это частный случай графа, в котором нет циклов. Кроме того между любой парой вершин такого графа есть минимум один путь.

[**Цикл**](https://ru.wikipedia.org/wiki/Цикл_(теория_графов)) в теории графов — это путь, который начинается и заканчивается в одной и той же вершине.

#### Поиск в ширину

Алгоритм **поиска в ширину** (breadth-first search, BFS) проходит по дереву поиска уровень за уровнем, начиная с корневого узла.

Иллюстрация 2-4 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-4. Порядок обхода узлов при поиске в ширину", height: "50%", width: "100%"}
![Поиск в ширину](images/ArtificialIntelligence/bfs-tree.png)

Номера в узлах дерева указывают порядок их обхода. Поиск начинается с корневого узла 1. Затем проверяются узлы первого уровня с номерами 2 и 3. После этого алгоритм проходит по узлам последнего уровня с номерами 4, 5, 6, 7. Порядок обхода узлов на одном уровне слева направо.

Достоинства поиска в ширину:

* Гарантированно находит решение, если оно существует (полнота).
* Находит оптимальное решение, если стоимость всех шагов одинакова (оптимальность).

Недостатки поиска в ширину:

* Требует много памяти (пространственная сложность). В худшем случае надо сохранить все посещённые узлы дерева поиска.
* Если решение представляет собой длинный путь, алгоритм ищет его очень долго (временная сложность).

#### Поиск по критерию стоимости

**Поиск по критерию стоимости** (uniform-cost search, UCS) используется для обхода дерева или графа, в котором стоимость шагов различается. Алгоритм проходит узлы в порядке возрастания стоимости пути от корневого узла. Первым проверяется узел стоимость пути до которого минимальна.

Если стоимость всех шагов в дереве или графе одинакова, поиск по критерию стоимости работает так же как поиск в ширину.

Иллюстрация 2-5 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-5. Порядок обхода узлов при поиске по критерию стоимости", height: "50%", width: "100%"}
![Поиск по критерию стоимости](images/ArtificialIntelligence/ucs-tree.png)

Номера в узлах дерева обозначают порядок их обхода. На иллюстрации около каждого ребра указана стоимость соответствующего шага. Алгоритм начинает проход с корневого узла 1. Стоимость шага до узла 2 равна 1. Это меньше стоимости шага 2 до узла 3. Поэтому алгоритм переходит в узел с номером 2.

Далее алгоритм вычисляет стоимость пути до узлов 5 и 4. Для узла 5 стоимость складывается из стоимости путей между узлами 1-2 и 2-5. В результате получается стоимость `1 + 3 = 4`. Для узла 4 стоимость равна `1 + 2 = 3`. В этом случае алгоритм выбирает проверку узла 3, потому что стоимость пути до него равна 2. Это меньше стоимости пути до узлов 5 и 4.

Далее алгоритм проверяет узел с минимальной стоимостью пути. Это узел под номером 4. Затем идут узлы:

* 5 — стоимость пути 4
* 6 — стоимость пути 5
* 7 — стоимость пути 6

Достоинства поиска по критерию стоимости:

* Находит оптимальное решение, потому что в первую очередь проходит пути с минимальной стоимостью (оптимальность).

Недостатки поиска по критерию стоимости:

* В наихудшем случае временная и пространственная сложность намного больше чем у поиска в ширину. Это происходит, потому что алгоритм сначала проверяет большие деревья из мелки шагов и только потом пути с большими шагами.

#### Поиск в глубину

**Поиск в глубину** (depth-first search, DFS) начинает с корневого узла и проходит каждый путь до самого дальнего узла. После этого алгоритм возвращается к ближайшему узлу, у которого есть непроверенные рёбра, и снова проходит до самого дальнего узла. Этот процесс повторяется, пока не пройдено всё дерево или граф.

Иллюстрация 2-6 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-6. Порядок обхода узлов при поиске в глубину", height: "50%", width: "100%"}
![Поиск в глубину](images/ArtificialIntelligence/dfs-tree.png)

Номера в узлах дерева указывают порядок их обхода. Поиск начинается с корневого узла 1. Затем алгоритм проходит до конца по левой ветви дерева через узлы 2 и 3. После этого он переходит на один шаг назад к узлу 2. У этого узла осталась непроверенная ветвь до узла 4. Алгоритм проверяет эту ветвь и возвращается в корневой узел 1. После этого он проходит по правой части дерева в аналогичном порядке.

Достоинства поиска в глубину:

* Требует очень мало памяти (пространственная сложность). Хранит только набор вершин по пути от корневой до текущей.

* Находит решение быстрее чем поиск в ширину, если начинается в правильном направлении (временная сложность).

Недостатки поиска в глубину:

* Если в графе или дереве есть циклы, алгоритм может зациклиться и не найти решения (полнота).

* Найденное решение может быть не оптимальным (оптимальность).

#### Поиск с ограничением глубины

**Поиск с ограничением глубины** (depth-limited search, DLS) — это вариант поиска в глубину с ограничением максимальной глубины прохода. Этот алгоритм решает проблему циклов, которые не может обработать поиск в глубину.

Иллюстрация 2-7 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-7. Порядок обхода узлов при поиске с ограничением глубины", height: "50%", width: "100%"}
![Поиск с ограничением глубины](images/ArtificialIntelligence/dls-tree.png)

Номера в узлах дерева указывают порядок их обхода. Иллюстрация демонстрирует обход дерева в случае ограничения глубины прохода, равном 3.

Алгоритм начинает с корневого узла 1 на глубине 0. Затем он идёт по левой ветви дерева через узлы 2 и 3. На узле 3 алгоритм останавливается, потому что этот узел находится на глубине 2. Это предел поиска для ограничения глубины, равном 3.

После этого алгоритм проходит узлы 4, 5, 6 и 7 в том же порядке что и поиск в глубину. На узле 7 алгоритм снова останавливается из-за ограничения глубины.

Достоинства поиска с ограничением глубины:

* Требует очень мало памяти также как поиск в глубину (пространственная сложность).

Недостатки поиска с ограничением глубины:

* Может не найти решения, если путь до него длиннее, чем ограничение глубины (полнота).

* Найденное решение может быть не оптимальным (оптимальность).

#### Поиск в глубину с итеративным углублением

**Поиск в глубину с итеративным углублением** (iterative-deepening depth-first search, IDDFS) — это вариант поиска с ограничением глубины. В нём пошагово увеличивается ограничение глубины до тех пор, пока не будет найдено решение.

Поиск в глубину с итеративным углублением представляет собой компромисс между поиском в ширину и поиском в глубину. Алгоритм имеет низкую пространственную ложность, но при этом полный и оптимальный.

Иллюстрация 2-8 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-8. Порядок обхода узлов при поиске в глубину с итеративным углублением", height: "50%", width: "100%"}
![Поиск в глубину с итеративным углублением](images/ArtificialIntelligence/iddfs-tree.png)

Поиск выполняется как последовательность итераций. Таблица 2-11 демонстрирует итерации для дерева поиска на иллюстрации 2-8.

{caption: "Таблица 2-11. Итерации поиска", width: "100%"}
| Номер итерации | Порядок посещения узлов |
| --- | --- |
| 1 | A |
|  | |
| 2 | A, B, C |
|  | |
| 3 | A, B, D, E, C, F, G |
|  | |
| 4 | A, B, D, H, I, E, C, F, G, J, K |

Достоинства поиска в глубину с итеративным углублением:

* Низкая пространственная сложность.

* Низкая временная сложность.

* Гарантированно находит решение, если оно есть (полнота).

* Найденное решение будет оптимальным (оптимальность).

Недостатки поиска в глубину с итеративным углублением:

* На каждой итерации алгоритм повторяет свои шаги из прошлой итерации.

Поиск в глубину с итеративным углублением считается лучшим алгоритмом неинформированного поиска, когда пространство поиска велико, а глубина решения неизвестна.

#### Двунаправленный поиск

**Двунаправленный поиск** (bidirectional search) заключается в одновременном поиске из корневого и целевого узлов. Поиск из корневого узла выполняется в прямом направлении, а из целевого узла — в обратном. Алгоритм прекращается, когда два процесса поиска встречаются. Таким образом решение составляется из двух частей. Это части пути, найденные поиском в прямом и в обратном направлениях.

Каждая часть двунаправленного поиска может выполняться любым алгоритмом неинформированного поиска (в ширину, в глубину, в глубину с ограничением и т.д.). Чаще всего используют поиск в ширину. Он обеспечивает полноту и оптимальность. Другие алгоритмы могут неполными или неоптимальными.

Для двунаправленного поиска должен быть известен целевой узел дерева или графа.

Иллюстрация 2-9 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-9. Порядок обхода узлов при двунаправленном поиске", height: "50%", width: "100%"}
![Двунаправленный поиск](images/ArtificialIntelligence/bidirectional-search-tree.png)

Поиск начинается в узле D. Он отмечен зелёным цветом. Целевой узел J отмечен оранжевым. Предположим, что в обоих направлениях выполняется поиск в ширину.

Во время двунаправленного поиска чередуются итерации прямого и обратного поиска. Таблица 2-12 демонстрирует эти итерации.

{caption: "Таблица 2-12. Итерации двунаправленного поиска", width: "100%"}
| Номер итерации | Направление поиска | Порядок посещения узлов |
| --- | --- | --- |
| 1 | Прямое | D |
|  | |
| 2 | Обратное | J |
|  | |
| 3 | Прямое | H, I, B |
|  | |
| 4 | Обратное | F, G |
|  | |
| 5 | Прямое | E, A |
|  | |
| 6 | Обратное | E, C, K |

Алгоритм останавливается на 6-ой итерации, когда прямой и обратный поиск встречаются в узле E. Далее алгоритм объединяет оба результата в один: D -> B -> E -> F -> J.

Достоинства двунаправленного поиска:

* Низкая пространственная сложность.

* Низкая временная сложность.

Недостатки поиска в глубину с итеративным углублением:

* Сложно реализовать в виде программы.

* Целевой узел должен быть известен заранее.

### Информированный поиск

Мы рассмотрели алгоритмы неинформированного поиска. Общая проблема таких алгоритмов в их неэффективности для большинства реальных задач. Как только пространство поиска становится большим, неинформированный поиск занимает слишком много времени и памяти из-за комбинаторного взрыва.

Алгоритмы **информированного поиска** решают проблему обработки большого пространства поиска. Эти алгоритмы применяют дополнительную информацию о поставленной задаче. Вот несколько примеров такой информации:

* Как далеко находится целевой узел от текущего?
* В каком направлении находится целевой узел?
* Какова стоимость пути до целевого узла?

Благодаря таким подсказкам, агент исключает некоторые ветви дерева без прохода по ним.

Подсказки даются агенту в виде **эвристической функции** (heuristics function). Эта функция принимает на вход текущий узел и оценивает, как далеко находится целевой узел. Эта оценка может выражаться в виде наименее дорогостоящего пути от текущего узла до целевого.

Рассмотрим пример. Предположим, что агент ищет кратчайший путь по улицам города от точки А на карте до точки Б. В этом случае эвристическая функция даст длину по прямой линии от А до Б. На практике этим путём воспользоваться нельзя, потому что агент вынужден двигаться по улицам и не может проходить сквозь дома. Из-за этого реальный путь от А до Б окажется больше, чем оценивает эвристическая функция.

Эвристическая функция называется **допустимой** (admissible), если её значение для любого узла меньше или равно фактической минимальной стоимости пути от этого узла до цели. Другими словами допустимая эвристическая функция никогда не переоценивает реальную стоимость решения.

Таблица 2-13 демонстрирует алгоритмы информированного поиска, которые применяются на практике чаще всего.

{caption: "Таблица 2-13. Алгоритмы информированного поиска", width: "100%"}
| Алгоритм | Временная сложность | Пространственная сложность | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Жадный поиск по первому наилучшему совпадению (GBFS) | O(b^m^) | O(b^m^) | Нет | Нет |
|  | | | | |
| Поиск A* | O(b^d^) | O(b^d^) | Да, если b конечное | Да, если эвристическая функция допустима |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — коэффициент ветвления.
* d — глубина (длина пути) самого поверхностного решения.
* m — максимальная глубина графа поиска.

#### Жадный поиск по первому наилучшему совпадению

Мы рассмотрим два алгоритма информированного. Они следуют общему подходу под названием **поиск по первому наилучшему совпадению** (best-first search, BFS). Самый простой вариант такого алгоритма называется **жадный поиск по первому наилучшему совпадению** (greedy best-first search, GBFS). Он выбирает путь к цели, который кажется наилучшим в данный момент. На каждом шаге алгоритм переходит в узел дерева или графа, который ближе всего к целевому узлу. Расстояние от текущего до целевого узла оценивает эвристическая функция. Алгоритм игнорирует стоимость шагов и полагается только на эвристическую функцию.

Иллюстрация 2-10 демонстрирует порядок обхода узлов дерева поиска.

{caption: "Иллюстрация 2-10. Порядок обхода узлов при жадном поиске по первому наилучшему совпадению", height: "50%", width: "100%"}
![Жадный поиск по первому наилучшему совпадению](images/ArtificialIntelligence/gbfs-tree.png)

Поиск начинается в корневом узле A. Целевой узел H. Эвристическая функция определяет расстояние по прямой от каждого узла до H. Эти расстояния отличаются от стоимости пути между узлами.

Таблица 2-14 демонстрирует все значения эвристической функции.

{caption: "Таблица 2-14. Значения эвристической функции", width: "100%"}
| Узел | Значение функции |
| --- | --- |
| A | 45 |
| B | 35 |
| C | 25 |
| D | 60 |
| E | 25 |
| F | 10 |
| G | 15 |
| H | 0 |
| I | 40 |

Жадный поиск по первому наилучшему совпадению ориентируется только на значения эвристической функции из таблицы 2-14. Поэтому он найдёт следующий путь:

A -> C -> F -> H

На первом шаге алгоритм выбирает между узлами B и C. Согласно эвристической функции из таблицы 2-14, узел C находится ближе к целевому узлу, чем B. Расстояние C-H равно 25, а B-H 35.

Далее алгоритм выбирает между узлами F и G. Расстояние F-H равно 10, согласно таблице 2-14. Расстояние G-H равно 15. Это значит, что узел F ближе к узлу H. Поэтому алгоритм выберет путь через узел F.

В нашем случае алгоритм GBFS нашёл неоптимальное решение. Стоимость найденного пути A-C-F-H равна `20 + 40 + 10 = 70`. Оптимальное решение — это путь A-C-G-H со стоимостью `20 + 10 + 20 = 50`. Причина выбора неоптимального решения в том, что алгоритм не учёл реальное расстояние между узлами C и F. Оно оказалось значительно больше, чем расстояние C-G.

Достоинства жадного поиска по первому наилучшему совпадению:

* В среднем алгоритм более эффективен, чем поиск в ширину и поиск в глубину (временная и пространственная сложность).

Недостатки жадного поиска по первому наилучшему совпадению:

* Если в графе или дереве есть циклы, алгоритм может зациклиться и не найти решения (полнота).

* Найденное решение может быть не оптимальным (оптимальность).

* Эффективность поиска зависит от качества эвристической функции.

#### Поиск A*

Другая разновидность поиска по первому наилучшему совпадению называется поиск А*. Он похож на алгоритм GBFS. Единственная разница в том, что поиск A* использует два фактора для оценки наилучшего узла для перехода:

1. Эвристическая функция.
2. Стоимость пути от начального узла.

Выразим эту оценку более формально на языке математики. Поиск A* использует **функцию оценки** `f(n)`, чтобы найти лучший следующий узел `n` для перехода. Обозначим эвристическую функцию как `h(n)`, а стоимость пути от начального узла до `n` как функцию `g(n)`. Тогда `f(n)` выражается так:
```
f(n) = g(n) + h(n)
```

Применим поиск A* для дерева на иллюстрации 2-10. Пусть значения эвристической функции будут такими же, как в таблице 2-14. В этом случае алгоритм поиска выполнит шаги из таблицы 2-15.

{caption: "Таблица 2-15. Шаги поиска A*", width: "100%"}
| Шаг | Узел | g(n) | h(n) | f(n) |
| --- | --- | --- | --- | --- |
| 1 | A | 0 | 45 | 45 |
| 2 | C | 20 | 25 | 45 |
| 3 | G | 30 | 15 | 45 |
| 4 | H | 50 | 0 | 50 |

Алгоритм начинает свою работу с корневого узла A. Там он находится на первом шаге.

На втором шаге алгоритм A* выбирает между узлами B и C. Для узла B значение `f(B)` рассчитывается так:
```
f(B) = g(B) + h(B) = 20 + 35 = 55
```

Для узла C значение `f(C)` рассчитывается так:
```
f(C) = g(C) + h(C) = 20 + 25 = 45
```

Значение функции оценки для узла С меньше,чем для B, т.е. `f(C) < f(B)`. Поэтому алгоритм выберет узел C на втором шаге.

Дальше алгоритм выбирает между узлами F и G на третьем шаге. Вот расчёт функции оценки `f(F)` для узла F:
```
f(F) = g(F) + h(F) = 60 + 10 = 70
```

Для узла G функция оценки будет такой:
```
f(G) = g(G) + h(G) = 30 + 15 = 45
```

`f(G) < f(F)`, поэтому алгоритм выберет узел G для перехода.

На четвёртом  шаге алгоритм выбирает между узлами H и I. Вот расчёт функции оценки для них:
```
f(H) = g(H) + h(H) = 50 + 0 = 50
f(I) = g(I) + h(I) = 60 + 40 = 100
```

Алгоритм перейдёт в целевой узел H с `f(H) = 50`, а не в узел I с `f(I) = 100`.

Достоинства поиска A*:

* Гарантированно находит решение, если оно есть (полнота).

* Найденное решение для дерева будет оптимальным, если эвристическая функция допустима (оптимальность).

Недостатки поиска A*:

* Не способен решать некоторые крупномасштабные задачи из-за высокого потребления памяти (пространственная сложность).

* Высокая временная сложность.

Чтобы поиск A* находил оптимальное решение на графе, эвристическая функция должна быть **преемственной** (монотонной). Для преемственной функции выполняется следующее неравенство:
```
h(A) ≤ cost(A,B) + h(B)
```

В нём используются следующие обозначения:

* A — узел графа.
* B — дочерний узел по отношению к A.
* h(n) — эвристическая функция.
* cost(A,B) — функция для нахождения пути между узлами.

#### Современные алгоритмы

Поиск A* — один из лучших алгоритмов информированного поиска. Он обладает полнотой и оптимальностью. Благодаря этим свойствам, он прекрасно справляется с небольшими задачами. Однако, высокая пространственная сложность мешает алгоритму решать крупные задачи.

Сегодня на практике применяются модификации поиска A*. Эти модификации используют меньше памяти за счёт увеличения времени работы. Вот некоторые из них:

* [**Поиск A* с итеративным углублением**](https://en.wikipedia.org/wiki/Iterative_deepening_A*) (iterative deepening A*, IDA*). Этот алгоритм напоминает поиск в глубину с итеративным углублением (IDDFS). В IDDFS в качестве ограничения глубины используется стоимость пути от корневого узла до узла n — это функция `g(n)`. IDA* глубина поиска ограничивается функцией оценки `f(n) = g(n) + h(n)`. Эта же самая функция `f(n)` используется в поиске A*.

* **Поиск A* с ограничением памяти** (memory bounded A*, MA*).

* [**Упрощённый поиск A* с ограничением памяти**](https://en.wikipedia.org/wiki/SMA*) (simplified memory bounded A*, SMA*). Этот алгоритм работает аналогично поиску A*. SMA* проходит по наиболее перспективным узлам с минимальным значением функции оценки `f(n)`. Когда доступная память исчерпана, SMA* удаляет информацию о наихудшем проверенном узле с максимальным значением `f(n)`. После удаления нескольких наихудших узлов алгоритм запоминает значение `f(n)` лучшего из них в их общем родительском узле. Благодаря этому, SMA* может вернуться к удалённым узлам, если другие направления поиска станут менее перспективными.

Кроме этих алгоритмов применяется также **рекурсивный поиск по первому наилучшему совпадению** (recursive best-first search, RBFS). Это одна из разновидностей алгоритма BFS (best-first search).

Алгоритм RBFS напоминает поиск в глубину с итеративным углублением (IDDFS). RBFS запоминает значение функции оценки `f(n)` для каждого предка текущего узла. Если функция оценки `f(A)` текущего узла A превышает одно из сохранённых значений `f(n)`, алгоритм  останавливается и переключается на поиск по альтернативному пути. В качестве этого пути выбирается потомок узла с наилучшим сохранённым значением `f(n)`.

Перед переключением на альтернативный путь RBFS сохраняет значение `f(A)`. Если альтернативный путь приводит к узлу с большим значением функции оценки, алгоритм возвращается к поиску пути от узла A.

Алгоритмы IDA* и RBFS хорошо справляются с обходом деревьев. В случае графов они могут оказаться неэффективными из-за циклов и многократных проверок одних и тех же узлов.

Ещё один недостаток IDA* и RBFS — переключение между альтернативными направлениями поиска. Если переключения происходят часто, время на решение задачи увеличивается. Для масштабных задач, это время может оказаться неприемлемо большим.

Алгоритм SMA* решает проблему частого переключения между направлениями поиска. Для этого он использует больше памяти чем IDA* и RBFS, но меньше чем поиск A*. SMA* представляет собой хороший компромисс между пространственной и временной сложностью.