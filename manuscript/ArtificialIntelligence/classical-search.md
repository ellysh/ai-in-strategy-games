## 2.4 Классический поиск

Мы познакомились с общими принципами пропозициональной логики и логики первого порядка. Их применяют рефлексные агенты, основанные на модели.

Теперь рассмотрим алгоритмы поиска. На них строятся интеллектуальные агенты двух типов:

* Агенты, основанные на цели.
* Агенты, основанные на производительности.

Все алгоритмы поиска можно разделить на два класса:

* **Классический поиск** (classical search).
* **Состязательный поиск** или поиск в условиях противодействия (adversarial search).

Начнём с классического поиска. Эти алгоритмы проще. Они хорошо работают в одноагентных средах.

Алгоритмы классического поиска можно разделить на два типа:

* [**Неинформированный поиск**](https://ru.wikipedia.org/wiki/Неинформированный_метод_поиска) (uninformed search)
* [**Информированный поиск**](https://ru.wikipedia.org/wiki/Информированный_метод_поиска) (informed search)

Неинформированным поиском пользуются агенты, основанные на цели. Информированный поиск применяют агенты, основанные на производительности.

### 2.4.1 Пространство состояний

Интеллектуальные агенты применяют алгоритмы [**поиска в пространстве состояний**](https://ru.wikipedia.org/wiki/Поиск_в_пространстве_состояний). Они отличаются от [традиционных алгоритмов поиска](https://en.wikipedia.org/wiki/Search_algorithm), которые изучает информатика.

Традиционные алгоритмы поиска находят заданное значение в некоторой структуре данных. Обычно эта структура целиком помещается в память компьютера. Сам алгоритм заключается в переборе значений, которые хранит структура. Когда искомое и проверяемое значение совпадают, поиск завершается.

При поиске в пространстве состояний структура данных не задаётся явно. Вместо этого есть состояния среды, в которой действует интеллектуальный агент. Набор всех возможных состояний среды называется [**пространством состояний**](https://en.wikipedia.org/wiki/State_space).

Пространство состояний обычно представляют в виде графа. Граф состоит из вершин, соединённых рёбрами. Вершины соответствуют состояниям среды. Рёбра обозначают действия агента. Выполнение любого действия меняет состояние среды. На графе это означает переход от одной вершины к другой. Эти вершины соединяет ребро, соответствующее выполненному действию.

Некоторые пространства состояний удобнее представлять в виде **ориентированного графа**. В таком графе рёбра имеют направления. Другими словами у каждого ребра есть начало и конец. Направленные рёбра называются **дугами**. Переход между вершинами графа возможен только по направлению дуги.

Иллюстрация 2-6 демонстрирует ориентированный граф с двумя состояниями среды для программы очистки диска из раздела 2.2.4.

{caption: "Иллюстрация 2-6. Пространство состояний для программы очистки диска", height: "50%", width: "100%"}
![Пространство состояний](images/ArtificialIntelligence/disc-cleanup-graph.png)

Любое пространство состояний определяют следующие параметры:

1. Начальное состояние среды.

2. Набор допустимых действий агента в каждом состоянии среды.

3. **Функция действия** (action function) — возвращает новое состояние среды, если агент совершит указанное действие в указанном состоянии среды.

В этом списке нет набора всех возможных состояний среды. Если этот набор известен, то пространство состояний представляют в виде **явного графа**. Граф такого типа помещается в память компьютера целиком. Он подходит для простых проблемных сред. Например, как на иллюстрации 2-6.

Если набор всех возможных состояний среды заранее неизвестен, пространство состояний представляют в виде **неявного графа**. Его также применяют, когда все возможные состояния среды не помещаются в память компьютера. В этом случае состояния выводятся в процессе поиска. Они временно сохраняются в памяти компьютера. Затем алгоритм удаляет эти состояния, если они не соответствуют решению задачи. Этот случай характерен для сложных проблемных сред.

Когда алгоритм поиска работает с неявным графом, говорят что он развёртывает узлы. **Развёртывание** означает применение функции действия к текущему состоянию среды. В результате формируются новые узлы состояний.

### 2.4.2 Решение задачи поиска

Допустим, что агент решает поставленную задачу с помощью поиска. Сначала он должен представить пространство состояний среды в виде графа. Затем ему нужно найти путь в графе. **Путём** называется такая последовательность рёбер, в которой конец каждого ребра является началом следующего.

**Решение задачи поиска** — это путь в графе, который ведёт из начального состояния среды к искомому.

Когда агент выполняет алгоритм поиска, он проверяет каждую посещённую вершину графа. Это действие называется **проверкой цели**. Суть проверки зависит от условий задачи. Возможны два варианта:

1. Цель определена как конкретное состояние среды. Тогда проверка цели сводится к сравнению текущего состояния среды и искомого. Если они совпали, проверка проходит успешно.

2. Цель определена как набор свойств, которым обладает искомое состояние среды. Тогда проверка цели заключается в проверке свойств текущего состояния среды. Если требуемые свойства есть, проверка проходит успешно.

Успешная проверка означает, что агент нашёл искомое состояние среды. В этому случае путь от начального состояния к искомому уже находится в памяти компьютера и известен агенту.

Как измерить показатели производительности агента, который решает задачу поиска? Для этого оценивают стоимость найденного им пути. **Стоимость пути** — это функция, которая даёт числовую оценку для указанного пути. Стоимость пути складывается из стоимостей составляющих его шагов. **Стоимость шага** — это числовая оценка действия агента, которое изменяет состояние среды.

Стоимость пути позволяет ввести понятие **оптимального решения задачи поиска**. Так называется решение с минимальной стоимостью.

### 2.4.3 Оценка алгоритмов поиска

Каждый алгоритм поиска можно оценить по четырём показателям:

* Временная сложность (time complexity)
* Пространственная сложность (space complexity)
* Полнота (completeness)
* Оптимальность (optimality)

Временная и пространственная сложность нам уже знакомы. **Временная сложность** — это зависимость количества шагов алгоритма от размера входных данных. **Пространственная сложность** — это зависимость количества используемой алгоритмом памяти от размера входных данных.

Временная и пространственная сложность выражаются в нотации ["О" большое](https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое). "O" большое определяет характер изменения функции, когда её аргумент стремится к бесконечности. Другими словами "O" большое определяет, как быстро растёт функция в зависимости от её входных данных.

Чтобы понять смысл нотации "О" большое, рассмотрим пример. Предположим, что число шагов алгоритма N зависит от размера входных данных n по такой формуле:

N = 2 * n^2^ + 5 * n + 10

В этом случае говорят, что временная сложность алгоритма равна O(n^2^). Почему? При оценке сложности в нотации "O" большое учитывают только слагаемое самого высокого порядка. В нашем примере это слагаемое равно 2 * n^2^. Константные множители не учитываются. То есть нам надо отбросить множитель 2. Тогда остаётся только n^2^. Таким образом мы получаем сложность алгоритма O(n^2^).

Другой пример. Допустим, что число шагов алгоритма вообще не зависит от размера входных данных. То есть число шагов — это некоторая константа. В этом случае сложность алгоритма равна O(1). При этом реальное число шагов в оценке сложности не учитывается.

Мы знаем сложности двух алгоритмов: O(n^2^) и O(1). Как их сравнить между собой? Удобнее всего сравнивать алгоритмы с помощью графиков функции оценки сложности. **Функция оценки сложности** — это и есть функция O. Графики отображают зависимость числа шагов алгоритма N от размера его входных данных n.

Иллюстрация 2-7 демонстрирует графики самых распространённых функций оценки сложности алгоритма.

{caption: "Иллюстрация 2-7. Функции оценки сложности алгоритма", height: "30%"}
![Функции оценки сложности](images/ArtificialIntelligence/computational-complexity.png)

Чем выше поднимается график функции от горизонтальной оси n, тем больше шагов выполняет алгоритм для обработки входных данных. Большее число шагов означает большую временную сложность.

Обратите внимание, что реальное число шагов алгоритма разное на разных участках функции оценки сложности. Есть участок около начала координат, где функция O(n^2^) находится ниже функции O(n). При больших n алгоритм со сложностью O(n^2^) выполняет на порядок больше шагов. Но при малых n он может быть эффективнее алгоритма со сложностью O(n). Поэтому при выборе алгоритма важно учитывать ожидаемый размер входных данных.

Пространственная сложность оценивается той же самой функцией O, что и временная. Только в случае пространственной сложности значение функции определяет объём используемой памяти. Другими словами, ось N на иллюстрации 2-7 покажет объём памяти, который использует алгоритм в процессе работы.

Рассмотрим оставшиеся два показателя оценки алгоритма: полнота и оптимальность.

Алгоритм поиска называется **полным**, если он гарантированно находит существующее решение в пространстве состояний за конечное число шагов. Если решение существует, но алгоритм его не находит в некоторых случаях, он называется **неполным**.

**Оптимальность** означает, что алгоритм находит решение с минимальной стоимостью среди всех возможных. Такое решение называется оптимальным.

### 2.4.4 Неинформированный поиск

К **неинформированному поиску** относятся алгоритмы, которые не используют дополнительную информацию о пространстве состояний. Их применяют основанные на цели агенты. Эти алгоритмы выполняют только два типа действий:

* Переход между вершинами графа.

* Проверка текущей вершины графа на соответствие искомому состоянию среды.

Алгоритмы неинформированного поиска различаются только порядком обхода вершин графа.

Чтобы разобраться в алгоритмах поиска, нам понадобится ещё два важных термина:

* **Дерево** — это частный случай графа, в котором нет циклов. Также между любой парой вершин такого графа есть минимум один путь.

* [**Цикл**](https://ru.wikipedia.org/wiki/Цикл_(теория_графов)) в теории графов — это путь, который начинается и заканчивается в одной и той же вершине.

Таблица 2-12 демонстрирует самые распространённые алгоритмы неинформированного поиска.

{caption: "Таблица 2-12. Алгоритмы неинформированного поиска", width: "100%"}
| Алгоритм | Время | Память | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Поиск в ширину (BFS) | O(b^d^) | O(b^d^) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Поиск по критерию стоимости (UCS) | ![](images/ArtificialIntelligence/ucs-complexity-formula.png) | ![](images/ArtificialIntelligence/ucs-complexity-formula.png) | Да, если стоимости всех шагов строго положительны | Да, если стоимости всех шагов строго положительны |
|  | | | | |
| Поиск в глубину (DFS) | O(b^m^) | O(b*m) | Нет | Нет |
|  | | | | |
| Поиск с ограничением глубины (DLS) | O(b^l^) | O(b*l) | Нет | Нет |
|  | | | | |
| Поиск в глубину с итеративным углублением (IDDFS) | O(b^d^) | O(b*d) | Да | Да, если стоимость всех шагов одинакова |
|  | | | | |
| Дву- | ![](images/ArtificialIntelligence/bidirectional-search-complexity-formula.png) | ![](images/ArtificialIntelligence/bidirectional-search-complexity-formula.png) | Да | Да, если |
| направленный поиск | | | | стоимость всех шагов одинакова |

Для определения временной и пространственной сложности в таблице используются следующие обозначения:

* b — **коэффициент ветвления**. Означает количество вершин, напрямую соединённых с каждой вершиной дерева. Если это количество отличается для разных вершин, вычисляется среднее значение.

* d — глубина (длина пути) самого поверхностного решения.

* C — стоимость пути оптимального решения.

* ε — стоимость каждого шага, который приближает алгоритм к целевой вершине.

* m — максимальная глубина дерева поиска.

* l — ограничение глубины поиска.

В общем случае алгоритмы неинформированного поиска работают и для явных, и для неявных деревьев. Мы рассмотрим только случай явных деревьев. Так будет проще проиллюстрировать принцип работы алгоритмов.

Теперь мы готовы рассмотреть алгоритмы неинформированного поиска.

#### 2.4.4.1 Поиск в ширину

Алгоритм **поиска в ширину** (breadth-first search, BFS) проходит по дереву уровень за уровнем, начиная с корневого узла.

Иллюстрация 2-8 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-8. Порядок обхода узлов при поиске в ширину", height: "25%"}
![Поиск в ширину](images/ArtificialIntelligence/bfs-tree.png)

Номера в узлах дерева указывают порядок их обхода. Поиск начинается с корневого узла 1. Затем проверяются узлы первого уровня с номерами 2 и 3. После этого алгоритм проходит по узлам последнего уровня с номерами 4, 5, 6, 7. Узлы на одном уровне посещаются в порядке слева направо.

Достоинства поиска в ширину:

* Гарантированно находит решение, если оно существует (полнота).

* Находит оптимальное решение, если стоимость всех шагов одинакова (оптимальность).

Недостатки поиска в ширину:

* Требует много памяти (пространственная сложность). В худшем случае надо сохранить все посещённые узлы дерева поиска.

* Если решением задачи является длинный путь, алгоритм ищет его очень долго (временная сложность).

#### 2.4.4.2 Поиск по критерию стоимости

**Поиск по критерию стоимости** (uniform-cost search, UCS) обходит дерево, в котором стоимость шагов различается. Алгоритм проходит узлы в порядке возрастания стоимости пути от корневого узла. Первым проверяется узел стоимость пути до которого минимальна.

Если стоимость всех шагов в дереве одинакова, поиск по критерию стоимости работает так же как поиск в ширину.

Иллюстрация 2-9 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-9. Порядок обхода узлов при поиске по критерию стоимости", height: "25%"}
![Поиск по критерию стоимости](images/ArtificialIntelligence/ucs-tree.png)

Номера в узлах дерева обозначают порядок их обхода. На иллюстрации около каждого ребра указана стоимость соответствующего шага.

Алгоритм начинает с корневого узла 1. Далее он проверяет стоимость шага до узла 2. Она равна 1. Это меньше стоимости шага до узла 3, которая равна 2. Поэтому алгоритм переходит в узел с номером 2.

Затем алгоритм вычисляет стоимость пути до узлов 5 и 4. Для узла 5 стоимость складывается из стоимости путей между узлами 1-2 и 2-5. В результате получается стоимость `1 + 3 = 4`. Для узла 4 стоимость равна `1 + 2 = 3`. В этом случае алгоритм выбирает проверку узла 3, потому что стоимость пути до него равна 2. Это меньше стоимости пути до узлов 5 и 4.

Далее алгоритм проверяет узел с минимальной стоимостью пути. Это узел под номером 4. Затем идут узлы:

* 5 — стоимость пути 4
* 6 — стоимость пути 5
* 7 — стоимость пути 6

Достоинства поиска по критерию стоимости:

* Находит оптимальное решение, потому что в первую очередь проходит пути с минимальной стоимостью (оптимальность).

Недостатки поиска по критерию стоимости:

* В худшем случае временная и пространственная сложность намного больше чем у поиска в ширину.

Причина высокой сложности алгоритма в том, что он сначала проверяет пути из шагов с малой стоимостью. Худший случай — решение задачи представляет собой путь из шагов с большой стоимостью. Тогда алгоритму понадобится много времени и памяти, чтобы его найти.

#### 2.4.4.3 Поиск в глубину

**Поиск в глубину** (depth-first search, DFS) начинает с корневого узла и проходит каждый путь слева направо до самого дальнего узла. После этого алгоритм возвращается к ближайшему узлу, у которого остались непроверенные рёбра, и снова проходит до самого дальнего узла. Алгоритм повторяет эти шаги, пока не пройдёт всё дерево.

Иллюстрация 2-10 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-10. Порядок обхода узлов при поиске в глубину", height: "25%"}
![Поиск в глубину](images/ArtificialIntelligence/dfs-tree.png)

Номера в узлах дерева указывают порядок их обхода.

Поиск начинается с корневого узла 1. Затем алгоритм проходит до конца по левой ветви дерева через узлы 2 и 3. После этого он возвращается на шаг назад к узлу 2. У него осталась непроверенная ветвь до узла 4. Алгоритм проверяет эту ветвь. После этого он возвращается в корневой узел 1 и проходит по правой части дерева в аналогичном порядке.

Достоинства поиска в глубину:

* Требует очень мало памяти (пространственная сложность). Алгоритм хранит только набор вершин по пути от корневого узла до текущего.

* Находит решение быстрее чем поиск в ширину, если начинается в правильном направлении (временная сложность).

Недостатки поиска в глубину:

* Если в дереве есть циклы, алгоритм может зациклиться и не найти решения (полнота).

* Найденное решение может быть неоптимальным (оптимальность).

#### 2.4.4.4 Поиск с ограничением глубины

**Поиск с ограничением глубины** (depth-limited search, DLS) — это вариант поиска в глубину с ограничением числа шагов в каждом направлении. Алгоритм решает проблему циклов, с которыми не справляется поиск в глубину.

Иллюстрация 2-11 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-11. Порядок обхода узлов при поиске с ограничением глубины"}
![Поиск с ограничением глубины](images/ArtificialIntelligence/dls-tree.png)

Номера в узлах дерева указывают порядок их обхода. Иллюстрация демонстрирует обход дерева с ограничением глубины прохода, равном 3.

Алгоритм начинает с корневого узла 1 на глубине 0. Он идёт по левой ветви дерева через узлы 2 и 3. На узле 3 алгоритм останавливается, потому что этот узел находится на глубине 2. Это предел поиска для ограничения глубины, равном 3.

После этого алгоритм проходит узлы 4, 5, 6 и 7 в том же порядке, что и поиск в глубину. На узле 7 алгоритм снова останавливается из-за ограничения глубины.

Достоинства поиска с ограничением глубины:

* Требует мало памяти, как и поиск в глубину (пространственная сложность).

Недостатки поиска с ограничением глубины:

* Не находит решение, если путь до него длиннее, чем ограничение глубины (полнота).

* Найденное решение может быть неоптимальным (оптимальность).

#### 2.4.4.5 Поиск в глубину с итеративным углублением

**Поиск в глубину с итеративным углублением** (iterative-deepening depth-first search, IDDFS) — это вариант поиска с ограничением глубины. Алгоритм пошагово увеличивает ограничение глубины до тех пор, пока не находит решение.

Поиск в глубину с итеративным углублением — это компромисс между поиском в ширину и поиском в глубину. Алгоритм имеет низкую пространственную сложность, но при этом полный и оптимальный.

Иллюстрация 2-12 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-12. Порядок обхода узлов при поиске в глубину с итеративным углублением"}
![Поиск в глубину с итеративным углублением](images/ArtificialIntelligence/iddfs-tree.png)

Поиск выполняется как последовательность итераций. Таблица 2-13 демонстрирует итерации для дерева поиска на иллюстрации 2-12.

{caption: "Таблица 2-13. Итерации поиска", width: "80%"}
| Номер итерации | Порядок посещения узлов |
| --- | --- |
| 1 | A |
|  | |
| 2 | A, B, C |
|  | |
| 3 | A, B, D, E, C, F, G |
|  | |
| 4 | A, B, D, H, I, E, C, F, G, J, K |

Достоинства поиска в глубину с итеративным углублением:

* Низкая пространственная сложность.

* Низкая временная сложность.

* Гарантированно находит решение, если оно есть (полнота).

* Найденное решение будет оптимальным (оптимальность).

Недостатки поиска в глубину с итеративным углублением:

* На каждой итерации алгоритм повторяет свои шаги из прошлой итерации.

Поиск в глубину с итеративным углублением считается лучшим алгоритмом неинформированного поиска при следующих условиях:

* Пространство поиска велико.

* Глубина решения заранее неизвестна.

#### 2.4.4.6 Двунаправленный поиск

**Двунаправленный поиск** (bidirectional search) — это одновременный поиск в двух направлениях: из начального и из целевого узла. Поиск из начального узла идёт в прямом направлении, а из целевого узла — в обратном. Когда эти процессы встречаются, алгоритм прекращается. Поиск в каждом направлении находит только часть пути. Вместе эти две части составляют конечное решение задачи.

Двунаправленный поиск представляет собой два алгоритма поиска, которые выполняются параллельно. Этими алгоритмами могут быть любые виды неинформированного поиска: в ширину, в глубину, в глубину с ограничением и т.д. Чаще всего используют поиск в ширину. Он гарантирует полноту и оптимальность. Другие алгоритмы могут быть неполными или неоптимальными.

Главное отличие двунаправленного поиска от других алгоритмов в том, что целевой узел дерева должен быть известен заранее.

Иллюстрация 2-13 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-13. Порядок обхода узлов при двунаправленном поиске"}
![Двунаправленный поиск](images/ArtificialIntelligence/bidirectional-search-tree.png)

Поиск начинается в узле D. Он отмечен зелёным цветом. Целевой узел J отмечен оранжевым.

Во время двунаправленного поиска чередуются итерации прямого и обратного поиска. Допустим, что в обоих направлениях выполняется поиск в ширину. Тогда таблица 2-14 демонстрирует все итерации алгоритма.

{caption: "Таблица 2-14. Итерации двунаправленного поиска", width: "80%"}
| Номер итерации | Направление поиска | Порядок посещения узлов |
| --- | --- | --- |
| 1 | Прямое | D |
|  | |
| 2 | Обратное | J |
|  | |
| 3 | Прямое | H, I, B |
|  | |
| 4 | Обратное | F, G |
|  | |
| 5 | Прямое | E, A |
|  | |
| 6 | Обратное | E, C, K |

Алгоритм останавливается на 6-й итерации. На этой итерации прямой и обратный поиск встречаются в узле E. Прямой поиск нашел такой путь от D до E: D -> B -> E. Обратный поиск нашёл такой путь от J до E: J -> F -> E. Комбинация этих двух путей будет конечным решением: D -> B -> E -> F -> J. Этот путь отмечен чёрной стрелкой на иллюстрации 2-13.

Достоинства двунаправленного поиска:

* Низкая пространственная сложность.

* Низкая временная сложность.

Недостатки двунаправленного поиска:

* Сложно реализовать в виде программы.

* Целевой узел должен быть известен заранее.

### 2.4.5 Информированный поиск

Мы рассмотрели алгоритмы неинформированного поиска. Они очень просты. Но к сожалению, все эти алгоритмы неэффективны для большинства реальных задач.

Допустим, что программа агента построена на неинформированном поиске. Агент должен действовать в сложной среде. В этом случае он не сможет решить поставленную задачу. Проблема в том, что у сложной среды много возможных состояний. Это означает, что пространство состояний среды велико. Следовательно, соответствующее ему дерево тоже большое. Чтобы пройти по такому дереву, любому алгоритму неинформированного поиска нужного слишком много времени и компьютерной памяти.

Проблему обработки больших деревьев решают алгоритмы **информированного поиска**. Их применяют агенты, основанные на полезности.

Чтобы применить любой алгоритм информированного поиска, нужна дополнительная информация о поставленной задаче. Например:

* Как далеко находится целевой узел от текущего?
* В каком направлении находится целевой узел?
* Какова стоимость пути до целевого узла?

Благодаря таким подсказкам, агент делает выводы о некоторых ветвях дерева без их проверки. Например, агент решает что конкретные ветви точно не приведут к решению задачи. Тогда он просто исключает их из рассмотрения.

Дополнительная информация о задаче представляется в виде **эвристической функции** (heuristics function). Функция принимает на вход текущий узел и оценивает, как далеко находится целевой узел. Эта оценка может выражаться по-разному. Обычно это путь с минимальной стоимостью от текущего узла до целевого.

Рассмотрим пример. Предположим, что агент ищет кратчайший путь по улицам города от точки А до точки Б. В этом случае эвристическая функция даст длину по прямой линии от А до Б. На практике этим путём воспользоваться нельзя. Агент должен двигаться по улицам и не может проходить сквозь дома. Из-за этого реальный путь от А до Б окажется больше, чем оценивает эвристическая функция. Тем не менее эта функция даёт подсказку, которая значительно сокращает время поиска правильного пути.

Эвристическая функция называется **допустимой** (admissible), если её значение для любого узла меньше или равно фактической минимальной стоимости пути от этого узла до цели. Другими словами, допустимая эвристическая функция никогда не переоценивает реальную стоимость решения. Только допустимая эвристическая функция гарантирует оптимальный результат поиск.

Таблица 2-15 демонстрирует алгоритмы информированного поиска, которые чаще всего применяются на практике.

{caption: "Таблица 2-15. Алгоритмы информированного поиска", width: "100%"}
| Алгоритм | Время | Память | Полнота | Оптимальность |
| --- | --- | --- | --- | --- |
| Жадный поиск по первому наилучшему совпадению (GBFS) | O(b^m^) | O(b^m^) | Нет | Нет |
|  | | | | |
| Поиск A\* | O(b^d^) | O(b^d^) | Да, если b конечное | Да, если эвристическая функция допустима |

Для определения временной и пространственной сложности в таблице применяются следующие обозначения:

* b — коэффициент ветвления.

* d — глубина (длина пути) самого поверхностного решения.

* m — максимальная глубина дерева поиска.

Теперь мы готовы рассмотреть алгоритмы информированного поиска.

#### 2.4.5.1 Жадный поиск по первому наилучшему совпадению

Мы рассмотрим два алгоритма, которые относятся к типу **поиск по первому наилучшему совпадению** (best-first search, BFS). Самый простой вариант такого алгоритма называется **жадный поиск по первому наилучшему совпадению** (greedy best-first search, GBFS). На каждом шаге он переходит в узел дерева, который находится ближе остальных к целевому узлу. Расстояние от текущего до целевого узла оценивает эвристическая функция. Алгоритм полагается только на неё и игнорирует стоимость шагов.

Иллюстрация 2-14 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-14. Порядок обхода узлов при жадном поиске по первому наилучшему совпадению"}
![Жадный поиск по первому наилучшему совпадению](images/ArtificialIntelligence/gbfs-tree.png)

На иллюстрации около каждого ребра указана стоимость соответствующего шага. Алгоритм поиска не использует эти значения. Они даны только для сравнения с результатами эвристической функцией.

Поиск начинается в корневом узле A. Алгоритм должен прийти в целевой узел H. Эвристическая функция определяет расстояние по прямой от каждого узла до H.

Чтобы понять разницу оценки эвристической функции от стоимости пути, рассмотрим пример. Пусть функция оценивает расстояние по прямой от узла A до H как 45. Между этими узлами есть два пути:

* A -> C -> F -> H

* A -> C -> G -> H

Стоимость первого пути равна:
{line-numbers: false, format: text}
```
20 + 40 + 10 = 70
```

Стоимость второго пути равна:
{line-numbers: false, format: text}
```
20 + 10 + 20 = 50
```

Оценка эвристической функции меньше стоимости обоих возможных путей. Это не ошибка. Именно такая эвристическая функция, которая не переоценивает стоимость решения, является допустимой.

Таблица 2-16 демонстрирует значения эвристической функции для каждого узла дерева.

{caption: "Таблица 2-16. Значения эвристической функции", width: "50%"}
| Узел | Значение функции |
| --- | --- |
| A | 45 |
| B | 35 |
| C | 25 |
| D | 60 |
| E | 25 |
| F | 10 |
| G | 15 |
| H | 0 |
| I | 40 |

Жадный поиск по первому наилучшему совпадению ориентируется только на значения эвристической функции из таблицы 2-16. Поэтому алгоритм найдёт следующий путь:

A -> C -> F -> H

Он отмечен чёрной стрелкой на иллюстрации 2-14.

На первом шаге алгоритм выбирает между узлами B и C. Согласно эвристической функции, узел C находится ближе к целевому узлу, чем B. Функция оценивает расстояние от C до H как 25, а от B до H — как 35.

Далее алгоритм выбирает между узлами F и G. Эвристическая функция оценивает расстояние от F до H как 10. Расстояние от G до H равно 15, согласно таблице 2-16. Это значит, что узел F ближе к узлу H. Поэтому алгоритм выберет путь через узел F.

Для нашего примера алгоритм GBFS нашёл путь A -> C -> F -> H. Это неоптимальное решение. Его стоимость равна 70. Оптимальное решение — это путь A -> C -> G -> H со стоимостью 50. Алгоритм выбрал неоптимальный путь, потому что не учёл реальное расстояние между узлами C и F. Оно оказалось значительно больше, чем расстояние от C до G.

Достоинства жадного поиска по первому наилучшему совпадению:

* В среднем алгоритм более эффективен, чем поиск в ширину и поиск в глубину (временная и пространственная сложность).

Недостатки жадного поиска по первому наилучшему совпадению:

* Если в дереве есть циклы, алгоритм может зациклиться и не найти решения (полнота).

* Найденное решение может быть неоптимальным (оптимальность).

* Эффективность поиска зависит от качества эвристической функции.

#### 2.4.5.2 Поиск A\*

Другой вариант поиска по первому наилучшему совпадению называется поиск А\*. На каждом шаге он оценивает узлы для перехода по двум факторам:

1. Значение эвристической функции.
2. Стоимость пути от начального узла.

Алгоритм перейдёт в тот узел, для которого сумма этих факторов окажется максимальной.

Выразим оценку узла для перехода более формально на языке математики. Чтобы найти лучший следующий узел `n` для перехода, поиск A\* использует **функцию оценки** (evaluation function) `f(n)`. Обозначим эвристическую функцию как `h(n)`. Стоимость наименее дорогостоящего пути от начального узла до узла `n` представим как функцию `g(n)`. Тогда функция оценки `f(n)` будет равна следующей сумме:
{line-numbers: false, format: text}
```
f(n) = g(n) + h(n)
```

Эта формула говорит о том, что вклад эвристической функции и стоимости пути в функцию оценки одинаков.

Иллюстрация 2-15 демонстрирует порядок обхода узлов дерева.

{caption: "Иллюстрация 2-15. Порядок обхода узлов при поиске А\*"}
![Поиск А\*](images/ArtificialIntelligence/a-star-tree.png)

Пусть значения эвристической функции для каждого узла дерева будут такими же, как в таблице 2-16. Тогда алгоритм поиска выполнит шаги, приведённые в таблице 2-17.

{caption: "Таблица 2-17. Шаги поиска A\*", width: "80%"}
| Шаг | Узел | g(n) | h(n) | f(n) |
| --- | --- | --- | --- | --- |
| 1 | A | 0 | 45 | 45 |
| 2 | C | 20 | 25 | 45 |
| 3 | G | 30 | 15 | 45 |
| 4 | H | 50 | 0 | 50 |

Алгоритм начинает свою работу с корневого узла A. Там он находится на первом шаге.

На втором шаге алгоритм A\* выбирает между узлами B и C. Для узла B значение функции оценки `f(B)` рассчитывается так:
{line-numbers: false, format: text}
```
f(B) = g(B) + h(B) = 20 + 35 = 55
```

Для узла C значение `f(C)` рассчитывается так:
{line-numbers: false, format: text}
```
f(C) = g(C) + h(C) = 20 + 25 = 45
```

Значение функции оценки для узла С меньше, чем для B, т.е. `f(C) < f(B)`. Поэтому алгоритм выберет узел C на втором шаге.

На третьем шаге алгоритм выбирает между узлами F и G. Вот расчёт значения функции оценки `f(F)` для узла F:
{line-numbers: false, format: text}
```
f(F) = g(F) + h(F) = 60 + 10 = 70
```

Для узла G значение функции будет таким:
{line-numbers: false, format: text}
```
f(G) = g(G) + h(G) = 30 + 15 = 45
```

Мы получили `f(G) < f(F)`. Поэтому для перехода алгоритм выберет узел G.

На четвёртом шаге алгоритм выбирает между узлами H и I. Расчёт значений функции оценки для них выглядит так:
{line-numbers: false, format: text}
```
f(H) = g(H) + h(H) = 50 + 0 = 50
f(I) = g(I) + h(I) = 60 + 40 = 100
```

Алгоритм перейдёт в целевой узел H с `f(H) = 50`, а не в узел I с `f(I) = 100`.

Таким образом поиск A\* найдёт следующее решение:

A -> C -> G -> H

Этот путь отмечен чёрной стрелкой на иллюстрации 2-15.

Достоинства поиска A\*:

* Гарантированно находит решение, если оно есть (полнота).

* Найденное решение для дерева будет оптимальным, если эвристическая функция допустима (оптимальность).

Недостатки поиска A\*:

* Не способен решать некоторые сложные задачи из-за высокого потребления памяти (пространственная сложность).

* Высокая временная сложность.

Поиск A\* можно оптимизировать. Если эвристическая функция допустима, алгоритм находит оптимальное решение. Но при этом он может посетить некоторые узлы более одного раза. Эту проблему можно решить, если наложить дополнительное требование на эвристическую функцию.

Эвристическая функция называется **преемственной** или монотонной, если для неё выполняется следующее неравенство:
{line-numbers: false, format: text}
```
h(A) ≤ g(A,B) + h(B)
```

В нём используются следующие обозначения:

* h(n) — эвристическая функция.
* g(A,B) — функция стоимости пути между узлами.
* A — узел дерева.
* B — дочерний узел по отношению к A.

Преемственная эвристическая функция гарантирует, что алгоритм A\* не посетит какой-либо узел более одного раза. Это уменьшит число переходов между узлами и ускорит работу алгоритма.

#### 2.4.5.3. Современные алгоритмы

A\* — один из лучших алгоритмов информированного поиска. Он обладает полнотой и оптимальностью. Благодаря этим свойствам, поиск A\* хорошо справляется с небольшими задачами. Но он использует слишком много памяти. Поэтому со сложными задачами у алгоритма возникают проблемы.

На практике чаще применяют модификации поиска A\*. Эти модификации используют меньше памяти за счёт увеличения времени работы. Вот некоторые из них:

* [**Поиск A\* с итеративным углублением**](https://en.wikipedia.org/wiki/Iterative_deepening_A*) (iterative deepening A\*, IDA\*) напоминает поиск в глубину с итеративным углублением (IDDFS). В IDDFS глубина поиска ограничена стоимостью пути от корневого узла до узла `n`. Эту стоимость рассчитывает функция `g(n)`. В IDA\* глубина поиска ограничена функцией оценки `f(n) = g(n) + h(n)`. Это та же самая функция `f(n)`, которая используется в обычном поиске A\*.

* **Поиск A\* с ограничением памяти** (memory bounded A\*, MA\*). Идея алгоритма в том, чтобы периодически удалять информацию о малоперспективных узлах. Эти узлы имеют максимальное значение функции оценки `f(n)`. В результате освобождается память для добавления новых узлов. Исключение узлов происходит, когда алгоритм превышает объем отведённой ему памяти.

* [**Упрощённый поиск A\* с ограничением памяти**](https://en.wikipedia.org/wiki/SMA*) (simplified memory bounded A\*, SMA\*) работает аналогично поиску MA\*. Алгоритм проходит по наиболее перспективным узлам с минимальным значением функции оценки `f(n)`. Когда доступная память исчерпана, SMA\* удаляет информацию о худшем проверенном узле с максимальным значением `f(n)`. После удаления нескольких худших узлов алгоритм запоминает значение `f(n)` лучшего из них в их общем родительском узле. Благодаря этому, SMA\* может вернуться к удалённым узлам, если другие направления поиска станут менее перспективными.

Кроме модификаций поиска A\* применяется также **рекурсивный поиск по первому наилучшему совпадению** (recursive best-first search, RBFS). Это одна из разновидностей алгоритма BFS (best-first search), которая решает проблему большого потребления памяти. Направление поиска задаёт функция оценки `f(n)`. Алгоритм RBFS запоминает значение `f(A)` для лучшего узла `A`, известного на данный момент. Далее от него выполняется поиск в глубину DFS. Если значение функции оценки `f(B)` для текущего узла `B` оказалась больше сохранённого `f(A)`, алгоритм останавливается и возвращается к лучшему узлу A. От него начинается поиск DFS по другому самому перспективному направлению.

Алгоритмы IDA\* и RBFS хорошо справляются с обходом деревьев. С графами они работают хуже. Проблемы возникают из-за циклов и многократных проверок одних и тех же узлов.

Ещё один недостаток IDA\* и RBFS — переключение между альтернативными направлениями поиска. Слишком частые переключения увеличивают время поиска. Для сложных задач это время может оказаться неприемлемо большим.

Алгоритм SMA\* решает проблему частого переключения между направлениями поиска. Для этого он использует больше памяти чем IDA\* и RBFS, но меньше чем поиск A\*. SMA\* предлагает хороший компромисс между пространственной и временной сложностью.

{pagebreak}
