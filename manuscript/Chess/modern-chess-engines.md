## 3.5 Современные шахматные движки

В конце 1990-х годов шахматные программы для ПК достигли уровня игры специализированных суперкомпьютеров наподобие Deep Blue. В результате новые разработки представляли собой именно программы. Компании и энтузиасты перестали проектировать специализированное шахматное аппаратное обеспечение, потому что это было слишком дорого.

Как настольные компьютеры достигли уровня игры суперкомпьютеров? Во-первых, значительно увеличилась мощность ПК. Большая часть таких компьютеров имела [IBM-совместимую](https://ru.wikipedia.org/wiki/IBM-PC-совместимый_компьютер) архитектуру и работала на процессорах от Intel. В 1993 году вышел процессор [Intel Pentium](https://ru.wikipedia.org/wiki/X86#Процессоры_Intel). К концу 1990-х его конструкция была усовершенствована. Так доступные ПК получили мощный и недорогой процессор. Его производительности хватало шахматным программам, чтобы просчитывать ходы на глубину, достаточную для качественной игры.

Вторая причина — это совершенствование самих шахматных программ. Основные улучшения касались оценочной функции. Благодаря им, программы качественнее оценивали позиции и выбирали более сильные ходы. Так же появились новые эвристики поиска. Это позволяло программам отбрасывать больше бесперспективных ходов и глубже просчитывать перспективные.

### 3.5.1 Шахматные движки

В 1993 году разработчик шахматных программ [Мартин Хирш](https://www.chessprogramming.org/Marty_Hirsch) ввёл термин [**шахматный движок**](https://ru.wikipedia.org/wiki/Шахматный_движок). Хирш сделал это, чтобы отличать коммерческие шахматные игры от инструментов для профессиональных шахматистов.

Шахматные игры для ПК начали появляться в конце 1980-х годов. Примеры таких игр: [Chessmaster](https://en.wikipedia.org/wiki/Chessmaster) и [Battle Chess](https://en.wikipedia.org/wiki/Battle_Chess). Эти программы имеют красивый графический интерфейс по меркам своего времени. Например, в Battle Chess после каждого хода фигуры оживают и перемещаются на указанное поле доски. Если это поле уже занимает фигура противника, то происходит сражение. Шахматные игры предназначались для широкой аудитории. Они продавались по низкой цене и позиционировались как развлечения. Уровень их игры был достаточно низким: около 1600 пунктов Эло.

В отличие от игр, шахматные движки не имеют графического интерфейса. Они предназначены для анализа и поиска наилучшего хода в заданной на доске позиций. Пользователь работает с такой программой через интерфейс командной строки. Шахматные движки изначально позиционировались как инструменты для профессионалов. С их помощью шахматисты анализировали партии и готовились к турнирам. Соответственно, цена на шахматные движки высока, как и на любой профессиональный инструмент. Их уровень игры намного выше, чем у шахматных игр.

Интерфейс командной строки был неудобен для большинства пользователей. Поэтому в начале 1990-х стали появляться программы для визуализации работы шахматного движка. Большинство современных программ визуализации коммерческие и достаточно дорогие. При этом наиболее сильные шахматные движки сегодня бесплатны и распространяются с [открытым исходным кодом](https://ru.wikipedia.org/wiki/Свободное_и_открытое_программное_обеспечение).

Все шахматные движки состоят из двух основных частей:

1. Механизм поиска.
2. Статическая оценка позиции.

Рассмотрим как реализованы эти части в самых сильных шахматных движках.

### 3.5.2 Stockfish

Stockfish считается сильнейшим современным шахматным движком. Он занимает первые строчки в рейтингах [Chess Engines Grand Tournament](http://www.cegt.net/40_40 Rating List/40_40 BestVersion/rangliste.html) (CEGT) и [Computer Chess Rating Lists](https://ccrl.chessdom.com/ccrl/4040/) (CCRL) за 2022 год.

Stockfish вырос из проекта шахматного движка Glaurung, который разработал Торд Ромстад. Первая версия Glaurung вышла в 2004 году. Это была программа для ПК с открытым исходным кодом. Разработчики портировали её более поздние версии на мобильные телефоны и планшеты.

В ноябре 2008 году Марко Костальба решил сделать [**форк**](https://ru.wikipedia.org/wiki/Форк) (от английского fork — вилка) кода Glaurung. Форком называется использование кодовой базы одного проекта в качестве старта для другого. Костальба назвал свой проект Stockfish. Первая версия этого движка вышла в ноябре 2008 года.

В течение 2008 года Glaurung и Stockfish развивались параллельно. Оба проекта распространялись с открытым исходным кодом. Поэтому их команды свободно обменивались идеями и усовершенствованиями алгоритмов.

В декабре 2008 года Ромстад выпустил последнюю версию Glaurung 2.2. Он прекратил поддержку своего проекта и присоединился к команде Stockfish. Stockfish на тот момент превзошёл Glaurung по уровню игры. Возможно, это стало причиной решения Ромстада.

В 2011 году Торд Ромстад вышел из проекта Stockfish. Он занялся разработкой шахматной программы для iOS. В 2014 году проект покинул Марко Костальба. Современная версия Stockfish развивается группой энтузиастов в которой около 20 человек.

#### 3.5.2.1 Система тестирования Fishtest

Stockfish достиг высокого уровня игры во многом благодаря специальной системе распределённых тестов под названием Fishtest. Её разработал Гэри Линскотт в 2013 году. Система Fishtest позволяет добровольцам выделять процессорное время своих компьютеров на тестирование шахматного движка. Суть тестирования заключается в многократных играх модифицированной версии Stockfish против последней стабильной версии. Только статистически значимые улучшения принимаются сообществом разработчиков и попадают в следующую стабильную версию.

Эффективность Fishtest можно оценить по первым 12 месяцам его использования. За это время уровень игры Stockfish вырос на 120 пунктов Эло. В результате этого прогресса Stockfish поднялся до лидирующих позиций во всех основных рейтингах шахматных движков.

К декабрю 2022 года благодаря системе Fishtest разные версии Stockfish сыграли друг с другом около 5 миллиардов партий. На это ушло более 8650 лет процессорного времени.

#### 3.5.2.2 Механизм поиска в Stockfish

Поиск в Stockfish основан на следующих алгоритмах:

* Магические битборды
* Минимаксный поиск
* Эвристика альфа-бета отсечения
* Оптимизация move ordering

Рассмотрим их подробнее.

##### 3.5.2.2.1 Магические битборды

Чтобы начать поиск, шахматному движку нужно получить список возможных ходов, допустимых правилами. Решение этой задачи зависит от формата, в котором движок хранит состояние шахматной доски. Наиболее эффективным форматом для современных компьютеров считаются [**битборды**](https://hmn.wiki/ru/Bitboard). Разберёмся, как они работают.

Впервые на практике битборды использовал Кристофер Стрейч в своей программе для игры в шашки в 1952 году. Битборды в шахматах впервые применили разработчики советской шахматной программы [Каисса](https://ru.wikipedia.org/wiki/Каисса_(программа)) в конце 1960-х годов.

Идея битбордов в том, чтобы оптимизировать обработку состояния доски. Битборд представляет собой одно 64-разрядное число. Каждый бит этого числа соответствует одному из 64-х полей шахматной доски. Если бит равен единице, поле занято фигурой. Если бит равен нулю, то поле свободно.

Чтобы сохранить состояние всех фигур на шахматной доске, нужно минимум восемь битбордов. По одному на каждый из шести типов фигур: пешки, ладьи, кони, слоны, короли, ферзи. Два битборда нужны для определения цвета фигуры на каждом поле: черный или белый. На практике обычно применяется набор из 12 битбордов: по одному для каждого типа фигур, каждого цвета. Такой подход удобнее для расчётов возможных ходов.

Рассмотрим пример. Битборд для начальной позиции белых пешек наглядно можно представить так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
```

На самом деле, в памяти компьютера этот битборд хранится как 64-разрядное число в двоичной системе счисления так:
{line-numbers: false, format: text}
```
0000000000000000000000000000000000000000000000001111111100000000
```

Аналогично, битборд для двух чёрных коней в начальной позиции выглядит так:
{line-numbers: false, format: text}
```
  0 1 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Ему соответствует такое 64-разрядное число в памяти:
{line-numbers: false, format: text}
```
0100001000000000000000000000000000000000000000000000000000000000
```

Какие преимущества дают битборды? Современные процессоры оперируют 64-разрядными регистрами. Это означает, что один битборд целиком помещается в один регистр. Также любую проверку или действие над числом процессор выполняет за одну операцию. Одна операция длится один [**такт**](https://hardwareguide.ru/процессор/частота-процессора/). Тактовая частота современных процессоров достигает 4 гигагерц. Это соответствует 4*10^6^ операций в секунду. Благодаря битбордам, современные шахматные программы достигают очень высокой производительности.

Битборды хранят состояния доски. Но сами по себе они не дают все доступные ходы для каждой фигуры. Эти ходы можно посчитать с помощью битовых операций. Для пешек, коней и королей их легко рассчитать с помощью битовых сдвигов.

Вот расчёт ходов для белых пешек в начальной позиции. Все пешки могут пойти на одно поле вперёд. В этом случае битовая маска допустимых ходов выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Кроме этого каждая пешка из начальной позиции может пойти на два поля вперёд. Это даст такую битовую маску:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Если мы наложим две битовые маски с допустимыми ходами друг на друга, то получим такой битборд:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Этот битборд возможных ходов (B) можно получить из битборда начальной позиции (A) с помощью операций битового сдвига влево и побитового OR. Формула для расчёта выглядит так:
{line-numbers: false, format: text}
```
B = (A << 8) | (A << 16)
```

Если некоторые пешки двигались в ходе партии, мы можем получить, например, такой битборд (C) c их позицией:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 1 1 0 0 0
  0 0 0 0 0 0 1 0
  1 1 1 0 0 1 0 1
  0 0 0 0 0 0 0 0
```

В этом случае наша формула для расчёта возможных ходов не подходит. Нам нужно отличать пешки, которые ещё могут сходить на два поля вперед. Для этого наложим маску начальной позиции белых пешек на битборд C с помощью побитого AND. Эта маска представляет собой битборд A начальных позиций пешек. Так мы получим универсальную формулу расчёта возможных ходов для белых пешек на любой стадии партии:
{line-numbers: false, format: text}
```
B = (C << 8) | ((C & A) << 16)
```

Аналогично выводятся формулы расчёта возможных ходов для чёрных пешек, а также коней и королей обоих цветов.

Найти ходы [**скользящих фигур**](https://www.chessprogramming.org/Sliding_Pieces) (sliding pieces) сложнее. Скользящими фигурами называют слона, ладью и ферзя. Они могут ходить по диагоналям, вертикалям и горизонталям через всю доску, если их не блокируют другие фигуры. Это означает, что битовых сдвигов будет недостаточно. Требуются более сложные вычисления.

Для расчёта возможных ходов скользящих фигур нам нужно знать:

1. Тип фигуры.
2. Поле, где она находится.
3. Битборд с расположением фигур, которые её блокируют.

Рассмотрим алгоритм расчёта возможных ходов. Для примера найдём возможные ходы ладьи на поле e4 на запад. Для этого нам надо выполнить следующие шаги:

1. Рассчитать **луч** в каждом из восьми направлений для поля, которое занимает фигура. Луч представляет собой все поля по горизонтали, вертикали или диагонали от заданной клетки. Например, вот луч на запад из клетки e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Остальные семь направлений это: северо-запад, север, северо-восток, восток, юго-восток, юг, юго-запад.

2. Выбрать, какие лучи подходят для данного типа фигуры. Например, для ладьи нужны только лучи на север, восток, юг и запад.

3. Использовать лучи как маски для битборда блокирующих фигур. Так мы получаем все фигуры, которые стоят на пути данной фигуры на каждом направлении.

4. Найти первую блокирующую фигуру на каждом направлении. Для направлений на запад и юг нужно найти **наибольший индекс ненулевого бита** (most significant set bit). Эта операция называется [**bit scan forward**](https://www.chessprogramming.org/BitScan#Bitscan_forward). Для направлений на восток и север мы ищем **наименьший индекс не нулевого бита** (least significant set bit). Эта операция называется [**bit scan reverse**](https://www.chessprogramming.org/BitScan#Bitscan_reverse).

5. Рассчитать лучи от найденной первой блокирующей фигуры. Для нашего примера нам нужен только луч на запад. Используем его как маску для луча от ладьи на e4 на запад.

Так мы получили все клетки, которые ладья e4 атакует на западе. Следуя тому же алгоритму, мы находим клетки атаки ладьи для остальных сторон.

Клетки, которые атакует слон, находятся аналогично ладье. В случае ферзя нам просто надо скомбинировать результаты алгоритма поиска клеток для ладьи и слона.

Мы рассмотрели один из алгоритмов для расчёта ходов скользящих фигур. Он основан на bit scan операциях. Существуют и другие алгоритмы, например [**вращаемые битборды**](https://habr.com/ru/post/155045/).

Для расчёта ходов фигур передовые шахматные движки используют подход под названием [**магические битборды**](https://habr.com/ru/post/272815/). На современных процессорах он даёт наилучшую производительность.

Идея магических битбордов в том, чтобы однократно посчитать все доступные ходы для всех фигур с учётом всех возможных позиций блокирующих фигур. Для этого расчёта можно использовать алгоритм на операциях bit scan или любой другой. Результат сохраняется в память. Далее в процессе работы движок обращается к памяти и читает уже рассчитанные доступные ходы, которые соответствуют текущей позиции на доске. Такая техника однократного расчёта и сохранения результата в память для повторного использования называется **кешированием**.

Результат расчёта ходов фигур хранится в наборе **двумерных массивов**. Каждый массив, соответствует определённому типу фигур. Первый индекс массива — это поле, которое занимает фигура. Второй индекс — битборд с блокирующими фигурами.

Проблема с кешированием возможных ходов в том, что число всех возможных битбордов с блокирующими фигурами огромно. Оно равно 2^64^. Подсчитаем, сколько памяти нужно для хранения массива возможных ходов для фигур одного типа (например, ладей). Один битборд занимает 64 бита. Число возможных битбордов блокирующих фигур 2^64^. Число полей, которые может занимать атакующая фигура 64. Получаем массив размером 64*2^64^*64=2^76^ бит. Это примерно равно 10^10^ терабайт. На современных компьютерах столько памяти нет.

Подход магических битбордов решает задачу экономии памяти. Его идея в том, чтобы использовать **хэш-функцию**, которая вместо 64-битного битборда блокирующих фигур даст меньшее число.

Требования к хэш-функции такие:

1. Она должна работать быстрее, чем расчёт ходов скользящих фигур.

2. Для каждого битборда блокирующих фигур она даёт уникальное число на выходе. В противном случае возникнут [**коллизии**](https://ru.wikipedia.org/wiki/Коллизия_хеш-функции).

Рассмотрим пример. Предположим, что у нас есть такой битборд блокирующих фигур для ладьи на e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 1 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

В этом случае нас интересуют только поля по горизонтали 4 и вертикали e. Поля по краям доски можно проигнорировать, поскольку они не влияют на набор полей, которые атакует ладья.

Итак, мы получили 10 клеток, которые называются маской ладьи. Эта маска выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 1 1 1 0 1 1 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

Если наложить маску на битборд блокирующих фигур, мы получим только те биты, которые важны для расчёта ходов ладьи на e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
```

Наша хэш-функция должна опускать эти биты в начало битборда. Тогда мы получим число, меньшее, чем 64-битный битборд. Всего таких чисел 2^10^, что значительно меньше чем 2^64^.

Хэш-функция умножает биты для расчёта ходов ладьи на некоторое "магическое" число. В результате такого умножения биты группируются вместе. Следующая операция — побитовый сдвиг группы битов вправо. В результате все важные нам биты оказываются в начале 64-битного числа.

Вопрос в том, как находить "магические" числа, которые группируют нужные нам биты битборда? Эти числа находятся [**полным перебором**](https://ru.wikipedia.org/wiki/Полный_перебор) для ладьи и слона на каждой клетке. После нахождения этих чисел они сохраняются в коде движка. То есть повторно находить их не нужно.

Полный алгоритм поиска хода с помощью магического битборда выглядит так:

1. Наложить на битборд блокирующих фигур маску фигуры (например маску ладьи на e4).

2. Передать результат наложения маски на битборд в хэш-функцию.

3. Использовать результат хэш-функции как индекс двумерного массива с рассчитанными ранее ходами.

I> Идею магических битбордов наглядно объясняет следующее [видео](https://www.youtube.com/watch?v=K0rp1vXV3Ek).

##### 3.5.2.2.2 Минимакс и альфа-бета отсечение

Механизм поиска Stockfish типичен для современных шахматных программ — это минимаксный поиск с альфа-бета отсечением.

Мы познакомились с общим принципом работы алгоритма минимакс и альфа-бета отсечения в разделах 2.5.2 и 2.5.3. Теперь рассмотрим, как именно они работают в шахматах.

Допустим для примера, что шахматный движок рассматривает два **полухода**. Термин полуход используют разработчики шахматных программ. Он означает ход одной из сторон: белых или чёрных. Два полухода составляют один полный ход.

Поскольку шахматы просчитать до конца нельзя, то минимакс ориентируется не на конечный результат партии, а на промежуточную статическую оценку позиции. Эта оценка рассчитывается для каждого полухода. Функция статической оценки возвращает положительное или отрицательное целое число. Чем оно больше, тем позиция лучше для шахматного движка. Чем число меньше — тем лучше для противника.

Шахматный движок использует поиск минимакс и статическую оценку. Так он находит свой лучший полуход, с учётом лучшего ответного полухода противника. В шахматах рассматривать только два полухода мало. Для качественной игры надо просчитывать более отдалённые последствия своих действий. Поэтому движок не останавливается на проверке одного полного хода, а просчитывает  полуходы обеих сторон дальше вглубь. Результат их статической оценки влияет на оценку полухода, который движок должен сделать прямо сейчас.

Сам по себе механизм минимакс очень ресурсоёмкий. На протяжении партии у каждой стороны в среднем есть по 30 возможных полуходов в каждой позиции. Получается, чтобы просчитать 10 всех возможных полуходов вперёд (или 5 полных ходов), надо проверить 30^10^ позиций. Это потребует слишком много времени.

Чтобы ускорить поиск минимакс, шахматный движок использует метод альфа-бета отсечения. Как она работает? Предположим, что шахматный движок рассматривает свой полуход A. Далее движок перебирает все возможные ответные полуходы противника. Пусть статическая оценка дала число +4 на лучший из ответов противника. Теперь движок переходит к следующему своему возможному полуходу B. Для примера оценка первого рассмотренного ответа противника оказалась -1. Это позволяет исключить из рассмотрения все остальные ответы противника на полуход B движка. Независимо от их статической оценки, полуход B всегда будет хуже, чем A. Причина в том, что в ответ на полуход B противник может создать позицию с оценкой -1 или хуже. Это значит, что для движка предпочтительнее полуход A, на который лучший ответ противника создаст позицию +4. Этот алгоритм даёт такой же результат, что и чистый минимакс поиск, только намного быстрее.

Применение метода альфа-бета не гарантирует высокую эффективность. Если в первую очередь движок проверяет посредственные ходы обеих сторон, то обрезание веток поиска будет происходить слишком поздно. Из-за этого будет обрезано только незначительное число веток и выигрыш в скорости поиска по сравнению с минимаксом будет незначительный.

Чтобы повысить эффективность альфа-бета отсечения, необходимо сортировать рассматриваемые ходы. В первую очередь надо проверять наиболее перспективные из них. Тогда большую часть посредственных ходов удастся отсечь. Эта оптимизация называется [**move ordering**](https://www.chessprogramming.org/Move_Ordering) (сортировка ходов) — сортировка ходов по их перспективности с учётом всей доступной на данный момент информации.

Stockfish реализует move ordering с помощью ряда эвристик под названием **истории ходов**. Всего таких эвристик шесть штук. Одна из них — это **continuation history** (история ответных ходов). Если Stockfish играет серию партий, он запоминает результаты своих ответных ходов на ходы противника. Например противник ходит конём на f6, а шахматный движок отвечает слоном на c4. Если ход оказался успешным, он получает положительную оценку. В противном случае оценка хода будет отрицательная. Далее когда противник ходит конём на f6 в другой позиции, Stockfish сортирует свой ход слоном на c4 в зависимости от его оценки по прошлым партиям.

Кроме истории ответных ходов Stockfish запоминает историю своих успешных последовательностей ходов. Например, в одной из сыгранных партий движок сходил конь f3. Его следующим ходом был конь g5. Статическая оценка дала ему высокий результат. Stockfish запоминает это. В другой партии после хода конь f3 движок рассмотрит последующий ход конь g5 в первую очередь.

##### 3.5.2.2.3 Выборочный поиск

Чтобы ускорить минимаксный поиск с альфа-бета отсечением, Stockfish использует разные эвристики **выборочного поиска** ([selective search](https://www.chessprogramming.org/Selectivity)). Такой поиск включает в себя три техники:

1. **Продление** ([extension](https://www.chessprogramming.org/Extensions)) — продолжение просчёта вглубь для перспективного хода.

2. **Сокращение** ([reduction](https://www.chessprogramming.org/Reductions)) — просчёт малоперспективного хода на меньшую глубину, чем обычно.

3. **Отсечение** ([pruning](https://www.chessprogramming.org/Pruning)) — удаление ветвей дерева поиска без их просчёта.

Продление выполняют в следующих случаях:

1. Произошло взятие.
2. Произошёл шах.
3. Ход единственный.
4. Ход гораздо лучше альтернатив.
5. При наличии проходной пешки.

Продления нужны, чтобы бороться с эффектом горизонта. Этот эффект приводит к неверной оценки позиции, когда движок достигает максимальной глубины поиска. Причина ошибки в том, что последующие не просчитанные ходы оппонента кардинально меняют позицию.

Рассмотрим пример. Допустим, что на максимальной глубине поиска движок видит взятие вражеского ферзя. После взятия оценка позиции очень высокая. Но на следующий ход противник может взять ферзя в ответ: то есть происходит размен. В результате позиция снова становится равная. Если ответное взятие оказалось за пределами глубины поиска — происходит эффект горизонта. Движок будет выбирать ходы, которые ведут его к взятию ферзя, пока ответное взятие не попадёт в максимальную глубину поиска. Тогда программа "увидит" размен и будет вынуждена полностью менять свой план.

Продления выполняются до спокойной позиции. В такой позиции нет взятий, шахов и единственных ходов. Эта техника называется **поиск спокойствия** ([quiescence search](https://www.chessprogramming.org/Quiescence_Search)). Спокойная позиция гарантирует, что у противника нет способа кардинально изменить позицию и её оценку для движка.

Сокращения и отсечения нужны, чтобы понизить коэффициент ветвления. В Stockfish этот коэффициент в среднем равен 1.7 или 1.8. На протяжении партии у каждой стороны есть около 30 возможных ходов в каждой позиции. Это означает, что движок отбрасывает 28 потенциальных ходов и рассматривает из них только 2. Если учесть просчёт ходов вглубь, то окажется что Stockfish отбрасывает 90% всего дерева поиска. Такая оптимизация значительно ускоряет поиск. Её недостаток в том, что программа может отсекать хорошие ходы, которые ведут к сильным комбинациям или мату.

Stockfish использует следующие алгоритмы сокращений:

1. [Late Move Reductions](https://www.chessprogramming.org/Late_Move_Reductions) (LMR) — уменьшение глубины поиска для ходов, которые алгоритм сортировки move ordering поместил в конец списка. В конце списка оказываются малоперспективные ходы, поэтому движок просчитывает их на меньшую глубину.

2. [Fail-High Reductions](https://www.chessprogramming.org/Fail-High_Reductions) (FHR) — уменьшение глубины поиска в спокойных позициях, когда на стороне делающего ход игрока есть существенное преимущество. [**Fail-high node**](https://www.chessprogramming.org/Fail-High) (или Cut-node) означает позицию, которая слишком хорошая для одной из сторон. При этом алгоритм поиска уже нашел ход оппонента, который предотвращает эту позицию. Вероятнее всего этот ход будет сделан, поэтому нет смысла просчитывать позицию глубоко. В этом случае происходит [beta-cutoff](https://www.chessprogramming.org/Beta-Cutoff), то есть отсечение по значению β.

3. [Null Move Reductions](https://www.chessprogramming.org/Null_Move_Reductions) (NMR). Допустим, что у одной из сторон есть существенное преимущество в рассматриваемой позиции. Если просто передать ход оппоненту и оценка позиции всё равно останется высокой, глубину поиска можно сократить. Передача ходу оппоненту называется [**null move**](https://www.chessprogramming.org/Null_Move). Такая передача запрещена правилами шахмат, но полезна для оптимизаций поиска.

Stockfish использует такие методы отсечения: 

1. [Mate Distance Pruning](https://www.chessprogramming.org/Mate_Distance_Pruning) работает, когда движок нашёл форсированный мат в несколько ходов. После этого он отсекает поддеревья, в которых невозможен мат за меньшее число ходов. Другими словами, когда мат найден, программа просчитывает самый короткий путь к нему.

2. [Futility pruning](https://www.chessprogramming.org/Futility_Pruning) выполняется за один ход до достижения максимальной глубины поиска. Эвристика отсекает узлы, оценка которых не может превысить уже найденную α. Чтобы подсчитать приблизительную оценку ещё не посещённых узлов, к оценке их корневого узла прибавляется константа под названием **запас бесполезности** (futility margin). Если сумма не превышает текущую α, то все подузлы отсекаются.

3. [SEE based pruning](https://www.chessprogramming.org/Static_Exchange_Evaluation). Статическая оценка обмена (Static Exchange Evaluation или SSE) проверяет последствия разменов на определённом поле, которые произойдут после выбранного хода. В результате вычисления SSE даёт вероятное изменение материала, которое будет потеряно или получено. Если функция SSE вернула отрицательное значение (т.е. проигрыш материала), Stockfish не рассматривает последствия хода, который ведёт к размену.

4. [History Leaf Pruning](https://www.chessprogramming.org/History_Leaf_Pruning) основана на эвристики истории ([history heuristic](https://www.chessprogramming.org/History_Heuristic)). Идея в том, чтобы считать сколько раз конкретный ход вызвал отсечение независимо от позиции, в которой он был сделан. Когда счётчик превышает пороговое значение, соответствующее этому ходу поддерево поиска отсекается.

5. [Multi-cut pruning](https://www.chessprogramming.org/Multi-Cut) — этот алгоритм выполняет сокращённый поиск в поддереве на небольшую глубину. Если из всех обойдённых узлов заданное число (например, три) оказалось fail-high node, то всё поддерево отсекается.

#### 3.5.2.3 Статическая оценка в Stockfish

Stockfish использует следующие механизмы для статической оценки позиций:

* Запрограммированная оценка.
* Нейронная сеть [**NNUE**](https://www.chessprogramming.org/Stockfish_NNUE).

Рассмотрим, как они работают.

##### 3.5.2.3.1 Запрограммированная оценка

До 2020 год Stockfish использовал вручную запрограммированную статическую оценку позиции. Эта оценка складывается из нескольких факторов.

Сначала Stockfish подсчитывает материал в заданной позиции. Это самая простая и быстрая оценка.

Затем проверяется пешечная структура. Для этого используются разные эвристики. Чтобы применить эти эвристики, алгоритм Stockfish перебирает все пешки на доске одна за другой. Для каждой из них выполняется ряд проверок. Вот несколько примеров:

1. Является ли пешка проходной?
2. Является ли пешка отсталой?
3. Является ли пешка сдвоенной?

В первом случае владеющий пешкой игрок получает бонус, а в двух других — штраф.

После проверки пешек Stockfish делает аналогичный перебор по фигурам. Для каждой из них проверяется мобильность. Для мобильности подсчитывается число клеток, которые:

1. Фигура атакует.
2. Не заблокированы своими фигурами.
3. Не бьются пешками противника.

С помощью таблиц подсчитанные клетки перекладываются на числовую оценку.

Следующая оценка Stockfish проверяет позицию короля. Она включает следующее:

1. Потенциальные шахи.
2. Число атак на **кольцо короля**. Этим кольцом называется восемь клеток вокруг короля.

Далее Stockfish с помощью эвристик проверяет очевидные угрозы. Например, что противник атакует ферзя или может напасть на него за один ход.

Если партия находится в эндшпиле, то для каждой позиции Stockfish оценивает возможность победы. Эта оценка складывается из проверки набора фигур и их расположения на доске. Прежде всего оценивается число пешек. Если пешек мало, то выиграть эндшпиль тяжело. Потому что часто победа достигается проведением пешки в ферзи. Другой пример с оценкой позиции фигур. Если все пешки на одном фланге, то выиграть ладейный эндшпиль сложно. Такая позиция также получит низкую оценку.

Последняя проверка эндшпиля называется **фактор масштабирования**. Этот термин означает коэффициент, на который умножается уже подсчитанная оценка эндшпиля. Умножение происходит при выполнении некоторых условий. Например, если у сторон остались разноцветные слоны, то коэффициент будет от 1/3 до 1/2. Таким образом понижается общая оценка эндшпиля (положительная или отрицательная). Причина в том, что при разноцветных слонах выиграть эндшпиль тяжело.

В 2020 году версия Stockfish 12 перешла на статическую оценку позиции с помощью нейронной сети NNUE.

##### 3.5.2.3.2 Нейронная сеть NNUE

Сеть NNUE (efficiently updatable neural network) разработал японский учёный [Ю Насу](https://www.chessprogramming.org/Yu_Nasu) в 2018 году. Она представляет собой сеть с прямой связью (FNN) категории shallow learning. Ю Насу разрабатывал NNUE специально для оценки текущей позиции фигур на доске. Она не учитывает временные зависимости и последовательности событий.

Первая версия сети NNUE анализировала позиции не в шахматах, а в японской адаптации этой игры под названием [сёги](https://ru.wikipedia.org/wiki/Сёги). Ю Насу помимо научной деятельности участвовал в проектах по адаптации движка Stockfish для сёги. [YaneuraOu](https://www.chessprogramming.org/YaneuraOu) — это один из таких проектов. Его разработчики применили новую сеть NNUE для статической оценки позиции. Это усилило игру движка примерно на 500 Эло.

В проекте YaneuraOu участвовал другой японский учёный [Хисаюри Нода](https://www.chessprogramming.org/Hisayori_Noda). В качестве эксперимента он интегрировал сеть NNUE в оригинальный Stockfish версии 10 в 2019 году. Тесты показали усиление игры движка на 50 Эло. В течение года этот проект развивался как форк Stokfish под названием [Stockfish NNUE](https://www.chessprogramming.org/Stockfish_NNUE). Он заинтересовал многих разработчиков шахматных движков.

В августе 2020 года система тестирования Fishtest показала, что Stockfish NNUE сильнее оригинального движка на 80 пунктов Эло. Тогда разработчики Stockfish решили включить сеть NNUE в следующий официальный релиз. Все наработки форка Stockfish NNUE добавили в код Stockfish.

2 сентября 2020 года вышел первый релиз Stockfish версии 12 с сетью NNUE. Он играл значительно сильнее, чем предыдущая версия. Разработчики продолжают совершенствовать и обучать сеть NNUE. Эта работа усиливает игру движка Stockfish с каждым следующим релизом.

Рассмотрим, как устроена NNUE. Чтобы понять её архитектурные решения, сначала надо разобраться, какие цели ставил Ю Насу перед этой сетью. Учёный разрабатывал модель для замены вручную запрограммированной статической оценки позиции в минимаксном поиске с альфа-бета отсечением. Чтобы модель работала лучше чем запрограммированная оценка, она должна удовлетворять следующим требованиям:

1. Скорость работы модели должна быть сопоставима скорости запрограммированной оценки. Если модель работает слишком медленно, шахматный движок будет оценивать намного меньше позиций в секунду. Это значительно снизит силу его игры.

2. Модель должна выполнять инкрементальные вычисления. Каждый ход лишь незначительно меняет состояние доски. Поэтому для анализа текущего хода сеть должна использовать свои расчёты, выполненные для предыдущего хода.

3. Модель должна эффективно работать на том же оборудовании, которое использует запрограммированная оценка. Другими словами сеть должна работать на обычных CPU, а не GPU.

Ю Насу решил, что именно инкрементальные вычисления — это главная отличительная черта его новой модели. Поэтому он назвал её **эффективно обновляемая нейронная сеть** (efficiently updatable neural network. Сокращенное название сети EUNN можно записать в обратном порядке букв как NNUE. Это слово напоминает имя японского мифического существа [Нуэ](https://ru.wikipedia.org/wiki/Нуэ). Из-за этого сходства Ю Насу и назвал свою сеть NNUE.

Чтобы удовлетворить требованиям к модели, учёный сформулировал три принципа её организации:

1. Сеть должна иметь относительно небольшое количество ненулевых входов.

2. Входные данные должны меняться как можно меньше между последующими оценками.

3. Сеть должна быть достаточно простой, чтобы выводить результат низкой точности в целочисленном виде.

Первый принцип означает, что при **масштабировании сети** входные данные должны стать **редкими**. Масштабировании сети означает увеличение в ней числа нейронов, уровней или входных параметров. Данные называются редкими, когда значительная их часть — это нули или очень маленькие значения.

Когда у сети мало ненулевых входов, понижается верхняя граница времени, необходимого для полной оценки входных данных с нуля. Именно благодаря первому принципу, сети NNUE могут быть большими, но при этом быстро оценивать позиции.

Следование второму принципу позволяет сети переиспользовать результаты оценки позиции с прошлого хода. Это даёт дополнительный выигрыш в скорости работы.

Третий принцип означает, что модель должна оперировать целыми числами, а не [**числами с плавающей запятой**](https://ru.wikipedia.org/wiki/Число_с_плавающей_запятой). Такой перевод нейронной сети на целочисленные расчёты называется **квантованием**. Квантование значительно ускоряет обработку входных данных модели, поскольку обычные CPU выполняют целочисленные операции быстрее. Минус квантования в потере точности. Оно приводит к ошибке вычислений, которая накапливается тем больше, чем глубже сеть.

Из-за накопления ошибки в результате квантования модель должна иметь минимальное число скрытых слоёв. Это также необходимо, чтобы удовлетворить третье требование — использовать то же оборудование, что и запрограммированная оценка. Как только модель попадает в разряд deep learning, ей перестаёт хватать производительности обычных CPU для эффективной работы.

NNUE — это собирательное название для моделей, который удовлетворяют трём принципам организации Ю Насу. Детали реализации каждой модели могут различаться. Это значит, что современные шахматные движки используют разные вариации NNUE. Более того разные версии Stockfish используют разные архитектуры NNUE.

Рассмотрим архитектуру под названием [**HalfKp**](https://www.chessprogramming.org/Stockfish_NNUE#HalfKP). Она подробно описана разработчиками проекта [nnue-pytorch](https://github.com/official-stockfish/nnue-pytorch/blob/master/docs/nnue.md) на Github. Именно вариант HalfKp был впервые интегрирован в Stockfish версии 10.

Затем архитектуру HalfKp развивал польский учёный [Томаш Собчик](https://www.chessprogramming.org/Tomasz_Sobczyk), который также участвует в проекте Stockfish. Так появились варианты NNUE под названием [**HalfKA**](https://www.chessprogramming.org/Stockfish_NNUE#HalfKA), HalfKAv2 (используется в Stockfish 14) и HalfKAv2_hm (используется в последнем Stockfish 16). Томаш Собчик оптимизировал оригинальную архитектуру HalfKp, чтобы ускорить время обучения модели и сократить объём обучающего набора данных.

Архитектура HalfKp — это shallow learning модель, которая имеет три скрытых слоя. Для начала рассмотрим, как устроен её входной слой. Входные данные NNUE сети должны быть редкими. Поэтому Ю Насу предложил для них специальный формат.

Всего на шахматной доске 64 поля. Есть 6 типов фигур: пешка, конь, слон, ладья, ферзь и король. Фигуры могут быть двух цветов: черные и белые. В качестве входных данных модели закодируем позиции фигур. Тогда каждый нейрон входного слоя будет соответствовать одному набору из трёх элементов: (поле, фигура, цвет). Всего таких наборов будет: `64 * 6 * 2 = 768`. Если на поле S есть фигура P цвета C, то мы устанавливаем в 1 вход сети, соответствующий набору (S,P,C). В противном случае этот вход устанавливаем в 0. Тогда в любой возможной шахматной позиции будет не более 32 ненулевых входов, поскольку на доске может находится не более 32 фигур. При этом любой ход меняет не более 4 входов сети (это случай рокировки). В среднем же один ход меняет менее 3-х входов.

Рассмотрим пример кодирования шахматной позиции на вход модели. Иллюстрация 3-32 демонстрирует позицию с четырьмя фигурами.

{caption: "Иллюстрация 3-32. Шахматная позиция с четырьмя фигурами", height: "40%"}
![Шахматная позиция с четырьмя фигурами](images/Chess/Stockfish-HalfKp-input.png)

Четыре фигуры на доске кодируются такими наборами: (A1, король, белые), (C3, пешка, белые), (B8, король, черные), (D4, ладья, черные). Ход пешки на c4 изменит вход (C3, пешка, белые) на 0, а вход (C4, пешка, белые) на 1. Ход пешки cxd4 изменит вход (C3, пешка, белые) на 0, вход (D4, пешка, белые) — на 1 и (D4, ладья, черные) — на 0.

Итак мы получили редкие входные данные, которые незначительно меняются после каждого хода. Как именно нейронная сеть использует это преимущество и выполняет инкрементальные вычисления? Для этого у неё есть механизм под названием **накапливающий сумматор** (accumulator). Его реализует первый скрытый слой модели.

Первый скрытый слой модели является **линейным** (linear). Назовём его входные значения `in_features`, а выходные — `out_features`. Тогда слой выполняет линейное преобразование над своими входами по следующей формуле:
{width: "50%"}
![](images/Chess/nnue-linear-layer-formula.png)

В ней используются следующие обозначения:

* x — вектор входных значений размера `in_features`
* A — матрица весов размера `(out_features, in_features)`
* b — вектор смещения (bias) размера `out_features`
* y — выходной вектор размера `out_features`.

По-сути линейный слой — это просто сложение нескольких столбцов матрицы весов. Вместо того чтобы пересчитывать линейное преобразование после каждого хода, нейронная сеть сохраняет его результат. Она обновляет этот результат после каждого хода, в зависимости от изменений входных наборов (S,P,C). Для этого сеть обрабатывает два простых случая:

* Входной набор i был удалён (1->0), тогда из сохранённого результата надо вычесть столбец i матрицы весов A.

* Входной набор i был добавлен (0->1), тогда к сохранённому результату надо прибавить столбец i матрицы весов A.

Ю Насу не остановился на полученном формате и продолжил его оптимизировать. Он хотел получить ещё более редкие входные данные для модели. Для этого в каждый набор входных данных он добавил позицию короля так: (поле_короля, поле_фигуры, фигура, цвет). Эти наборы есть для всех типов фигур кроме короля. Такой формат позволяет модели лучше понимать расположение фигур относительно короля. Общее количество таки наборов будет равно: `64*64*5*2=40960`. В HalfKp реализации NNUE для Stokfish есть 64 неиспользуемых входных набора, что даёт общую сумму входов модели: `40960 + 64 = 41024`. Эти входы использовались в сёги, но оказали ненужны для шахмат.

Новый формат сделал входные данные более редкими. Его единственный минус — это ход короля, который стал очень дорогостоящим. Он приводит к изменению всех входов модели. Ю Насу посчитал это приемлемым компромиссом.

У внимательного читателя мог возникнуть вопрос: позиция какого короля (белого или чёрного) указывается во всех входных наборах модели? Ответ — обоих королей. Архитектура HalfKp имеет два накапливающих сумматора: для чёрных и для белых. Это означает, что количество входных наборов тоже удваивается: позиции всех фигур относительно белого короля и то же самое относительно чёрного.

Решение с двумя накапливающими сумматорами приводит к дополнительным вычислениям. Во-первых, каждый ход приводит к пересчётам в самих сумматорах. Во-вторых, результаты сумматоров надо свести в конечный результат, который передаётся на второй скрытый слой сети. В HalfKp архитектуре это выполняется простым объединением выходных векторов y1 и y2 обоих сумматоров. Преимущество двух сумматоров в увеличении точности модели.

Возникает ещё один вопрос. Если есть входные наборы с точки зрения белого короля и чёрного, то чем они различаются? Для эффективной работы сети нужно чтобы эти входные наборы отличались между собой. В противном случае увеличения точности модели не будет. В HalfKp архитектуре эта проблема решается сменой цвета фигур для точки зрения чёрных.

Ещё раз обратимся к позиции на иллюстрации 3-32. С учётом разворота доски она кодируется следующими двумя наборами:

* С точки зрения белых: (A1, C3, пешка, белая), (A1, D4, ладья, чёрная)

* С точки зрения чёрных: (B1, C6, пешка, чёрная), (B1, D5, ладья, белая)

Пример показывает, что для точки зрения чёрных поменялся не только цвет фигур, но и номера полей. Это произошло потому, что белые фигуры всегда начинают игру на горизонталях 1 и 2. Следовательно смена цвета чёрного короля, означает что он находится не на поле b8, а на b1. То же самое справедливо для всех остальных фигур.

Теперь рассмотрим сеть архитектуры HalfKp целиком. Её демонстрирует иллюстрация 3-33.

{caption: "Иллюстрация 3-33. Архитектура HalfKp сети NNUE для Stockfish 10", height: "40%"}
![Архитектура HalfKp сети NNUE для Stockfish 10](images/Chess/Stockfish-NNUE-HalfKp.png)

>>>

Главное достоинство сети NNUE в том, что она быстро работает на процессорах (CPU). Это отличает её от большинства других нейронных сетей, которым для эффективной работы нужен [**графический процессор**](https://ru.wikipedia.org/wiki/Графический_процессор) (GPU). Это означает, что NNUE не требует дорогое специализированное оборудование. Она эффективно работает на маломощных ноутбуках и смартфонах.

У сети NNUE есть и недостатки. Главный из них — невысокая скорость работы. Сети требуется больше времени на обработку каждой позиции по сравнению с оценкой, запрограммированной вручную.

Чтобы создать сеть NNUE, применяется алгоритм обучения с учителем. Этот алгоритм принимает на вход 16 миллиардов позиций и оценка для каждой из них. Позиции берутся из реальных партий с разными дебютами. Так достигается их разнообразие. Предварительную оценку позиций выполняет шахматный движок с открытым исходным кодом Leela Chess Zero.

Алгоритм обучения создаёт сеть NNUE, которая даёт оценку позициям близкую к той, что дала Leela Chess Zero. Значение оценки интерпретируется так же, как и для вручную запрограммированных алгоритмов. Чем большее число вернула сеть NNUE, тем позиция лучше для движка. Чем число меньше — тем позиция хуже.

Результат обучения нейросети проверяется с помощью системы тестирования Fishtest. Если движок Stockfish с новой сетью NNUE показывает лучшую игру, чем текущая версия движка — тест считается пройденным. В этом случае новая версия сети NNUE попадает в очередной релиз Stockfish.

Вручную запрограммированная оценка до сих пор используется в Stockfish. Она нужна в позициях, когда скорость работы важнее чем точность. Например, если у одной из сторон значительный материальный перевес (в ферзя или ладью).

Нейронная сеть NNUE не может заменить минимаксный поиск с альфа-бета отсечением в Stockfish. Разработчики пробовали настроить движок так, чтобы он выбирал наилучший ход по мнению статической оценки сети NNUE. Другими словами движок делал тот ход, который сеть оценивала как наилучший. При этом он не просчитывал дальнейшие ходы вглубь. В этом случае сила игры Stockfish составила всего 500-600 Эло.

Этот эксперимент показал принципиальное различие между нейросетью Leela Chess Zero и NNUE. Движок Leela Chess Zero с отключенным поиском играет на уровне 2000 Эло.

Разный уровень игры Stockfish и Leela Chess Zero с отключенным поиском связан с архитектурой их нейронных сетей. Эти движки находятся на разных сторонах спектра возможностей сетей. У Stockfish относительно маленькая, но быстрая нейронная сеть. Она позволяет движку оценивать много позиций и просчитывать их на глубину 25-30 полуходов. То есть Stockfish делает ставку на скорость оценки.

Leela Chess Zero использует большую нейронную сеть. Для её работы необходим GPU. Из-за своего размера сеть работает относительно медленно. Она позволяет оценить совсем немного позиций, но зато делает это более качественно, чем NNUE в Stockfish.

### 3.5.3 AlphaZero

#### 3.5.3.1 Поиск Монте-Карло

Рассмотрим как работает поиск [Монте-Карло по дереву](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search) игры шахматы. Его идея в том, чтобы рассматривать только самые перспективные ходы. Поиск основан на **playout**. Playout означает шахматной проигрывание партии от текущий позиции до конца. В этом playout ходы выбираются случайным образом. Результат такой проигранной партии используется для оценки узлов дерева поиска. В следующем playout ходы с большим весом будут использоваться с большей вероятностью.

### 3.5.4 Leela Chess Zero

#### 3.5.4.1 Нейронная сеть

В отличие от сети NNUE, сеть Leela Chess Zero возвращает оценку позиции и move ordering. То есть на выходе нейронной сети мы получаем порядок ходов для алгоритма поиска. Этот move ordering заменяет эвристики истории ходов Stockfish.