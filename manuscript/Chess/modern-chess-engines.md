## 3.5 Современные шахматные движки

В конце 1990-х годов шахматные программы для ПК достигли уровня игры специализированных суперкомпьютеров наподобие Deep Blue. В результате новые разработки представляли собой именно программы. Компании и энтузиасты перестали проектировать специализированное шахматное аппаратное обеспечение, потому что это было слишком дорого.

Как настольные компьютеры достигли уровня игры суперкомпьютеров? Во-первых, значительно увеличилась мощность ПК. Большая часть таких компьютеров имела [IBM-совместимую](https://ru.wikipedia.org/wiki/IBM-PC-совместимый_компьютер) архитектуру и работала на процессорах от Intel. В 1993 году вышел процессор [Intel Pentium](https://ru.wikipedia.org/wiki/X86#Процессоры_Intel). К концу 1990-х его конструкция была усовершенствована. Так доступные ПК получили мощный и недорогой процессор. Его производительности хватало шахматным программам, чтобы просчитывать ходы на глубину, достаточную для качественной игры.

Вторая причина — это совершенствование самих шахматных программ. Основные улучшения касались оценочной функции. Благодаря им, программы качественнее оценивали позиции и выбирали более сильные ходы. Так же появились новые эвристики поиска. Это позволяло программам отбрасывать больше бесперспективных ходов и глубже просчитывать перспективные.

### 3.5.1 Шахматные движки

В 1993 году разработчик шахматных программ [Мартин Хирш](https://www.chessprogramming.org/Marty_Hirsch) ввёл термин [**шахматный движок**](https://ru.wikipedia.org/wiki/Шахматный_движок). Хирш сделал это чтобы отличать коммерческие шахматные игры от инструментов для профессиональных шахматистов.

Шахматные игры для ПК начали появляться в конце 1980-х годов. Примеры таких игр: [Chessmaster](https://en.wikipedia.org/wiki/Chessmaster) и [Battle Chess](https://en.wikipedia.org/wiki/Battle_Chess). Эти программы имели красивый графический интерфейс по меркам того времени. Например, в Battle Chess после каждого хода фигуры оживают и перемещаются на указанное поле доски. Если это поле уже занимает фигура противника, то происходит сражение. Шахматные игры предназначались для широкой аудитории. Они продавались по низкой цене и позиционировались как развлечения. Их уровень игры был достаточно низким: около 1600 пунктов Эло.

В отличие от игр, шахматные движки не имеют графического интерфейса. Они предназначены для анализа заданной позиций и поиска в ней наилучшего хода. Пользователь работает с такой программой через интерфейс командной строки. Шахматные движки изначально позиционировались как инструменты для профессионалов. С их помощью шахматисты анализировали партии и готовились к турнирам. Соответственно цена на шахматные движки была высокой, как и на любой профессиональный инструмент. Их уровень игры был намного выше, чем у шахматных игр.

Интерфейс командной строки был неудобен для большинства пользователей. Поэтому в начале 1990-х стали появляться программы для визуализации работы шахматного движка. Большинство современных программ визуализации коммерческие и достаточно дорогие. При этом наиболее сильные шахматные движки бесплатны и распространяются с [открытым исходным кодом](https://ru.wikipedia.org/wiki/Свободное_и_открытое_программное_обеспечение).

Все современные шахматные движки состоят из двух основных частей:

1. Механизм поиска.
2. Статическая оценка позиции.

Рассмотрим как реализованы эти части в самых сильных современных шахматных движках.

### 3.5.2 Stockfish

Stockfish считается сильнейшим современным шахматным движком. Он занимает первые строчки в рейтингах [Chess Engines Grand Tournament](http://www.cegt.net/40_40 Rating List/40_40 BestVersion/rangliste.html) (CEGT) и [Computer Chess Rating Lists](https://ccrl.chessdom.com/ccrl/4040/) (CCRL) за 2022 год.

Stockfish стал продолжением проекта шахматного движка Glaurung, разработанного Тордом Ромстадом. Первая версия Glaurung вышла в 2004 году. Это была программа для ПК с открытым исходным кодом. Разработчики портировали её более поздние версии на мобильные телефоны и планшеты.

В ноябре 2008 году Марко Костальба решил сделать [**форк**](https://ru.wikipedia.org/wiki/Форк) (от английского fork — вилка) кода Glaurung. Форком называется использование кодовой базы одного проекта в качестве старта для другого. Костальба назвал свой проект Stockfish. Первая версия этого движка вышла в ноябре 2008 года.

В течение 2008 года Glaurung и Stockfish развивались параллельно. Оба проекта распространялись с открытым исходным кодом. Поэтому их команды свободно обменивались идеями и усовершенствованиями алгоритмов.

В декабре 2008 года Ромстад выпустил последнюю версию Glaurung 2.2. Он решил прекратить поддержку своего проекта и присоединился к команде Stockfish. Причина решения была в том, что Stockfish на тот момент превзошёл Glaurung по уровню игры.

В 2011 году Ромстад вышел из проекта Stockfish. Он занялся разработкой шахматной программы для iOS. В 2014 году проект покинул Марко Костальба. Современная версия Stockfish развивается группой энтузиастов в которой около 20 человек.

#### 3.5.2.1 Система тестирования Fishtest

Stockfish достиг высокого уровня игры во многом благодаря специальной системе распределённых тестов под названием Fishtest. Её разработал Гэри Линскотт в 2013 году. Система Fishtest позволяет добровольцам выделять процессорное время своих компьютеров на тестирование шахматного движка. Суть тестирования заключается в многократных играх модифицированной версии Stockfish против последней стабильной версии. Только статистически значимые улучшения принимаются сообществом разработчиков.

Эффективность Fishtest можно оценить по первым 12 месяцам его использования. За это время уровень игры Stockfish вырос на 120 пунктов Эло. В результате этого прогресса Stockfish поднялся до лидирующих позиций во всех основных рейтингах шахматных движков.

К декабрю 2022 года благодаря системе Fishtest движок Stockfish сыграл около 5 миллиардов шахматных партий. На это ушло более 8650 лет процессорного времени.

#### 3.5.2.2 Механизм поиска в Stockfish

Поиск в Stockfish он основан на следующих алгоритмах:

* Магические битборды
* Минимаксный поиск
* Эвристика альфа-бета отсечения
* Оптимизация move ordering

Рассмотрим их подробнее.

#### 3.5.2.2.1 Магические битборды

Чтобы начать поиск, шахматному движку нужно получить список возможных ходов, допустимых правилами. Решение этой задачи зависит от формата, в котором движок хранит состояние шахматной доски. Наиболее эффективным форматом для современных компьютеров считаются [**битборды**](https://hmn.wiki/ru/Bitboard). Разберёмся, как они работают.

Впервые на практике битборды использовал Кристофер Стрейч в своей программе для игры в шашки в 1952 году. Битборды в шахматах впервые применили разработчики советской шахматной программы [Каисса](https://ru.wikipedia.org/wiki/Каисса_(программа)) в конце 1960-х годов.

Идея битбордов в том, чтобы оптимизировать обработку состояния доски. Битборд представляет собой одно 64-разрядное число. Каждый бит этого числа соответствует одному из 64-х полей шахматной доски. Если бит равен единице, поле занято фигурой. Если бит равен нулю, то поле свободно.

Чтобы сохранить состояние всех фигур на шахматной доске, нужно минимум восемь битбордов. По одному на каждый из шести типов фигур: пешки, ладьи, кони, слоны, короли, ферзи. Два битборда нужны для определения цвета фигуры на каждом поле: черный или белый. На практике обычно применяется набор из 12 битбордов: по одному для каждого типа фигур, каждого цвета. Такой подход удобнее для расчётов возможных ходов.

Рассмотрим пример. Битборд для начальной позиции белых пешек наглядно можно представить так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
```

На самом деле, в памяти компьютера этот битборд хранится как 64-разрядное число в двоичной системе счисления так:
{line-numbers: false, format: text}
```
0000000000000000000000000000000000000000000000001111111100000000
```

Аналогично, битборд для двух чёрных коней в начальной позиции выглядит так:
{line-numbers: false, format: text}
```
  0 1 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Ему соответствует такое 64-разрядное число в памяти:
{line-numbers: false, format: text}
```
0100001000000000000000000000000000000000000000000000000000000000
```

Какие преимущества дают битборды? Современные процессоры оперируют 64-разрядными регистрами. Это означает, что один битборд целиком помещается в один регистр. Также любую проверку или действие над числом процессор выполняет за одну операцию. Одна операция длится один [**такт**](https://hardwareguide.ru/процессор/частота-процессора/). Тактовая частота современных процессоров достигает 4 гигагерц. Это соответствует 4*10^6^ операций в секунду. Благодаря битбордам, современные шахматные программы достигают очень высокой производительности.

Битборды хранят состояния доски. Но сами по себе они не дают все доступные ходы для каждой фигуры. Эти ходы можно посчитать с помощью битовых операций. Для пешек, коней и королей их легко рассчитать с помощью битовых сдвигов.

Вот расчёт ходов для белых пешек в начальной позиции. Все пешки могут пойти на одно поле вперёд. В этом случае битовая маска допустимых ходов выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Кроме этого каждая пешка из начальной позиции может пойти на два поля вперёд. Это даст такую битовую маску:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Если мы наложим две битовые маски с допустимыми ходами друг на друга, то получим такой битборд:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Этот битборд возможных ходов (B) можно получить из битборда начальной позиции (A) с помощью операций битового сдвига влево и побитового OR. Формула для расчёта выглядит так:
{line-numbers: false, format: text}
```
B = (A << 8) | (A << 16)
```

Если некоторые пешки двигались в ходе партии, мы можем получить, например, такой битборд (C) c их позицией:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 1 1 0 0 0
  0 0 0 0 0 0 1 0
  1 1 1 0 0 1 0 1
  0 0 0 0 0 0 0 0
```

В этом случае наша формула для расчёта возможных ходов не подходит. Нам нужно отличать пешки, которые ещё могут сходить на два поля вперед. Для этого наложим маску начальной позиции белых пешек на битборд C с помощью побитого AND. Эта маска представляет собой битборд A начальных позиций пешек. Так мы получим универсальную формулу расчёта возможных ходов для белых пешек на любой стадии партии:
{line-numbers: false, format: text}
```
B = (C << 8) | ((C & A) << 16)
```

Аналогично выводятся формулы расчёта возможных ходов для чёрных пешек, а также коней и королей обоих цветов.

Найти ходы [**скользящих фигур**](https://www.chessprogramming.org/Sliding_Pieces) (sliding pieces) сложнее. Скользящими фигурами называют слона, ладью и ферзя. Они могут ходить по диагоналям, вертикалям и горизонталям через всю доску, если их не блокируют другие фигуры. Это означает, что битовых сдвигов будет недостаточно. Требуются более сложные вычисления.

Для расчёта возможных ходов скользящих фигур нам нужно знать:

1. Тип фигуры.
2. Поле, где она находится.
3. Битборд с расположением фигур, которые её блокируют.

Рассмотрим алгоритм расчёта возможных ходов. Для примера найдём возможные ходы ладьи на поле e4 на запад. Для этого нам надо выполнить следующие шаги:

1. Рассчитать **луч** в каждом из восьми направлений для поля, которое занимает фигура. Луч представляет собой все поля по горизонтали, вертикали или диагонали от заданной клетки. Например, вот луч на запад из клетки e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Остальные семь направлений это: северо-запад, север, северо-восток, восток, юго-восток, юг, юго-запад.

2. Выбрать, какие лучи подходят для данного типа фигуры. Например, для ладьи нужны только лучи на север, восток, юг и запад.

3. Использовать лучи как маски для битборда блокирующих фигур. Так мы получаем все фигуры, которые стоят на пути данной фигуры на каждом направлении.

4. Найти первую блокирующую фигуру на каждом направлении. Для направлений на запад и юг нужно найти **наибольший индекс ненулевого бита** (most significant set bit). Эта операция называется [**bit scan forward**](https://www.chessprogramming.org/BitScan#Bitscan_forward). Для направлений на восток и север мы ищем **наименьший индекс не нулевого бита** (least significant set bit). Эта операция называется [**bit scan reverse**](https://www.chessprogramming.org/BitScan#Bitscan_reverse).

5. Рассчитать лучи от найденной первой блокирующей фигуры. Для нашего примера нам нужен только луч на запад. Используем его как маску для луча от ладьи на e4 на запад.

Так мы получили все клетки, которые ладья e4 атакует на западе. Следуя тому же алгоритму, мы находим клетки атаки ладьи для остальных сторон.

Клетки, которые атакует слон, находятся аналогично ладье. В случае ферзя нам просто надо скомбинировать результаты алгоритма поиска клеток для ладьи и слона.

Мы рассмотрели один из алгоритмов для расчёта ходов скользящих фигур. Он основан на bit scan операциях. Существуют и другие алгоритмы, например [**вращаемые битборды**](https://habr.com/ru/post/155045/).

Для расчёта ходов фигур передовые шахматные движки используют подход под названием [**магические битборды**](https://habr.com/ru/post/272815/). На современных процессорах он даёт наилучшую производительность.

Идея магических битбордов в том, чтобы однократно посчитать все доступные ходы для всех фигур с учётом всех возможных позиций блокирующих фигур. Для этого расчёта можно использовать алгоритм на операциях bit scan или любой другой. Результат сохраняется в память. Далее в процессе работы движок обращается к памяти и читает уже рассчитанные доступные ходы, которые соответствуют текущей позиции на доске. Такая техника однократного расчёта и сохранения результата в память для повторного использования называется **кешированием**.

Результат расчёта ходов фигур хранится в наборе **двумерных массивов**. Каждый массив, соответствует определённому типу фигур. Первый индекс массива — это поле, которое занимает фигура. Второй индекс — битборд с блокирующими фигурами.

Проблема с кешированием возможных ходов в том, что число всех возможных битбордов с блокирующими фигурами огромно. Оно равно 2^64^. Подсчитаем, сколько памяти нужно для хранения массива возможных ходов для фигур одного типа (например, ладей). Один битборд занимает 64 бита. Число возможных битбордов блокирующих фигур 2^64^. Число полей, которые может занимать атакующая фигура 64. Получаем массив размером 64*2^64^*64=2^76^ бит. Это примерно равно 10^10^ терабайт. На современных компьютерах столько памяти нет.

Подход магических битбордов решает задачу экономии памяти. Его идея в том, чтобы использовать **хэш-функцию**, которая вместо 64-битного битборда блокирующих фигур даст меньшее число.

Требования к хэш-функции такие:

1. Она должна работать быстрее, чем расчёт ходов скользящих фигур.

2. Для каждого битборда блокирующих фигур она даёт уникальное число на выходе. В противном случае возникнут [**коллизии**](https://ru.wikipedia.org/wiki/Коллизия_хеш-функции).

Рассмотрим пример. Предположим, что у нас есть такой битборд блокирующих фигур для ладьи на e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 1 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

В этом случае нас интересуют только поля по горизонтали 4 и вертикали e. Поля по краям доски можно проигнорировать, поскольку они не влияют на набор полей, которые атакует ладья.

Итак, мы получили 10 клеток, которые называются маской ладьи. Эта маска выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 1 1 1 0 1 1 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

Если наложить маску на битборд блокирующих фигур, мы получим только те биты, которые важны для расчёта ходов ладьи на e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
```

Наша хэш-функция должна опускать эти биты в начало битборда. Тогда мы получим число, меньшее, чем 64-битный битборд. Всего таких чисел 2^10^, что значительно меньше чем 2^64^.

Хэш-функция умножает биты для расчёта ходов ладьи на некоторое "магическое" число. В результате такого умножения биты группируются вместе. Следующая операция — побитовый сдвиг группы битов вправо. В результате все важные нам биты оказываются в начале 64-битного числа.

Вопрос в том, как находить "магические" числа, которые группируют нужные нам биты битборда? Эти числа находятся [**полным перебором**](https://ru.wikipedia.org/wiki/Полный_перебор) для ладьи и слона на каждой клетке. После нахождения этих чисел они сохраняются в коде движка. То есть повторно находить их не нужно.

Полный алгоритм поиска хода с помощью магического битборда выглядит так:

1. Наложить на битборд блокирующих фигур маску фигуры (например маску ладьи на e4).

2. Передать результат наложения маски на битборд в хэш-функцию.

3. Использовать результат хэш-функции как индекс двумерного массива с рассчитанными ранее ходами.

I> Идею магических битбордов наглядно объясняет следующее [видео](https://www.youtube.com/watch?v=K0rp1vXV3Ek).

#### 3.5.2.2.2 Оптимизации для альфа-бета отсечения

Механизм поиска Stockfish типичен для современных шахматных программ — это минимаксный поиск с альфа-бета отсечением. Однако, чтобы повысить его эффективность команда разработчиков применяет ряд дополнительных оптимизаций и эвристик. Их задача — отсечь максимально возможное число ветвей в дереве поиска, которые соответствуют малоперспективным ходам.

Чтобы повысить эффективность альфа-бета отсечения, необходимо сортировать рассматриваемые ходы. Из них в первую очередь надо проверять наиболее перспективные. Тогда большую часть остальных ходов удастся отсечь. Эта оптимизация называется [**move ordering**](https://www.chessprogramming.org/Move_Ordering) (сортировка ходов).

Stockfish реализует move ordering с помощью эвристик под названием **истории ходов**. Одна из них — это **continuation history** (история ответных ходов). Если Stockfish играет серию партий, он запоминает результаты своих ответных ходов на ходы противника. Например противник ходит конём на f6, а шахматный движок отвечает слоном на c4. Если ход оказался успешным, он получает положительную оценку. В противном случае оценка хода будет отрицательная. Далее когда противник ходит конём на f6 в другой позиции, Stockfish сортирует ход слоном на c4 в зависимости от его оценки по прошлым партиям.

Кроме истории ответных ходов Stockfish запоминает историю своих успешных последовательностей ходов. Например, в одной из сыгранных партий после хода конь f3, ход конь g5 был успешным. В этом случае движок даёт ходу конь g5 положительную оценку. В следующей партии поле хода конь f3 Stockfish рассмотрит последующий ход на g5 в первую очередь.

#### 3.5.2.4 Статическая оценка в Stockfish

### 3.5.3 AlphaZero

### 3.5.4 Leela Chess Zero
