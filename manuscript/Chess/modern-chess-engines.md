## 3.5 Современные шахматные движки

В конце 1990-х годов шахматные программы для ПК достигли уровня игры специализированных суперкомпьютеров наподобие Deep Blue. В результате новые разработки представляли собой именно программы. Компании и энтузиасты перестали проектировать специализированное шахматное аппаратное обеспечение, потому что это было слишком дорого.

Как настольные компьютеры достигли уровня игры суперкомпьютеров? Во-первых, значительно увеличилась мощность ПК. Большая часть таких компьютеров имела [IBM-совместимую](https://ru.wikipedia.org/wiki/IBM-PC-совместимый_компьютер) архитектуру и работала на процессорах от Intel. В 1993 году вышел процессор [Intel Pentium](https://ru.wikipedia.org/wiki/X86#Процессоры_Intel). К концу 1990-х его конструкция была усовершенствована. Так доступные ПК получили мощный и недорогой процессор. Его производительности хватало шахматным программам, чтобы просчитывать ходы на глубину, достаточную для качественной игры.

Вторая причина — это совершенствование самих шахматных программ. Основные улучшения касались оценочной функции. Благодаря им, программы качественнее оценивали позиции и выбирали более сильные ходы. Так же появились новые эвристики поиска. Это позволяло программам отбрасывать больше бесперспективных ходов и глубже просчитывать перспективные.

### 3.5.1 Шахматные движки

В 1993 году разработчик шахматных программ [Мартин Хирш](https://www.chessprogramming.org/Marty_Hirsch) ввёл термин [**шахматный движок**](https://ru.wikipedia.org/wiki/Шахматный_движок). Хирш сделал это чтобы отличать коммерческие шахматные игры от инструментов для профессиональных шахматистов.

Шахматные игры для ПК начали появляться в конце 1980-х годов. Примеры таких игр: [Chessmaster](https://en.wikipedia.org/wiki/Chessmaster) и [Battle Chess](https://en.wikipedia.org/wiki/Battle_Chess). Эти программы имели красивый графический интерфейс по меркам того времени. Например, в Battle Chess после каждого хода фигуры оживают и перемещаются на указанное поле доски. Если это поле уже занимает фигура противника, то происходит сражение. Шахматные игры предназначались для широкой аудитории. Они продавались по низкой цене и позиционировались как развлечения. Их уровень игры был достаточно низким: около 1600 пунктов Эло.

В отличие от игр, шахматные движки не имеют графического интерфейса. Они предназначены для анализа заданной позиций и поиска в ней наилучшего хода. Пользователь работает с такой программой через интерфейс командной строки. Шахматные движки изначально позиционировались как инструменты для профессионалов. С их помощью шахматисты анализировали партии и готовились к турнирам. Соответственно цена на шахматные движки была высокой, как и на любой профессиональный инструмент. Их уровень игры был намного выше, чем у шахматных игр.

Интерфейс командной строки был неудобен для большинства пользователей. Поэтому в начале 1990-х стали появляться программы для визуализации работы шахматного движка. Большинство современных программ визуализации коммерческие и достаточно дорогие. При этом наиболее сильные шахматные движки бесплатны и распространяются с [открытым исходным кодом](https://ru.wikipedia.org/wiki/Свободное_и_открытое_программное_обеспечение).

Все современные шахматные движки состоят из двух основных частей:

1. Механизм поиска.
2. Статическая оценка позиции.

Рассмотрим как реализованы эти части в самых сильных современных шахматных движках.

### 3.5.2 Stockfish

Stockfish считается сильнейшим современным шахматным движком. Он занимает первые строчки в рейтингах [Chess Engines Grand Tournament](http://www.cegt.net/40_40 Rating List/40_40 BestVersion/rangliste.html) (CEGT) и [Computer Chess Rating Lists](https://ccrl.chessdom.com/ccrl/4040/) (CCRL) за 2022 год.

Stockfish стал продолжением проекта шахматного движка Glaurung, разработанного Тордом Ромстадом. Первая версия Glaurung вышла в 2004 году. Это была программа для ПК с открытым исходным кодом. Разработчики портировали её более поздние версии на мобильные телефоны и планшеты.

В ноябре 2008 году Марко Костальба решил сделать [**форк**](https://ru.wikipedia.org/wiki/Форк) (от английского fork — вилка) кода Glaurung. Форком называется использование кодовой базы одного проекта в качестве старта для другого. Костальба назвал свой проект Stockfish. Первая версия этого движка вышла в ноябре 2008 года.

В течение 2008 года Glaurung и Stockfish развивались параллельно. Оба проекта распространялись с открытым исходным кодом. Поэтому их команды свободно обменивались идеями и усовершенствованиями алгоритмов.

В декабре 2008 года Ромстад выпустил последнюю версию Glaurung 2.2. Он решил прекратить поддержку своего проекта и присоединился к команде Stockfish. Причина решения была в том, что Stockfish на тот момент превзошёл Glaurung по уровню игры.

В 2011 году Ромстад вышел из проекта Stockfish. Он занялся разработкой шахматной программы для iOS. В 2014 году проект покинул Марко Костальба. Современная версия Stockfish развивается группой энтузиастов в которой около 20 человек.

#### 3.5.2.1 Система тестирования Fishtest

Stockfish достиг высокого уровня игры во многом благодаря специальной системе распределённых тестов под названием Fishtest. Её разработал Гэри Линскотт в 2013 году. Система Fishtest позволяет добровольцам выделять процессорное время своих компьютеров на тестирование шахматного движка. Суть тестирования заключается в многократных играх модифицированной версии Stockfish против последней стабильной версии. Только статистически значимые улучшения принимаются сообществом разработчиков.

Эффективность Fishtest можно оценить по первым 12 месяцам его использования. За это время уровень игры Stockfish вырос на 120 пунктов Эло. В результате этого прогресса Stockfish поднялся до лидирующих позиций во всех основных рейтингах шахматных движков.

К декабрю 2022 года благодаря системе Fishtest движок Stockfish сыграл около 5 миллиардов шахматных партий. На это ушло более 8650 лет процессорного времени.

#### 3.5.2.2 Механизм поиска в Stockfish

Поиск в Stockfish он основан на следующих алгоритмах:

* Магические битборды
* Минимаксный поиск
* Эвристика альфа-бета отсечения
* Оптимизация move ordering

Рассмотрим их подробнее.

#### 3.5.2.2.1 Магические битборды

Чтобы начать поиск, шахматному движку нужно получить список возможных ходов, допустимых правилами. Решение этой задачи зависит от формата, в котором движок хранит состояние шахматной доски. Наиболее эффективным форматом для современных компьютеров считаются [**битборды**](https://hmn.wiki/ru/Bitboard). Применив их, можно воспользоваться механизмом под названием [**магические битборды**](https://www.chessprogramming.org/Magic_Bitboards). Он даст нам все доступные ходы для всех фигур на поле. Разберёмся, как это работает.

Впервые на практике битборды использовал Кристофер Стрейч в своей программе для игры в шашки в 1952 году. Битборды в шахматах впервые применили разработчики советской шахматной программы [Каисса](https://ru.wikipedia.org/wiki/Каисса_(программа)) в конце 1960-х годов.

Идея битбордов в том, чтобы оптимизировать обработку состояния доски. Битборд представляет собой одно 64-разрядное число. Каждый бит этого числа соответствует одному из 64-х полей шахматной доски. Если бит равен единице, поле занято фигурой. Если бит равен нулю, то поле свободно.

Чтобы сохранить состояние всех фигур на шахматной доске, нужно минимум восемь битбордов. По одному на каждый из шести типов фигур: пешки, ладьи, кони, слоны, короли, ферзи. Два битборда нужны для определения цвета фигуры на каждом поле: черный или белый. На практике обычно применяется набор из 12 битбордов: по одному для каждого типа фигур, каждого цвета. Такой подход удобнее для расчётов возможных ходов.

Рассмотрим пример. Битборд для начальной позиции белых пешек наглядно можно представить так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
```

На самом деле, в памяти компьютера этот битборд хранится как 64-разрядное число в двоичной системе счисления так:
{line-numbers: false, format: text}
```
0000000000000000000000000000000000000000000000001111111100000000
```

Аналогично, битборд для двух чёрных коней в начальной позиции выглядит так:
{line-numbers: false, format: text}
```
  0 1 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Ему соответствует такое 64-разрядное число в памяти:
{line-numbers: false, format: text}
```
0100001000000000000000000000000000000000000000000000000000000000
```

Какие преимущества дают битборды? Современные процессоры оперируют 64-разрядными регистрами. Это означает, что один битборд целиком помещается в один регистр. Также любую проверку или действие над числом процессор выполняет за одну операцию. Одна операция длится один [**такт**](https://hardwareguide.ru/процессор/частота-процессора/). Тактовая частота современных процессоров достигает 4 гигагерц. Это соответствует 4*10^6^ операций в секунду. Благодаря битбордам, современные шахматные программы достигают очень высокой производительности.

Битборды хранят состояния доски. Но сами по себе они не дают все доступные ходы для каждой фигуры. Эти ходы можно посчитать с помощью битовых операций. Для пешек, коней и королей их легко рассчитать с помощью битовых сдвигов.

Вот расчёт ходов для белых пешек в начальной позиции. Все пешки могут пойти на одно поле вперёд. В этом случае битовая маска допустимых ходов выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Кроме этого каждая пешка из начальной позиции может пойти на два поля вперёд. Это даст такую битовую маску:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Если мы наложим две битовые маски с допустимыми ходами друг на друга, то получим такой битборд:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Этот битборд возможных ходов (B) можно получить из битборда начальной позиции (A) с помощью операций битового сдвига влево и побитового OR. Формула для расчёта выглядит так:
{line-numbers: false, format: text}
```
B = (A << 8) | (A << 16)
```

Если некоторые пешки двигались в ходе партии, мы можем получить, например, такой битборд (C) c их позицией:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 1 1 0 0 0
  0 0 0 0 0 0 1 0
  1 1 1 0 0 1 0 1
  0 0 0 0 0 0 0 0
```

В этом случае наша формула для расчёта возможных ходов не подходит. Нам нужно отличать пешки, которые ещё могут сходить на два поля вперед. Для этого наложим маску начальной позиции белых пешек на битборд C с помощью побитого AND. Эта маска представляет собой битборд A начальных позиций пешек. Так мы получим универсальную формулу расчёта возможных ходов для белых пешек на любой стадии партии:
{line-numbers: false, format: text}
```
B = (C << 8) | ((C & A) << 16)
```

Аналогично выводятся формулы расчёта возможных ходов для чёрных пешек, а также коней и королей обоих цветов.

Найти ходы [**скользящих фигур**](https://www.chessprogramming.org/Sliding_Pieces) (sliding pieces) сложнее. Скользящими фигурами называют слона, ладью и ферзя. Они могут ходить по диагоналям, вертикалям и горизонталям через всю доску, если их не блокируют другие фигуры. Это означает, что битовых сдвигов будет недостаточно. Требуются более сложные вычисления.

Чтобы получить доступные ходы для скользящих фигур, используют один из двух подходов: [**вращаемые битборды**](https://habr.com/ru/post/155045/) или [**магические битборды**](https://habr.com/ru/post/272815/). На современных процессорах магические битборды дают лучшую производительность. Поэтому все шахматные движки сегодня используют именно их.

Идея магических битбордов в **кешировании** всех доступных ходов для всех фигур с учётом всех возможных позиций блокирующих фигур. Кеширование означает однократный рассчёт и сохранение результата в памяти для повторного использования. Результат кеширования сохраняется в двумерных массивах. Каждый массив, соответствует одному типу фигур. Первый индекс массива — это поле, которое занимает фигура. Второй индекс — битборд с блокирующими фигурами.

Проблема с кешированием в том, что количество битбордов с блокирующими фигурами огромно. Оно равно 2^64^. Чтобы подсчитать необходимую память, умножим 2^64^ на 64 и получим 2^76^ бит или 2^36^ терабайт. Подход магических битбордов решает задачу экономии памяти. Его идея в том, чтобы использовать хэш-функцию, которая вместо 64-битного битборда блокирующих фигур даст меньшее число. Такое преобразование возможно, потому что в битборде блокирующих фигур нас интересует только первая блокирующая фигура на каждом направлении. Фигуры за ней не важны для расчёта доступных ходов.

I> Идею магических битбордов наглядно объясняет следующее [видео](https://www.youtube.com/watch?v=K0rp1vXV3Ek).

#### 3.5.2.2.2 Оптимизации для альфа-бета отсечения

Механизм поиска Stockfish типичен для современных шахматных программ — это минимаксный поиск с альфа-бета отсечением. Однако, чтобы повысить его эффективность команда разработчиков применяет ряд дополнительных оптимизаций и эвристик. Их задача — отсечь максимально возможное число ветвей в дереве поиска, которые соответствуют малоперспективным ходам.

Чтобы повысить эффективность альфа-бета отсечения, необходимо сортировать рассматриваемые ходы. Из них в первую очередь надо проверять наиболее перспективные. Тогда большую часть остальных ходов удастся отсечь. Эта оптимизация называется [**move ordering**](https://www.chessprogramming.org/Move_Ordering) (сортировка ходов).

Stockfish реализует move ordering с помощью эвристик под названием **истории ходов**. Одна из них — это **continuation history** (история ответных ходов). Если Stockfish играет серию партий, он запоминает результаты своих ответных ходов на ходы противника. Например противник ходит конём на f6, а шахматный движок отвечает слоном на c4. Если ход оказался успешным, он получает положительную оценку. В противном случае оценка хода будет отрицательная. Далее когда противник ходит конём на f6 в другой позиции, Stockfish сортирует ход слоном на c4 в зависимости от его оценки по прошлым партиям.

Кроме истории ответных ходов Stockfish запоминает историю своих успешных последовательностей ходов. Например, в одной из сыгранных партий после хода конь f3, ход конь g5 был успешным. В этом случае движок даёт ходу конь g5 положительную оценку. В следующей партии поле хода конь f3 Stockfish рассмотрит последующий ход на g5 в первую очередь.

#### 3.5.2.4 Статическая оценка в Stockfish

### 3.5.3 AlphaZero

### 3.5.4 Leela Chess Zero
