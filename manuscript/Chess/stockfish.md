## 3.5 Stockfish

Все шахматные движки состоят из следующих основных частей:

1. Генератор ходов
2. Функция оценки позиции
3. Алгоритм поиска
4. Дебютная книга
5. Таблицы эндшпилей.

Игровую силу программы во многом определяют генератор ходов, функция оценки и алгоритм поиска. Мы рассмотрим, как устроены эти механизмы в самых сильных современных шахматных движках.

### 3.5.1 История Stockfish

На сегодня Stockfish считается сильнейшим шахматным движком. Он занимает первые строчки в рейтингах [Chess Engines Grand Tournament](http://www.cegt.net/40_40 Rating List/40_40 BestVersion/rangliste.html) (CEGT) и [Computer Chess Rating Lists](https://ccrl.chessdom.com/ccrl/4040/) (CCRL).

Stockfish вырос из проекта шахматного движка Glaurung, который разработал норвежский программист Торд Ромстад. Первая версия Glaurung вышла в 2004 году. Это была программа для ПК с интерфейсом командной строки и открытым исходным кодом. Позднее к Торду Ромстаду присоединились другие энтузиасты. Они портировали более поздние версии Glaurung на мобильные телефоны и планшеты.

В 2008 году итальянский программист Марко Костальба разрабатывал новый шахматный движок. Чтобы не начинать с нуля, он взял код Glaurung как основу для своего проекта. Для этого итальянец сделал форк Glaurung. [**Форком**](https://ru.wikipedia.org/wiki/Форк) (от английского fork — вилка) называется использование кодовой базы одного проекта в качестве старта для другого. Марко Костальба назвал свой проект Stockfish. Первая версия этого движка вышла в ноябре 2008 года.

В течение 2008 года Glaurung и Stockfish развивались параллельно. Оба проекта распространялись с открытым исходным кодом. Их команды свободно обменивались идеями по улучшению алгоритма поиска и оценочной функции.

В декабре 2008 года Торд Ромстад выпустил последнюю версию Glaurung 2.2. После этого он прекратил поддержку своего проекта и присоединился к команде Stockfish. На тот момент Stockfish превзошёл Glaurung по уровню игры. Возможно, именно поэтому Торд Ромстад оставил свой проект.

В 2011 году Торд Ромстад вышел из проекта Stockfish. Он занялся разработкой шахматной программы для iOS. В 2014 году проект покинул Марко Костальба. Современная версия Stockfish развивается группой энтузиастов. Сейчас в команде активных разработчиков около 20 человек.

### 3.5.2 Система тестирования Fishtest

Stockfish достиг высокого уровня игры благодаря системе автоматизированных распределённых тестов под названием Fishtest. Её разработал канадец Гэри Линскотт в 2013 году. Система оценивает каждое изменение, которое делают разработчики Stockfish. Это гарантирует, что любой патч улучшает производительность движка, а не ухудшает её.

Тестирование изменения в Fishtest происходит в несколько этапов:

1. Разработчик готовит изменение и предлагает его для тестирования. Это может быть корректировка функции оценки, алгоритма поиска или других механизмов движка, которые улучшают его игровую силу.

2. Сервер Fishtest получает изменение и добавляет его в очередь на тестирование. Состояние текущей очереди и результаты тестирования каждого изменения доступны через веб-интерфейс.

3. Любой доброволец запускает на своём компьютере программу-клиент Fishtest Worker.

4. Fishtest Worker автоматически загружает задачи тестирования с сервера Fishtest. Задачи представляют собой шахматные партии между версией Stockfish с изменением и последней стабильной версией.

5. Fishtest Worker играет тысячи партий с быстрым контролем времени между сравниваемыми версиями Stockfish.

6. Fishtest Worker отправляет результаты сыгранных партий на сервер.

7. Сервер Stockfish определяет, улучшает ли тестируемое изменение производительность движка. Для этого применяется статистический метод [SPRT](https://en.wikipedia.org/wiki/Sequential_probability_ratio_test) (Sequential Probability Ratio Test).

8. Если результаты превышают статистическое пороговое значение, изменение интегрируется в кодовую базу Stockfish. Пороговое значение гарантирует, что модифицированная версия движка выигрывает больше игр, чем стабильная версия. Если результаты ниже порога, изменение отклоняется.

Система Fishtest позволяет быстро и надёжно проверять качество всех предлагаемых изменений. Эффективность её работы можно оценить по первым 12 месяцам использования. За это время уровень игры Stockfish вырос на 120 пунктов Эло. Такое усиление подняло Stockfish до лидирующих позиций в рейтинге шахматных движков.

Благодаря системе Fishtest, к декабрю 2022 года разные версии Stockfish сыграли друг с другом около 5 миллиардов партий. На это ушло более 8650 лет процессорного времени. Никакая система тестирования, запускаемая на компьютерах разработчиков, не может дать сопоставимый результат.

### 3.5.3 Генератор ходов

Генератор ходов создаёт список всех допустимых ходов для указанного игрока в заданной позиции на доске. При составлении этого списка генератор учитывает правила шахматной игры и особые условия. К таким условиям относятся: шах, мат, пат, рокировка, взятие на проходе и проведение пешки.

Генератор ходов в современных шахматных движках работает по следующему алгоритму:

1. Определить расположение на доске всех фигур игрока, который делает ход.

2. Для каждого типа фигур применить свои правила перемещения.

3. Проверить специальные условия (шах, мат, рокировка и т.д.).

4. Составить список допустимых ходов.

Эффективность генератора ходов напрямую влияет на общую производительность шахматного движка. Поэтому разработчики уделяют особое внимание оптимизации этого механизма.

#### 3.5.3.1 Битборды

Скорость генерации ходов зависит от формата, в котором движок хранит состояние шахматной доски. Наиболее эффективным форматом для современных ПК считаются [**битборды**](https://hmn.wiki/ru/Bitboard) (bitboard).

Идея битбордов совсем не нова. В 1952 году британский учёный Кристофер Стрейч разработал первую программу для игры в шашки. В ней учёный впервые применил битборды на практике. В шахматах первыми использовали битборды разработчики советской шахматной программы [Каисса](https://ru.wikipedia.org/wiki/Каисса_(программа)) в конце 1960-х годов.

Битборд представляет собой одно 64-разрядное число. Всего на шахматной доске 64 поля. Обратите внимание, что число полей равно разрядности битборда. Идея заключается в том, чтобы представить состояние каждого поля одним битом 64-разрядного числа. Если бит равен единице, поле занято фигурой. Если бит равен нулю, то поле свободно.

Как с помощью битборда сохранить состояние всех фигур на шахматной доске? Всего есть шесть типов фигур: пешки, ладьи, кони, слоны, короли и ферзи. Для каждого типа нужен отдельный битборд. У каждой фигуры есть цвет: белый или чёрный. Чтобы его учесть, можно ввести ещё два битборда. Первый указывает положение всех белых фигур независимо от их типа, а второй — положение всех чёрных. Итого в сумме получается восемь битбордов. На практике обычно используют набор из 12 битбордов: по одному для каждого типа фигур, каждого цвета. То есть, белые пешки имеют свой битборд, чёрные пешки — свой и т.д. Такой подход эффективнее для генерации допустимых ходов.

Рассмотрим пару примеров. Представим битборд для начальной позиции белых пешек в наглядном виде:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
```

Такое представление удобно для человека. Но компьютер хранит этот битборд в памяти как 64-разрядное число в двоичной системе счисления. Оно выглядит следующим образом:
{line-numbers: false, format: text}
```
0000000000000000000000000000000000000000000000001111111100000000
```

Битборд для двух чёрных коней в начальной позиции выглядит так:
{line-numbers: false, format: text}
```
  0 1 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Компьютер хранит его в памяти в виде следующего числа:
{line-numbers: false, format: text}
```
0100001000000000000000000000000000000000000000000000000000000000
```

На первый взгляд, битборд кажется неудобными для работы. Человеку трудно его прочитать в том виде, в котором его хранит компьютер. Тем не менее у битбордов есть огромные преимущества перед другими форматами. Во-первых, все современные процессоры для ПК оперируют 64-разрядными регистрами. Это означает, что один битборд целиком помещается в один регистр. Побитовые операции над регистрами обычно выполняются за один [**такт**](https://hardwareguide.ru/процессор/частота-процессора/) процессора. Тактовая частота достигает 4 гигагерц и выше. Это означает, что в секунду выполняется более 4*10^6^ операций. Таким образом битборды обрабатываются намного быстрее любых аналогичных форматов представления доски.

Во-вторых, битборды позволяют обрабатывать несколько фигур и полей за одну единственную побитовую операцию. Например, одна операция может оценить пути атаки всех фигур одного типа по всем направлениям.

В-третьих, битборд — это очень компактное представление доски. Компактность снижает использование памяти. Поэтому все битборды с состоянием доски обычно помещаются в кэш быстрого доступа процессора. Это сводит к минимуму задержки доступа к оперативной памяти.

Битборды хранят текущее расположение фигур на доске. Это исходные данные для генерации допустимых ходов. Сами ходы нужно рассчитывать с помощью битовых операций. Для пешек, коней и королей это делается с помощью битовых сдвигов.

Рассчитаем все ходы для белых пешек в начальной позиции. Во-первых, они могут пойти на одно поле вперёд. В этом случае битовая маска допустимых ходов выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Во-вторых, каждая пешка из начальной позиции может пойти на два поля вперёд. Это даст следующую битовую маску:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Применим побитовое OR к двум маскам допустимых ходов. Получим следующий битборд:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Для простоты мы не рассматриваем взятия. Обозначим битборд с начальной позицией как A, а битборд с допустимыми ходами — как B. Тогда B получается из A с помощью двух операций битового сдвига влево и побитового OR между ними. Формула для расчёта выглядит так:
{line-numbers: false, format: text}
```
B = (A << 8) | (A << 16)
```

Допустим, что некоторые белые пешки уже двигались. В результате получился следующий битборд с их позициями:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 1 1 0 0 0
  0 0 0 0 0 0 1 0
  1 1 1 0 0 1 0 1
  0 0 0 0 0 0 0 0
```

Обозначим этот битборд как C. Битборд с допустимыми ходами пешек в такой позиции выглядит следующим образом:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 1 1 0 0 0
  1 1 1 0 0 1 1 1
  1 1 1 0 0 1 0 1
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Обозначим этот битборд как D. Для его расчёта формула с двумя битовыми сдвигами влево и OR не подходит. Проблема в том, что теперь не все пешки могут сходить на два поля вперёд. Нам надо как-то их отличать. Применим побитовое AND к маске начальной позиции белых пешек и битборду C. Маска представляет собой битборд A начальных позиций пешек. Так мы получим универсальную формулу расчёта возможных ходов для белых пешек на любой стадии партии:
{line-numbers: false, format: text}
```
D = (C << 8) | ((C & A) << 16)
```

Аналогично выводятся формулы для расчёта допустимых ходов чёрных пешек, коней и королей обоих цветов.

Вычислить ходы скользящих фигур сложнее. [**Скользящими фигурами**](https://www.chessprogramming.org/Sliding_Pieces) (sliding pieces) называют слона, ладью и ферзя. Они ходят по диагоналям, вертикалям и горизонталям через всю доску, если их не блокируют другие фигуры. Это означает, что для расчёта ходов битовых сдвигов теперь недостаточно. Нужны более сложные вычисления.

Чтобы найти допустимые ходы скользящей фигуры, нужно знать следующее:

1. Тип фигуры.
2. Поле, где она находится.
3. Битборд с расположением фигур, которые её блокируют.

Для примера найдём допустимые ходы ладьи. Предположим, что ладья занимает поле e4. Алгоритм расчёта выглядит так:

1. Рассчитать луч в каждом из восьми направлений для поля, которое занимает фигура. **Луч** представляет собой все поля по горизонтали, вертикали или диагонали от заданной клетки. Например, луч на запад из клетки e4 выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 1 1 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Остальные семь направлений это: северо-запад, север, северо-восток, восток, юго-восток, юг, юго-запад.

2. Из восьми лучей выбрать только те, которые подходят для данного типа фигуры. Например, для ладьи нужны лучи на север, восток, юг и запад.

3. Применить побитовое AND к каждому лучу и битборду блокирующих фигур. Так мы получим все фигуры, которые стоят на пути данной фигуры на каждом направлении. Допустим, что битборд блокирующих фигур выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

4. Найти первую блокирующую фигуру на каждом направлении. Для направлений на запад и юг нужно найти **наибольший индекс ненулевого бита** (most significant set bit). Эта операция называется **битовое сканирование вперед** ([bit scan forward](https://www.chessprogramming.org/BitScan#Bitscan_forward)). Для направлений на восток и север надо найти **наименьший индекс не нулевого бита** (least significant set bit). Эта операция называется **битовое сканирование назад** ([bit scan reverse](https://www.chessprogramming.org/BitScan#Bitscan_reverse)). Для нашего примера первая блокирующая фигура будет такой:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 1 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

5. Рассчитать лучи от найденной первой блокирующей фигуры. Например, если мы рассчитываем все ходы ладьи e4 на запад, нам нужен луч блокирующей фигуры на запад. Он выглядит так:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

6. Инвертируем луч блокирующей фигуры. Для нашего примера это даст следующую маску:
{line-numbers: false, format: text}
```
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  0 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
  1 1 1 1 1 1 1 1
```

7. Применим побитовое AND к маске инвертированного луча блокирующей фигуры и лучу с ходами ладьи e4 на запад. Получим битборд всех полей, которые атакует эта ладья на западе:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 1 1 1 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
```

Этот же алгоритм находит битборды с полями, которые атакует ладья в остальные три стороны. Аналогично можно найти поля, которые атакует слон. Ферзь ходит как слон и ладья одновременно. Поэтому для него достаточно скомбинировать результаты алгоритма для ладьи и слона.

Мы рассмотрели один из алгоритмов для расчёта ходов скользящих фигур. Он основан на операциях битового сканирования (bit scan). Есть и альтернативные алгоритмы, например [**вращаемые битборды**](https://habr.com/ru/post/155045/) и магические битборды.

#### 3.5.3.2 Магические битборды

Метод [**магических битбордов**](https://habr.com/ru/post/272815/) даёт лучшую производительность на современных процессорах. Его используют самые мощные шахматные движки, в том числе и Stockfish. Идея магических битбордов заключается в кэшировании. **Кэширование** (caching) — это однократное вычисление некоторого результата и сохранение его в памяти для повторного использования.

Шахматный движок работает с магическими битбордами по следующему алгоритму:

1. Пользователь запускает шахматный движок.

2. Сразу после старта движок рассчитывает все допустимые ходы скользящих фигур на всех полях с учётом всех возможных позиций блокирующих фигур. Для этого он использует операции битового сканирования или любой другой метод.

3. Движок сохраняет результаты расчёта в оперативную память (RAM) компьютера.

4. Когда движку нужно сгенерировать ходы в какой-то позиции на доске, он обращается к RAM и читает нужные ему допустимые ходы.

Результат расчёта ходов хранится в RAM как набор **двумерных массивов**. Каждый массив соответствует фигурам одного типа. Первый индекс массива — это поле, которое занимает фигура. Второй индекс — битборд с блокирующими фигурами. При этом цвет фигур не важен. Элемент массива — это битборд со всеми допустимыми ходами скользящей фигуры.

Формат двумерных массивов создаёт проблему. Дело в том, что число всех возможных битбордов с блокирующими фигурами огромно. Оно равно 2^64^. Чтобы сохранить массив возможных ходов для фигур одного типа (например, ладей), нужен следующий объём памяти. Один битборд занимает 64 бита. Число возможных битбордов блокирующих фигур равно 2^64^. Число полей, которые может занимать атакующая фигура равно 64. Получаем массив размером 64×2^64^×64=2^76^ бит. Это примерно равно 10^10^ терабайт. Даже на современных суперкомпьютерах нет такого объёма оперативной памяти.

Метод магических битбордов решает задачу экономии памяти. Он предлагает формат упаковки 64-х битных битбордов в числа с меньшей разрядностью. Эту упаковку выполняет **хэш-функция**. Она должна удовлетворять следующим требованиям:

1. Работает быстрее, чем расчёт ходов скользящих фигур любым доступным методом.

2. Даёт на выходе уникальное число для любого возможного битборда блокирующих фигур.

Если нарушается первое требование, то пропадает смысл кэширования. Движку будет быстрее считать допустимые ходы по мере их необходимости. Если нарушается второе требование, возникнут коллизии. Из-за них движок не сможет различать разные наборы блокирующих фигур.

I> [**Коллизия**](https://ru.wikipedia.org/wiki/Коллизия_хеш-функции) — это ситуация, когда на разные входные данные хэш-функция возвращает одно и то же значение.

Рассмотрим пример упаковки битборда с помощью хэш-функции. Предположим, что для ладьи на e4 есть следующий битборд блокирующих фигур:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 1 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 1 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

Сама ладья обозначается буквой r для удобства. В этом битборде нас интересуют только поля по горизонтали 4 и вертикали e. Те из них, которые находятся по краям доски, можно игнорировать. Они никак не влияют на допустимые ходы ладьи.

Поля по горизонтали 4 и вертикали e, кроме самых крайних, называются **маской ладьи**. Она выглядит следующим образом:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 1 1 1 0 1 1 0
  0 0 0 0 1 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 1 0
```

Применим операцию побитого AND к маске ладьи и битборду блокирующих фигур. Мы получим битборд только с теми полями, которые важны для расчёта ходов ладьи на e4:
{line-numbers: false, format: text}
```
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0
  1 1 0 0 r 0 1 0
  0 0 0 0 0 0 0 0
  0 0 0 0 1 0 0 0
  0 0 0 0 0 0 0 0
```

Хэш-функция должна сдвигать биты важных полей в начало битборда. Тогда она вернёт число с разрядностью меньше 64-х. Если сдвигать биты важных полей для всех возможных ходов ладей и слонов из всех полей доски, получим 2^10^ возможных чисел. Обратите внимание, что 2^10^ гораздо меньше чем 2^64^. Теперь двумерные массивы с кэшированными допустимыми ходами помещаются в RAM. Они займут всего 64×2^10^×64=4194304 бит или 512 Кбайт.

Как устроена хэш-функция? Она умножает биты важных полей для расчёта ходов фигуры на некоторое "магическое" число. В результате умножения биты группируются вместе. Следующая операция функции — побитовый сдвиг группы битов вправо. В результате все биты важных полей оказываются в начале 64-битного числа.

Следующий вопрос: как находить "магические" числа, которые группируют важные биты битборда? Эти числа находятся [**полным перебором**](https://ru.wikipedia.org/wiki/Полный_перебор) для ладьи и слона на каждой клетке доски. Когда перебор находит эти числа, они сохраняются в коде движка. Поэтому движку не надо искать их заново на каждом старте.

Алгоритм расчёта второго индекса двумерного массива с кэшем допустимых ходов фигуры выглядит так:

1. Применить побитовое AND к битборду блокирующих фигур в текущей позиции и маске фигуры (например, к маске ладьи на e4).

2. Передать результат операции AND на вход хэш-функции.

3. Использовать результат хэш-функции как второй индекс двумерного массива.

Идею магических битбордов хорошо демонстрирует следующее [видео](https://www.youtube.com/watch?v=K0rp1vXV3Ek).

### 3.5.4 Алгоритм поиска

Механизм поиска Stockfish типичен для современных шахматных движков. Он основан на минимаксном алгоритме. Чтобы его ускорить, движок применяет ряд эвристик. Прежде всего это альфа-бета отсечение. Кроме него есть и более сложные эвристики.

Мы подробно рассмотрели работу алгоритма минимакс в разделе 2.5.2. Альфа-бета отсечение подробно разбирается в разделе 2.5.3. Алгоритм применения минимакс в шахматах описывает стратегия А Клода Шеннона. Мы говорили о ней в разделе 3.1.3.

Здесь мы рассмотрим, как именно взаимодействуют три основные части шахматного движка:

1. Генератор ходов
2. Функция оценки позиции
3. Алгоритм поиска.

Связующим звеном является итеративный алгоритм поиска. Именно он в ходе своей работы вызывает генератор ходов и функцию оценки. Моменты их вызова зависят от характера проверяемой позиции фигур на доске.

Основные шаги алгоритма поиска следующие:

1. Движок запускает алгоритм поиска для текущей позиции фигур на доске.

2. Алгоритм поиска вызывает генератор ходов и передаёт ему текущую позицию.

3. Генератор ходов возвращает список всех допустимых ходов в текущей позиции.

4. Алгоритм поиска проходит по каждому сгенерированному ходу и получает набор новых позиций фигур на доске.

5. Алгоритм поиска проверяет характер каждой полученной позиции. Основные проверки следующие:

* Достигнута ли максимальная глубина анализа? Максимальная глубина анализа — это тонко подобранный параметр, который хранится в коде движка.

* Является ли позиция терминальным узлом дерева игры? К таким позициям относится мат, пат, ничья.

* Является ли позиция спокойной? Это означает, что в ней нет хода, который резко меняет соотношение сил.

6. Если любая из проверок позиции дала положительный результат (например, белые поставили мат), алгоритм поиска вызывает функцию оценки для этой позиции. Затем алгоритм возвращается назад по дереву игры к ещё не проверенным позициям.

7. Если все проверки дали отрицательный результат, алгоритм поиска возвращается к шагу 2. Он снова вызывает генератор ходов для текущей позиции и обрабатывает дерево игры дальше вглубь.

8. На основе оценок позиций алгоритм поиска выполняет альфа-бета отсечение.

9. Когда все позиции на максимальной глубине анализа проверены, алгоритм поиска выбирает лучший ход по методу минимакс.

Этому алгоритму поиска следует большинство современных шахматных движков. Отличительная особенность Stockfish не в этом алгоритме, а в дополнительных эвристиках для его ускорения. Именно они обеспечивают высокую производительность и непревзойдённую силу игры Stockfish. Рассмотрим самые важные из этих эвристик.

#### 3.5.4.1 Сортировка ходов

>>> REWRITE

Эвристика альфа-бета отсечения не гарантирует высокую эффективность. Если в первую очередь движок проверяет посредственные ходы обеих сторон, то обрезание веток поиска будет происходить слишком поздно. Из-за этого будет обрезано только незначительное число веток и выигрыш в скорости поиска по сравнению с минимаксом будет незначительный.

Чтобы повысить эффективность альфа-бета отсечения, необходимо сортировать рассматриваемые ходы. В первую очередь надо проверять наиболее перспективные из них. Тогда большую часть посредственных ходов удастся отсечь. Эта оптимизация называется [**move ordering**](https://www.chessprogramming.org/Move_Ordering) (сортировка ходов) — сортировка ходов по их перспективности с учётом всей доступной на данный момент информации.

Stockfish реализует move ordering с помощью ряда эвристик под названием **истории ходов**. Всего таких эвристик шесть штук. Одна из них — это **continuation history** (история ответных ходов). Если Stockfish играет серию партий, он запоминает результаты своих ответных ходов на ходы противника. Например противник ходит конём на f6, а шахматный движок отвечает слоном на c4. Если ход оказался успешным, он получает положительную оценку. В противном случае оценка хода будет отрицательная. Далее когда противник ходит конём на f6 в другой позиции, Stockfish сортирует свой ход слоном на c4 в зависимости от его оценки по прошлым партиям.

Кроме истории ответных ходов Stockfish запоминает историю своих успешных последовательностей ходов. Например, в одной из сыгранных партий движок сходил конь f3. Его следующим ходом был конь g5. Статическая оценка дала ему высокий результат. Stockfish запоминает это. В другой партии после хода конь f3 движок рассмотрит последующий ход конь g5 в первую очередь.

#### 3.5.4.2 Выборочный поиск

Чтобы ускорить минимаксный поиск с альфа-бета отсечением, Stockfish использует разные эвристики **выборочного поиска** ([selective search](https://www.chessprogramming.org/Selectivity)). Такой поиск включает в себя три техники:

1. **Продление** ([extension](https://www.chessprogramming.org/Extensions)) — продолжение просчёта вглубь для перспективного хода.

2. **Сокращение** ([reduction](https://www.chessprogramming.org/Reductions)) — просчёт малоперспективного хода на меньшую глубину, чем обычно.

3. **Отсечение** ([pruning](https://www.chessprogramming.org/Pruning)) — удаление ветвей дерева поиска без их просчёта.

Продление выполняют в следующих случаях:

1. Произошло взятие.
2. Произошёл шах.
3. Ход единственный.
4. Ход гораздо лучше альтернатив.
5. При наличии проходной пешки.

Продления нужны, чтобы бороться с эффектом горизонта. Этот эффект приводит к неверной оценки позиции, когда движок достигает максимальной глубины поиска. Причина ошибки в том, что последующие не просчитанные ходы оппонента кардинально меняют позицию.

Рассмотрим пример. Допустим, что на максимальной глубине поиска движок видит взятие вражеского ферзя. После взятия оценка позиции очень высокая. Но на следующий ход противник может взять ферзя в ответ: то есть происходит размен. В результате позиция снова становится равная. Если ответное взятие оказалось за пределами глубины поиска — происходит эффект горизонта. Движок будет выбирать ходы, которые ведут его к взятию ферзя, пока ответное взятие не попадёт в максимальную глубину поиска. Тогда программа "увидит" размен и будет вынуждена полностью менять свой план.

Продления выполняются до спокойной позиции. В такой позиции нет взятий, шахов и единственных ходов. Эта техника называется **поиск спокойствия** ([quiescence search](https://www.chessprogramming.org/Quiescence_Search)). Спокойная позиция гарантирует, что у противника нет способа кардинально изменить позицию и её оценку для движка.

Сокращения и отсечения нужны, чтобы понизить коэффициент ветвления. В Stockfish этот коэффициент в среднем равен 1.7 или 1.8. На протяжении партии у каждой стороны есть около 30 возможных ходов в каждой позиции. Это означает, что движок отбрасывает 28 потенциальных ходов и рассматривает из них только 2. Если учесть просчёт ходов вглубь, то окажется что Stockfish отбрасывает 90% всего дерева поиска. Такая оптимизация значительно ускоряет поиск. Её недостаток в том, что программа может отсекать хорошие ходы, которые ведут к сильным комбинациям или мату.

Stockfish использует следующие алгоритмы сокращений:

1. [Late Move Reductions](https://www.chessprogramming.org/Late_Move_Reductions) (LMR) — уменьшение глубины поиска для ходов, которые алгоритм сортировки move ordering поместил в конец списка. В конце списка оказываются малоперспективные ходы, поэтому движок просчитывает их на меньшую глубину.

2. [Fail-High Reductions](https://www.chessprogramming.org/Fail-High_Reductions) (FHR) — уменьшение глубины поиска в спокойных позициях, когда на стороне делающего ход игрока есть существенное преимущество. [**Fail-high node**](https://www.chessprogramming.org/Fail-High) (или Cut-node) означает позицию, которая слишком хорошая для одной из сторон. При этом алгоритм поиска уже нашел ход оппонента, который предотвращает эту позицию. Вероятнее всего этот ход будет сделан, поэтому нет смысла просчитывать позицию глубоко. В этом случае происходит [beta-cutoff](https://www.chessprogramming.org/Beta-Cutoff), то есть отсечение по значению β.

3. [Null Move Reductions](https://www.chessprogramming.org/Null_Move_Reductions) (NMR). Допустим, что у одной из сторон есть существенное преимущество в рассматриваемой позиции. Если просто передать ход оппоненту и оценка позиции всё равно останется высокой, глубину поиска можно сократить. Передача ходу оппоненту называется [**null move**](https://www.chessprogramming.org/Null_Move). Такая передача запрещена правилами шахмат, но полезна для оптимизаций поиска.

Stockfish использует такие методы отсечения: 

1. [Mate Distance Pruning](https://www.chessprogramming.org/Mate_Distance_Pruning) работает, когда движок нашёл форсированный мат в несколько ходов. После этого он отсекает поддеревья, в которых невозможен мат за меньшее число ходов. Другими словами, когда мат найден, программа просчитывает самый короткий путь к нему.

2. [Futility pruning](https://www.chessprogramming.org/Futility_Pruning) выполняется за один ход до достижения максимальной глубины поиска. Эвристика отсекает узлы, оценка которых не может превысить уже найденную α. Чтобы подсчитать приблизительную оценку ещё не посещённых узлов, к оценке их корневого узла прибавляется константа под названием **запас бесполезности** (futility margin). Если сумма не превышает текущую α, то все подузлы отсекаются.

3. [SEE based pruning](https://www.chessprogramming.org/Static_Exchange_Evaluation). Статическая оценка обмена (Static Exchange Evaluation или SSE) проверяет последствия разменов на определённом поле, которые произойдут после выбранного хода. В результате вычисления SSE даёт вероятное изменение материала, которое будет потеряно или получено. Если функция SSE вернула отрицательное значение (т.е. проигрыш материала), Stockfish не рассматривает последствия хода, который ведёт к размену.

4. [History Leaf Pruning](https://www.chessprogramming.org/History_Leaf_Pruning) основана на эвристики истории ([history heuristic](https://www.chessprogramming.org/History_Heuristic)). Идея в том, чтобы считать сколько раз конкретный ход вызвал отсечение независимо от позиции, в которой он был сделан. Когда счётчик превышает пороговое значение, соответствующее этому ходу поддерево отсекается.

5. [Multi-cut pruning](https://www.chessprogramming.org/Multi-Cut) — этот алгоритм выполняет сокращённый поиск в поддереве на небольшую глубину. Если из всех обойдённых узлов заданное число (например, три) оказалось fail-high node, то всё поддерево отсекается.

### 3.5.5 Функция оценки позиций

Stockfish использует следующие механизмы для оценки позиций:

* Запрограммированная оценка.
* Нейронная сеть [**NNUE**](https://www.chessprogramming.org/Stockfish_NNUE).

Рассмотрим, как они работают.

#### 3.5.5.1 Запрограммированная оценка

До 2020 год Stockfish использовал вручную запрограммированную статическую оценку позиции. Эта оценка складывается из нескольких факторов.

Сначала Stockfish подсчитывает материал в заданной позиции. Это самая простая и быстрая оценка.

Затем проверяется пешечная структура. Для этого используются разные эвристики. Чтобы применить эти эвристики, алгоритм Stockfish перебирает все пешки на доске одна за другой. Для каждой из них выполняется ряд проверок. Вот несколько примеров:

1. Является ли пешка проходной?
2. Является ли пешка отсталой?
3. Является ли пешка сдвоенной?

В первом случае владеющий пешкой игрок получает бонус, а в двух других — штраф.

После проверки пешек Stockfish делает аналогичный перебор по фигурам. Для каждой из них проверяется мобильность. Для мобильности подсчитывается число клеток, которые:

1. Фигура атакует.
2. Не заблокированы своими фигурами.
3. Не бьются пешками противника.

С помощью таблиц подсчитанные клетки перекладываются на числовую оценку.

Следующая оценка Stockfish проверяет позицию короля. Она включает следующее:

1. Потенциальные шахи.
2. Число атак на **кольцо короля**. Этим кольцом называется восемь клеток вокруг короля.

Далее Stockfish с помощью эвристик проверяет очевидные угрозы. Например, что противник атакует ферзя или может напасть на него за один ход.

Если партия находится в эндшпиле, то для каждой позиции Stockfish оценивает возможность победы. Эта оценка складывается из проверки набора фигур и их расположения на доске. Прежде всего оценивается число пешек. Если пешек мало, то выиграть эндшпиль тяжело. Потому что часто победа достигается проведением пешки в ферзи. Другой пример с оценкой позиции фигур. Если все пешки на одном фланге, то выиграть ладейный эндшпиль сложно. Такая позиция также получит низкую оценку.

Последняя проверка эндшпиля называется **фактор масштабирования**. Этот термин означает коэффициент, на который умножается уже подсчитанная оценка эндшпиля. Умножение происходит при выполнении некоторых условий. Например, если у сторон остались разноцветные слоны, то коэффициент будет от 1/3 до 1/2. Таким образом понижается общая оценка эндшпиля (положительная или отрицательная). Причина в том, что при разноцветных слонах выиграть эндшпиль тяжело.

В 2020 году версия Stockfish 12 перешла на статическую оценку позиции с помощью нейронной сети NNUE.

#### 3.5.5.2 Нейронная сеть NNUE

Сеть NNUE (efficiently updatable neural network) разработал японский учёный [Ю Насу](https://www.chessprogramming.org/Yu_Nasu) в 2018 году. Она представляет собой сеть с прямой связью (FNN) категории shallow learning. Ю Насу разрабатывал NNUE специально для оценки текущей позиции фигур на доске. Она не учитывает временные зависимости и последовательности событий.

Первая версия сети NNUE анализировала позиции не в шахматах, а в японской адаптации этой игры под названием [сёги](https://ru.wikipedia.org/wiki/Сёги). Ю Насу помимо научной деятельности участвовал в проектах по адаптации движка Stockfish для сёги. [YaneuraOu](https://www.chessprogramming.org/YaneuraOu) — это один из таких проектов. Его разработчики применили новую сеть NNUE для статической оценки позиции. Это усилило игру движка примерно на 500 Эло.

В проекте YaneuraOu участвовал другой японский учёный [Хисаюри Нода](https://www.chessprogramming.org/Hisayori_Noda). В качестве эксперимента он интегрировал сеть NNUE в оригинальный Stockfish версии 10 в 2019 году. Тесты показали усиление игры движка на 50 Эло. В течение года этот проект развивался как форк Stokfish под названием [Stockfish NNUE](https://www.chessprogramming.org/Stockfish_NNUE). Он заинтересовал многих разработчиков шахматных движков.

В августе 2020 года система тестирования Fishtest показала, что Stockfish NNUE сильнее оригинального движка на 80 пунктов Эло. Тогда разработчики Stockfish решили включить сеть NNUE в следующий официальный релиз. Все наработки форка Stockfish NNUE добавили в код Stockfish.

2 сентября 2020 года вышел первый релиз Stockfish версии 12 с сетью NNUE. Он играл значительно сильнее, чем предыдущая версия. Разработчики продолжают совершенствовать и обучать сеть NNUE. Эта работа усиливает игру движка Stockfish с каждым следующим релизом.

Рассмотрим, как устроена NNUE. Чтобы понять её архитектурные решения, сначала надо разобраться, какие цели ставил Ю Насу перед этой сетью. Учёный разрабатывал модель для замены вручную запрограммированной статической оценки позиции в минимаксном поиске с альфа-бета отсечением. Чтобы модель работала лучше чем запрограммированная оценка, она должна удовлетворять следующим требованиям:

1. Скорость работы модели должна быть сопоставима скорости запрограммированной оценки. Если модель работает слишком медленно, шахматный движок будет оценивать намного меньше позиций в секунду. Это значительно снизит силу его игры.

2. Модель должна выполнять инкрементальные вычисления. Каждый ход лишь незначительно меняет состояние доски. Поэтому для анализа текущего хода сеть должна использовать свои расчёты, выполненные для предыдущего хода.

3. Модель должна эффективно работать на том же оборудовании, которое использует запрограммированная оценка. Другими словами сеть должна работать на обычных CPU, а не GPU.

Ю Насу решил, что именно инкрементальные вычисления — это главная отличительная черта его новой модели. Поэтому он назвал её **эффективно обновляемая нейронная сеть** (efficiently updatable neural network. Сокращенное название сети EUNN можно записать в обратном порядке букв как NNUE. Это слово напоминает имя японского мифического существа [Нуэ](https://ru.wikipedia.org/wiki/Нуэ). Из-за этого сходства Ю Насу и назвал свою сеть NNUE.

Чтобы удовлетворить требованиям к модели, учёный сформулировал три принципа её организации:

1. Сеть должна иметь относительно небольшое количество ненулевых входов.

2. Входные данные должны меняться как можно меньше между последующими оценками.

3. Сеть должна быть достаточно простой, чтобы выводить результат низкой точности в целочисленном виде.

Первый принцип означает, что при **масштабировании сети** входные данные должны стать **редкими**. Масштабировании сети означает увеличение в ней числа нейронов, уровней или входных параметров. Данные называются редкими, когда значительная их часть — это нули или очень маленькие значения.

Когда у сети мало ненулевых входов, понижается верхняя граница времени, необходимого для полной оценки входных данных с нуля. Именно благодаря первому принципу, сети NNUE могут быть большими, но при этом быстро оценивать позиции.

Следование второму принципу позволяет сети переиспользовать результаты оценки позиции с прошлого хода. Это даёт дополнительный выигрыш в скорости работы.

Третий принцип означает, что модель должна оперировать целыми числами, а не [**числами с плавающей запятой**](https://ru.wikipedia.org/wiki/Число_с_плавающей_запятой). Такой перевод нейронной сети на целочисленные расчёты называется **квантованием**. Квантование значительно ускоряет обработку входных данных модели, поскольку обычные CPU выполняют целочисленные операции быстрее. Минус квантования в потере точности. Оно приводит к ошибке вычислений, которая накапливается тем больше, чем глубже сеть.

Из-за накопления ошибки в результате квантования модель должна иметь минимальное число скрытых слоёв. Это также необходимо, чтобы удовлетворить третье требование — использовать то же оборудование, что и запрограммированная оценка. Как только модель попадает в разряд deep learning, ей перестаёт хватать производительности обычных CPU для эффективной работы.

NNUE — это собирательное название для моделей, которые удовлетворяют трём принципам организации Ю Насу. Детали реализации каждой модели могут различаться. Это значит, что современные шахматные движки используют разные вариации NNUE. Более того разные версии Stockfish используют разные архитектуры NNUE.

Рассмотрим архитектуру под названием [**HalfKp**](https://www.chessprogramming.org/Stockfish_NNUE#HalfKP). Она подробно описана разработчиками проекта [nnue-pytorch](https://github.com/official-stockfish/nnue-pytorch/blob/master/docs/nnue.md) на Github. Именно вариант HalfKp был впервые интегрирован в Stockfish версии 10.

Затем архитектуру HalfKp развивал польский учёный [Томаш Собчик](https://www.chessprogramming.org/Tomasz_Sobczyk), который также участвует в проекте Stockfish. Так появились варианты NNUE под названием [**HalfKA**](https://www.chessprogramming.org/Stockfish_NNUE#HalfKA), HalfKAv2 (используется в Stockfish 14) и HalfKAv2_hm (используется в последнем Stockfish 16). Томаш Собчик оптимизировал оригинальную архитектуру HalfKp, чтобы ускорить время обучения модели и сократить объём обучающего набора данных.

Архитектура HalfKp — это shallow learning модель, которая имеет три скрытых слоя. Для начала рассмотрим, как устроен её входной слой. Входные данные NNUE сети должны быть редкими. Поэтому Ю Насу предложил для них специальный формат.

Всего на шахматной доске 64 поля. Есть 6 типов фигур: пешка, конь, слон, ладья, ферзь и король. Фигуры могут быть двух цветов: черные и белые. В качестве входных данных модели закодируем позиции фигур. Тогда каждый нейрон входного слоя будет соответствовать одному набору из трёх элементов: `(поле, фигура, цвет)`. Всего таких наборов будет: `64 * 6 * 2 = 768`. Если на поле S есть фигура P цвета C, то мы устанавливаем в 1 вход сети, соответствующий набору `(S,P,C)`. В противном случае этот вход устанавливаем в 0. Тогда в любой возможной шахматной позиции будет не более 32 ненулевых входов, поскольку на доске может находится не более 32 фигур. При этом любой ход меняет не более 4 входов сети (это случай рокировки). В среднем же один ход меняет менее 3-х входов.

Рассмотрим пример кодирования шахматной позиции на вход модели. Иллюстрация 3-32 демонстрирует позицию с четырьмя фигурами.

{caption: "Иллюстрация 3-32. Шахматная позиция с четырьмя фигурами", height: "40%"}
![Шахматная позиция с четырьмя фигурами](images/Chess/Stockfish-HalfKp-input.png)

Четыре фигуры на доске кодируются такими наборами: `(A1, король, белые)`, `(C3, пешка, белые)`, `(B8, король, черные)`, `(D4, ладья, черные)`. Ход пешки на c4 изменит вход `(C3, пешка, белые)` на 0, а вход `(C4, пешка, белые)` на 1. Ход пешки cxd4 изменит вход `(C3, пешка, белые)` на 0, вход `(D4, пешка, белые)` — на 1 и `(D4, ладья, черные)` — на 0.

Итак мы получили редкие входные данные, которые незначительно меняются после каждого хода. Как именно нейронная сеть использует это преимущество и выполняет инкрементальные вычисления? Для этого у неё есть механизм под названием **накапливающий сумматор** (accumulator). Его реализует первый скрытый слой модели.

Ю Насу не остановился на полученном формате и продолжил его оптимизировать. Он хотел получить ещё более редкие входные данные для модели. Для этого в каждый набор входных данных он добавил позицию короля так: `(поле_короля, поле_фигуры, фигура, цвет)`. Эти наборы есть для всех типов фигур кроме короля. Такой формат позволяет модели лучше понимать расположение фигур относительно короля. Общее количество таки наборов будет равно: `64*64*5*2=40960`. В HalfKp реализации NNUE для Stokfish есть 64 неиспользуемых входных набора, что даёт общую сумму входов модели: `40960 + 64 = 41024`. Эти входы использовались в сёги, но оказали ненужны для шахмат.

Новый формат сделал входные данные более редкими. Его единственный минус — это ход короля, который стал очень дорогостоящим. Он приводит к изменению всех входов модели. Ю Насу посчитал это приемлемым компромиссом.

У внимательного читателя мог возникнуть вопрос: позиция какого короля (белого или чёрного) указывается во всех входных наборах модели? Ответ — обоих королей. Архитектура HalfKp имеет два накапливающих сумматора: для чёрных и для белых. Это означает, что количество входных наборов тоже удваивается: позиции всех фигур относительно белого короля и то же самое относительно чёрного.

Решение с двумя накапливающими сумматорами приводит к дополнительным вычислениям. Во-первых, каждый ход приводит к пересчётам в самих сумматорах. Во-вторых, результаты сумматоров надо свести в конечный результат, который передаётся на второй скрытый слой сети. В HalfKp архитектуре это выполняется простым объединением выходных векторов y1 и y2 обоих сумматоров. Преимущество двух сумматоров в увеличении точности модели.

Возникает ещё один вопрос. Если есть входные наборы с точки зрения белого короля и чёрного, то чем они различаются? Для эффективной работы сети нужно, чтобы эти входные наборы отличались между собой. В противном случае увеличения точности модели не будет. В HalfKp архитектуре эта проблема решается сменой цвета фигур для точки зрения чёрных.

Ещё раз обратимся к позиции на иллюстрации 3-32. С учётом разворота доски она кодируется следующими двумя наборами:

* С точки зрения белых: `(A1, C3, пешка, белая)`, `(A1, D4, ладья, чёрная)`

* С точки зрения чёрных: `(B1, C6, пешка, чёрная)`, `(B1, D5, ладья, белая)`

Пример показывает, что для точки зрения чёрных поменялся не только цвет фигур, но и номера полей. Это произошло потому, что белые фигуры всегда начинают игру на горизонталях 1 и 2. Следовательно, смена цвета чёрного короля означает, что он находится не на поле b8, а на b1. То же самое справедливо для всех остальных фигур.

Теперь рассмотрим архитектуру HalfKp. Иллюстрация3-34 демонстрирует её схему. Она достаточно сложная. Чтобы её понять, сначала надо разобраться в том, как работают отдельные слои нейронных сетей.

Каждый слой любой нейронной сети имеет две важные характеристики:

1. Тип слоя.
2. Функция активации его нейронов.

Самые распространённые типы слоёв следующие:

1. **Линейный слой** (linear layer)
2. Свёрточный слой (convolution layer)
3. Слой подвыборки (pooling layer)
4. Рекуррентный слой (recurrent layer)

Все слои NNUE сети относятся к линейному типу. Поэтому сконцентрируемся только на нём.

Тип слоя определяет, как именно его нейроны соединены с нейронами предыдущего слоя. В случае линейного типа это прямая связь без замыканий. При такой связи информация распространяется в одном направлении: от входов нейронов слоя к их выходам.

В NNUE сети все линейные слои являются **полносвязными** (fully connected). Полносвязным называется слой, каждый нейрон которого связан с каждым нейроном предыдущего слоя.

Предположим, что в некоторой сети есть два слоя C и D. Выходы нейронов слоя C связаны со входами нейронов слоя D. Способ этой связи определяет, как преобразуются данные при их передаче от слоя C к D.

Допустим, что слой D линейный и полносвязный. Назовём выходные значения предыдущего слоя C `out_C`, а входные значения D — `in_D`. Тогда `in_D` рассчитывается по следующей формуле:
{width: "30%"}
![](images/Chess/nnue-linear-layer-formula.png)

В ней используются следующие обозначения:

* x — вектор выходных значений слоя C: `out_C`
* A — матрица весов размера `(in_D, out_C)`
* b — вектор смещения (bias) с размером `in_D`
* y — вектор входных значений слоя D: `in_D`.

Обратите внимание, что для этой формулы тип слоя C не важен.

Теперь поговорим о функции активации. Строго говоря это харакетеристика не самого слоя, а его строительной единицы — нейрона. Обычно все нейроны одного слоя имеют одинаковую функцию активации. Это выгодно с точки зрения скорости и эффективности обучения модели. Только в некоторых специлизированных архитектурах нейронных сетей это правило не выполняется.

Функция активации — это операция каждого отдельного нейрона над своими входными значениями. В результате этой операции получаются выходные значения нейрона.

Вернёмся к примеру с двумя слоями C и D. Функция активации каждого нейрона слоя D получает на вход значение из вектора `in_D`. Позиция значения в векторе определяет, какой именно нейрон слоя D его получит.

Выходные значения всех нейронов слоя D объединяются в вектор и передаются в следующий за ним слой (например E). В зависимости от типа слоя E, над этим вектором снова происходит преобразование с участием матрицы весов. Связи между нейронами слоёв D и E определяют, какое значение из выходного вектора слоя D получит какой нейрон слоя E.

Нейроны всех скрытых слоёв NNUE сети Stockfish используют функцию активации **clipped ReLU**. Ещё раз напомню, что функция активации относится к каждому отдельному нейрону. Формула clipped ReLU в HalfKp архитектуре выглядит так:
{width: "50%"}
![](images/Chess/nnue-clipped-relu-layer-formula-127.png)

В ней используются следующие обозначения:

* x — входное значение нейрона
* y — выходное значение нейрона.

Иллюстрация 3-33 демонстрирует график функции clipped ReLU.

{caption: "Иллюстрация 3-33. Функция активации clipped ReLU", height: "40%"}
![Функция активации Clipped ReLU](images/Chess/nnue-clipped-relu-graph.png)

**ReLU** — это сокращение от rectified linear unit, что переводится как усеченное линейное преобразование. Обычная ReLU функция преобразует входное значение значение x в результат y от 0 до положительной бесконечности. Если входное значение меньше или равно нулю, то ReLU выдаёт ноль. В противном случае — входное значение.

Функция Clipped ReLU ведёт себя как ReLU, но с одним отличием: выходные значения в ней ограничены некоторой константой. В случае HalfKp архитектуры эта константа равна 127. Если входное значение clipped ReLU оказалось больше 127, то на выходе мы получим 127. Для всех остальных входных значений выход будет таким же, как и для обычной ReLU функции.

Зачем в сети NNUE нужны слои с функцией активации нейронов clipped ReLU? Они добавляют нелинейность в модель. Если бы в ней были только слои с линейной функцией активации, их можно было бы свернуть в один. Для этого достаточно перемножить их матрицы весов. В результате сеть не смогла бы научиться оценивать сложные шахматные позиции. С другой стороны, сеть с нелинейностью способна аппроксимировать сложные нелинейные функции. Оценка позиции как раз и является такой функцией.

В архитектуре HalfKp используется не ReLU, а clipped ReLU из-за квантования. Оно требует уменьшения **динамического диапазона** входных данных скрытого слоя. Динамический диапазон означает диапазон значений, который слой сети может принимать на вход. Для случая HalfKp этот диапазон ограничен 127. Это важно для высокой скорости работы модели.

Теперь мы готовы познакомиться с общей схемой архитектуры HalfKp. Её демонстрирует иллюстрация 3-34.

{caption: "Иллюстрация 3-34. Архитектура HalfKp сети NNUE для Stockfish 10", height: "40%"}
![Архитектура HalfKp сети NNUE для Stockfish 10](images/Chess/Stockfish-NNUE-HalfKp.png)

В левой части иллюстрации изображена шахматная доска с некоторой позицией. Ход в ней делают белые.

Справа от доски мы видим два прямоугольника: серый и под ним белый. Серый прямоугольник объединяет нейроны входного слоя сети, которые соответствуют позициям фигур относительно чёрного короля. В белом прямоугольнике — нейроны входного слоя сети, соответствующие позициям фигур относительно белого короля. В каждом прямоугольнике по 41024 нейрона, что в сумме составляет 82048.

Входной слой любой сети с прямой связью не имеет весов и смещения, а его нейроны не имеют функции активации. Этот слой не выполняет никаких вычислений, а просто передаёт входные данные модели на следующий за ним скрытый слой.

Первый скрытый слой модели разделён на две части также как входной слой. Каждая часть выполянет роль накапливающего сумматора для соответствующей ей входных данных. В каждой части слоя по 256 нейронов, что в сумме даёт 512. Это значит, что вектор выходных значений слоя имеет размер 512.

Нейроны первого слоя в розовом прямоугольнике получают на вход позиции фигур относительно чёрного короля. Нейроны в зелёном прямогульнике — позиции фигур относительно белого короля.

Первый скрытый слой модели линейный с функцией активации нейронов clipped ReLU. Это означает, что сначала вектор с входными значениями этого слоя умножается на матрицу весов. У каждой части слоя своя матрица. Каждая из них имеет размер 41024x256. Каждый вес в матрице — это целое число со знаком размерностью 16 бит. К результату умножения прибавляются смещения  размерностью 16 бит. Смещения хранятся в векторе из 256 элементов.

После умножения на матрицу весов и прибавления смещения получаются входные значения для нейронов первого скрытого слоя. Они передаются в виде вектора из 512 элементов размерностью 8 бит. К каждому из них применяется функция активации clipped ReLU. В результате получается вектор выходных значений первого скрытого слоя. Это 512 целых чисел в диапазоне от 0 до 127.

Накапливающий сумматор отвечает за инкрементальные вычисления. Модель сохраняет результат умножения входных данных первого скрытого слоя на матрицу весов. После очередного хода этот результат обновляется в зависимости от изменения входных наборов `(поле_короля, поле_фигуры, фигура, цвет)`. Для обновления слой обрабатывает два простых случая:

* Входной набор i был удалён (1->0), тогда из сохранённого результата вычитается столбец i матрицы весов A.

* Входной набор i был добавлен (0->1), тогда к сохранённому результату прибавляется столбец i матрицы весов A.

Далее к изменившимся входным значения первого скрытого слоя применяется функция активации clipped ReLU.

Второй скрытый слой HalfKp сети состоит из 32 нейронов. Он линейный с функцией активации clipped ReLU. Линейный тип слоя означает, что каждый его нейрон связан со всеми нейронами предыдущего слоя. Таким образом второй скрытый слой объединяет выходные данный обоих сумматоров.

Матрица весов второго слоя имеет размер 512x32. Каждый вес в ней — это целое число со знаком размерностью 8 бит. После умножения матрицы весов на вектор входных получается вектор из 32 элементов размерностью 32 бита. К каждому из элементов добавляется 32 битное смещение. Результат делится на 64. После этого над ним выполняется функция clipped ReLU. В результате получается вектор из 32 чисел в диапазоне от 0 до 127. Это выходные данные второго скрытого слоя модели. 

Третий скрытый слой также как и второй состоит из 32 нейронов. Опять же это линейный слой с функцией активации clipped ReLU. Он работает точно так же как и второй слой. Единственное отличие в том, что его матрица весов имеет размер 32x32.

Выходной слой модели состоит из одного нейрона. Это линейный слой с функцией активации `y = x/16`. Его матрица весов имеет размер 32x1. Каждый вес имеет размерность 8 бит. После умножения вектора входных значений слоя на матрицу весов получается одно 32 битное целое число. Это число делится на 16. Так сеть HalfKp получает конечную оценку позиции на доске.

Для подготовки сети NNUE в Stockfish применяется алгоритм обучения с учителем. Он принимает на вход 16 миллиардов позиций и оценку для каждой из них. Позиции берутся из реальных партий с разными дебютами. Так достигается их разнообразие. Предварительную оценку позиций выполняет шахматный движок с открытым исходным кодом Leela Chess Zero.

Алгоритм обучения подбирает веса в сети NNUE так, чтобы она давала оценку позициям близкую к оценкам Leela Chess Zero. Значение оценки интерпретируется так же, как и для вручную запрограммированных алгоритмов. Чем большее число вернула сеть NNUE, тем позиция лучше для движка. Чем число меньше — тем позиция хуже.

Результат обучения нейросети проверяется с помощью системы тестирования Fishtest. Если движок Stockfish с новой сетью NNUE показывает лучшую игру, чем текущая версия движка — тест считается пройденным. В этом случае новая версия сети NNUE попадает в очередной релиз Stockfish.

Несмотря на все оптимизации в архитектуре сети NNUE её скорость работы всё равно уступает вручную запрограммированной оценки. Поэтому эта оценка до сих пор используется в Stockfish. Она применяется в позициях, когда скорость работы важнее чем точность оценки. Например, когда у одной из сторон значительный материальный перевес: как минимум в ферзя или ладью.

### 3.5.6 Результаты Stockfish

Stockfish можно считать эталонной реализацией шахматного движка, построенного на минимакс поиске с альфа-бета отсечением. Благодаря хорошей инфраструктуре проекта и открытому исходному коду, он продолжает активно развиваться.

Все коммерческие движки равняются на Stockfish. Именно его используют разработчики для тестирования и оценки силы своих  шахматных программ. Команда DeepMind не исключение. В 2017 году именно со Stockfish они сравнивали свою новую систему AlphaZero.

Многие коммерческие движки перенимают идеи Stockfish. Например, использование NNUE сети для оценки позиций. Несмотря на это, они остаются в роли догоняющего. Stockfish по-прежнему занимает первые строчки рейтинга самых сильных программ.

Влияние Stockfish на шахматный мир огромно. Прежде всего он помогает развивать современную шахматную теорию. Многие существующие шахматные начала были пересмотрены. Некоторые из них стали популярнее чем раньше, благодаря новым вариантам, которые помог открыть движок. Также Stockfish предложил новые идеи и для других стадий игры.

Большинство профессионалов и любителей использует Stockfish при подготовке к турнирам. Он позволяет эффективно анализировать сыгранные партии, находить допущенные ошибки и проверять альтернативные ходы, которые не были сыграны. Популярность Stockfish у профессионалов подтверждает его высокое качество.

{pagebreak}
